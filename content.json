{"meta":{"title":"七点一刻的魔法书","subtitle":"书里面记载了许多召唤术，可以召唤天使或者精灵为自己服务","description":"书里面记载了许多召唤术，可以召唤天使或者精灵为自己服务","author":"七点一刻","url":"https://liangyuanzheng.com","root":"/"},"pages":[{"title":"","date":"2025-10-27T00:35:42.225Z","updated":"2025-10-27T00:35:42.225Z","comments":true,"path":"baidu_verify_code-CycccvLKGr.html","permalink":"https://liangyuanzheng.com/baidu_verify_code-CycccvLKGr.html","excerpt":"","text":"dd04038418f28ad3b2b7186e448ea6b0"},{"title":"","date":"2025-10-27T00:35:42.225Z","updated":"2025-10-27T00:35:42.225Z","comments":true,"path":"google37bc4188ec049df8.html","permalink":"https://liangyuanzheng.com/google37bc4188ec049df8.html","excerpt":"","text":"google-site-verification: google37bc4188ec049df8.html"},{"title":"categories","date":"2017-07-08T08:49:47.000Z","updated":"2025-10-27T00:35:42.225Z","comments":true,"path":"index.html","permalink":"https://liangyuanzheng.com/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-08-28T15:05:50.000Z","updated":"2025-10-27T00:35:41.797Z","comments":true,"path":"about/index.html","permalink":"https://liangyuanzheng.com/about/index.html","excerpt":"","text":"七点一刻闲暇时，记一二句。 没有什么事儿是一句话讲不明白的。 如果有，那就写篇博客！ 【留言】 关于作者闲来无事，喜欢码字，欢迎关注，七点一刻 。 贡献本文使用 markdown 编写，提交 PR 时，文章排版请遵循 中文文案排版指北。 转载合作转载本指南，请注明 GitHub 链接，谢谢！ 协议&#x2F;License本作品采用 GNU General Public License v3.0 进行许可。"},{"title":"categories","date":"2017-07-08T08:49:47.000Z","updated":"2025-10-27T00:35:42.225Z","comments":true,"path":"categories/index.html","permalink":"https://liangyuanzheng.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-08T08:50:20.000Z","updated":"2025-10-27T00:35:42.225Z","comments":true,"path":"tags/index.html","permalink":"https://liangyuanzheng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"反切注音法","slug":"反切注音法","date":"2025-10-26T14:11:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"反切注音法.html","link":"","permalink":"https://liangyuanzheng.com/%E5%8F%8D%E5%88%87%E6%B3%A8%E9%9F%B3%E6%B3%95.html","excerpt":"","text":"在看《资治通鉴》时，发现用于解释的小字部分有“治，直之翻”之类的字眼，请问这个“翻”是什么意思呀？ 即反切。古时的注音方法。唐以前人们祇称某某反，唐代人们忌称“反”而改称“切”，也有叫“翻”的，後人合称反切。反切，套成现代术语，基本方法是取前一字的声母和後一字的韵母与声调，二者相拼，就得到了一个新的读音。但知道了这些祇能解决一部分反切的拼读，而不是全部。楼主所举就有一些无法顺利拼读。还有一些专门知识要铺垫纔能全部解决。 还有“扶问翻”，“他综翻”，“户计翻”，“直之翻”，还有“直吏翻”等好多的。你都能理解了。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"界门纲目科属种","slug":"界门纲目科属种","date":"2025-10-26T14:11:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"界门纲目科属种.html","link":"","permalink":"https://liangyuanzheng.com/%E7%95%8C%E9%97%A8%E7%BA%B2%E7%9B%AE%E7%A7%91%E5%B1%9E%E7%A7%8D.html","excerpt":"","text":"分类","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"关于传国玉玺印文的几种说法","slug":"关于传国玉玺印文的几种说法","date":"2025-10-26T09:53:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"关于传国玉玺印文的几种说法.html","link":"","permalink":"https://liangyuanzheng.com/%E5%85%B3%E4%BA%8E%E4%BC%A0%E5%9B%BD%E7%8E%89%E7%8E%BA%E5%8D%B0%E6%96%87%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%B4%E6%B3%95.html","excerpt":"","text":"传国玉玺的印文以“受命于天，既寿永昌”的说法最为普遍。 据众多文献记载，秦始皇命丞相李斯以鱼虫篆书书写这八个字，玉工孙寿将其刻于传国玉玺之上￼￼￼。不过，也有一些文献如《宋书·礼志》等记载其印文为“受天之命，皇帝寿昌”￼￼￼。此外，《汉书》中还记载有“昊天之命，皇帝寿昌”的说法。 综合来看，“受命于天，既寿永昌”这一说法在历史传承中更为常见，被大多数人所认可。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"秦王扫六合","slug":"秦王扫六合","date":"2025-10-24T14:44:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"秦王扫六合.html","link":"","permalink":"https://liangyuanzheng.com/%E7%A7%A6%E7%8E%8B%E6%89%AB%E5%85%AD%E5%90%88.html","excerpt":"","text":"&#x3D;&#x3D;秦王扫六合中的“六合”指的是战国时期被秦国灭亡的六个诸侯国：齐、楚、燕、韩、赵、魏‌&#x3D;&#x3D; 六合的具体含义与历史背景“六合”本义为天地四方，但在“秦王扫六合”的语境中特指战国七雄中除秦国以外的六个诸侯国。秦王嬴政（即秦始皇）于公元前230年至前221年发动统一战争，依次灭韩、赵、魏、楚、燕、齐，建立中国历史上第一个中央集权制国家。 六个国家的列表 &#x3D;&#x3D;‌齐‌&#x3D;&#x3D;：位于今山东一带，末代君主为齐王建。 &#x3D;&#x3D;‌楚‌&#x3D;&#x3D;：位于长江流域，末代君主为楚王负刍。 &#x3D;&#x3D;‌燕‌&#x3D;&#x3D;：位于今河北北部，末代君主为燕王喜。 &#x3D;&#x3D;‌韩‌&#x3D;&#x3D;：位于今河南中部，末代君主为韩王安。 &#x3D;&#x3D;‌赵‌&#x3D;&#x3D;：位于今山西、河北一带，末代君主为赵王迁。 &#x3D;&#x3D;‌魏‌&#x3D;&#x3D;：位于今河南东部，末代君主为魏王假。 事件的意义秦统一六国结束了春秋战国以来的分裂局面，奠定了中国多民族统一国家的基础，并推行了统一度量衡、货币和文字等制度。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"资治通鉴","slug":"资治通鉴","permalink":"https://liangyuanzheng.com/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"}]},{"title":"周郑交质（《左传》）","slug":"周郑交质（《左传》）","date":"2025-07-09T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"周郑交质（《左传》）.html","link":"","permalink":"https://liangyuanzheng.com/%E5%91%A8%E9%83%91%E4%BA%A4%E8%B4%A8%EF%BC%88%E3%80%8A%E5%B7%A6%E4%BC%A0%E3%80%8B%EF%BC%89.html","excerpt":"","text":"人物： 周平王：周天子，周幽王之子。郑武公：卿士（执政官）。郑庄公：卿士。虢：西虢公，周王室卿士。王子狐：姬狐，周平王次子。史称“王子狐”。郑公子忽：郑庄公的太子，后即位为昭公。郑祭足：祭仲，郑国大夫。 故事： 东周初期，郑国积极服侍周王室，和周天子建立了良好的君臣关系。后来，周平王宠信西虢公，周王室和郑国的关系开始恶化，周平王为了缓解矛盾，取信郑庄公，于是发生了互相交换人质的事情。【王子狐为质于郑，郑公子忽为质于周】 周平王驾崩，周朝又把国政交给西虢了。郑国不乐意了，于是，有了两次收周庄稼的事情。【四月，郑祭仲帅师取温之麦。秋，又取成周之禾】从此，周郑便结仇了。【周郑交恶】 鉴赏： 相互之间的了解和信任要建立在彼此体谅、坦诚相待的基础上。【信为由中，质无益也】 郑庄公咄咄逼人，交质本身是平等关系才有的事。一个诸侯国竟然与周交质，东周已经礼崩乐坏，也没有能力约束诸侯国了。 原文： 周郑交质（左丘明著历史散文）_百度百科","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"古文观止","slug":"古文观止","permalink":"https://liangyuanzheng.com/tags/%E5%8F%A4%E6%96%87%E8%A7%82%E6%AD%A2/"}]},{"title":"每日一库：gocyclo-——-Go-圈复杂度分析工具","slug":"每日一库：gocyclo-——-Go-圈复杂度分析工具","date":"2025-05-18T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：gocyclo-——-Go-圈复杂度分析工具.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Agocyclo-%E2%80%94%E2%80%94-Go-%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.html","excerpt":"","text":"简介gocyclo 是一个用于计算 Go 代码中函数的​​圈复杂度（Cyclomatic Complexity）​​的开源工具。圈复杂度是衡量代码复杂性的重要指标，通过分析代码中的分支路径数量，帮助开发者识别需要重构的高复杂度函数，从而提升代码可维护性和测试覆盖率。 核心功能​​1️⃣圈复杂度计算​​根据以下规则计算函数的复杂度： 基础复杂度为 1（每个函数起始值）。 每遇到 if、for、switch（或 case）、&amp;&amp;、|| 时复杂度 +1。 ​2️⃣高复杂度函数识别​​支持通过阈值过滤、排序展示高复杂度函数，帮助快速定位潜在问题。 安装通过 Go 命令一键安装： 1go install github.com/fzipp/gocyclo/cmd/gocyclo@latest 安装后，确保 $GOPATH/bin 在系统 PATH 中，即可全局使用 gocyclo 命令。 使用示例​1️⃣基本用法​​分析当前目录及子目录下的所有 Go 文件： 123456# 分析当前目录下所有 Go 文件gocyclo .# 输出示例：# 5 main parseConfigFile src/cmd/main.go:25:1# 8 util calculateMetrics src/pkg/util/metrics.go:12:1 ​2️⃣​过滤高复杂度函数​​显示复杂度超过 15 的函数，并触发非零退出码（适用于 CI&#x2F;CD 检测）： 12# 仅显示复杂度 &gt;= 15 的函数gocyclo -over 15 . ​3️⃣显示 Top N 复杂函数​​列出当前目录下最复杂的 10 个函数： 1gocyclo -top 10 . ​4️⃣计算平均复杂度​​输出所有函数的平均复杂度（短格式）： 1gocyclo -avg-short . ​5️⃣忽略指定文件&#x2F;目录​​使用正则表达式忽略测试文件、第三方库等： 1gocyclo -ignore \"_test|vendor/\" . 输出格式示例输出： 1239 gocyclo (*complexityVisitor).Visit complexity.go:30:18 7 main main.go:53:17 Average: 2.72 每行字段含义：&lt;复杂度&gt; &lt;包名&gt; &lt;函数名&gt; &lt;文件:行:列&gt;末尾的平均值为所有函数的平均值（包括未输出的低复杂度函数）。 高级特性 ​​忽略特定函数​​ 通过添加 //gocyclo:ignore 注释忽略指定函数： 1234//gocyclo:ignorefunc HighComplexityFunction() &#123; // 复杂逻辑...&#125; ​​集成到开发流程​​ 结合 CI 工具（如 GitHub Actions），通过 -over 参数设置复杂度阈值，自动阻止不符合规范的代码合并。 适用场景 ​​代码审查​​：快速定位高复杂度函数，提高审查效率。 ​​重构指导​​：识别需要拆分的复杂函数，降低维护成本。 ​​质量门禁​​：在 CI 流程中设置复杂度阈值，确保代码质量。 总结​​gocyclo​​ 是 Go 开发者提升代码质量的利器，通过量化复杂度帮助团队建立代码规范。其轻量级、易集成的特性，使其成为日常开发、代码审查和自动化流程中的必备工具。建议结合 go vet、staticcheck 等工具，构建全面的代码质量检测体系。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"}]},{"title":"每日一库：Copier-Go-语言的结构体复制神器","slug":"每日一库：Copier-Go-语言的结构体复制神器","date":"2025-05-14T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Copier-Go-语言的结构体复制神器.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9ACopier-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%8D%E5%88%B6%E7%A5%9E%E5%99%A8.html","excerpt":"","text":"简介copier 是一个轻量级的 Go 语言库，专注于简化结构体之间的数据复制。通过自动或自定义的字段映射，它能够高效处理结构体、切片、甚至嵌套类型的复制，减少手动赋值的冗余代码。由知名 GORM 作者 jinzhu 开发，稳定性和设计理念值得信赖。 核心功能1️⃣结构体 ↔ 结构体复制 自动匹配同名字段：无需配置，自动复制名称和类型相同的字段。 标签支持：通过 copier:&quot;目标字段名&quot; 标签映射不同名称的字段。 嵌套结构体：自动递归复制嵌套的结构体（默认深度复制）。 1234567891011121314151617type User struct &#123; Name string Age int&#125;type Employee struct &#123; Name string Age int `copier:\"UserAge\"` // 显式映射到源结构体的 Age 字段 Salary float64&#125;func main() &#123; user := User&#123;Name: \"Alice\", Age: 30&#125; employee := Employee&#123;&#125; copier.Copy(&amp;employee, &amp;user) // employee.Name = \"Alice\", employee.UserAge = 30&#125; 2️⃣切片 ↔ 切片复制 自动将源切片元素逐个复制到目标切片。 支持不同类型切片（需元素类型可转换）。 123users := []User&#123;&#123;Name: \"Alice\"&#125;, &#123;Name: \"Bob\"&#125;&#125;var employees []Employeecopier.Copy(&amp;employees, &amp;users) // employees 成为包含两个 Employee 的切片 3️⃣自定义转换函数 注册函数处理特定类型或字段的转换逻辑（如时间格式、枚举解析），自动处理基础类型转换（如 int ↔ int32、string ↔ []byte）。 支持自定义转换器：通过 copier.RegisterConverter 注册函数处理复杂类型转换。 1234567891011copier.CopyWithOption(&amp;dest, &amp;src, copier.Option&#123; Converters: []copier.TypeConverter&#123; &#123; SrcType: time.Time&#123;&#125;, DstType: copier.String, Fn: func(src interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return src.(time.Time).Format(\"2006-01-02\"), nil &#125;, &#125;, &#125;,&#125;) 4️⃣忽略字段 使用 copier:&quot;-&quot; 标签跳过指定字段。 1234type Config struct &#123; APIKey string `copier:\"-\"` // 复制时忽略此字段 Port int&#125; 5️⃣深度复制（Deep Copy） 对指针、切片、映射等引用类型创建独立副本，避免副作用。 6️⃣复制选项（Option） IgnoreEmpty：跳过源字段为零值（如 &quot;&quot;、0、nil）的复制。 1copier.CopyWithOption(&amp;dest, &amp;src, copier.Option&#123;IgnoreEmpty: true&#125;) // 源字段为空时不覆盖目标 CaseInsensitive：启用不区分大小写的字段匹配（如 Source.Name 匹配 Target.NAME） DeepCopy：深度复制指针、切片等引用类型（默认浅复制）。 123src := &amp;User&#123;Addresses: []Address&#123;&#123;City: \"NY\"&#125;&#125;&#125;var dest Usercopier.CopyWithOption(&amp;dest, src, copier.Option&#123;DeepCopy: true&#125;) // 复制切片内容而非指针 典型应用场景 DTO 转换：将数据库模型（Model）转换为 API 响应体（DTO）或前端所需的 JSON 结构。 配置覆盖：合并默认配置和用户自定义配置，忽略敏感字段。 微服务通信：不同服务间消息结构的转换，如 gRPC 消息 ↔ 内部结构体。 测试数据构造：快速生成测试对象的变体，避免重复初始化逻辑。 实战示例场景：API 响应过滤敏感字段 123456789101112131415161718type UserModel struct &#123; ID int Email string Password string&#125;type UserResponse struct &#123; ID int `json:\"id\"` Email string `json:\"email\"` // Password 字段被排除&#125;func GetUser(ctx *gin.Context) &#123; user := getUserFromDB() // 获取数据库模型 var resp UserResponse copier.Copy(&amp;resp, &amp;user) // 自动复制 ID 和 Email，跳过 Password ctx.JSON(200, resp)&#125; 总结copier 是处理 Go 结构体复制的神器，尤其适合需要频繁进行数据转换的场景。尽管反射带来轻微性能损耗，但其带来的代码简洁性和可维护性提升，在大多数项目中利大于弊。推荐在 Web 开发、微服务架构或任何涉及多数据模型转换的项目中尝试使用。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"}]},{"title":"《荀子》强国","slug":"《荀子》强国","date":"2025-05-04T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"《荀子》强国.html","link":"","permalink":"https://liangyuanzheng.com/%E3%80%8A%E8%8D%80%E5%AD%90%E3%80%8B%E5%BC%BA%E5%9B%BD.html","excerpt":"","text":"积微，月不胜日，时不胜月，岁不胜时。凡人好敖慢小事，大事至，然后兴之务之。如是，则常不胜夫敦比于小事者矣！是何也？则小事之至也数，其县日也博，其为积也大。大事之至也希，其县日也浅，其为积也小。故，善日者王，善时者霸，补漏者危，大荒者亡！故，王者敬日，霸者敬时，仅存之国，危而后戚之。亡国，至亡而后知亡，至死而后知死。亡国之祸败，不可胜悔也。霸者之善箸也，可以时托也。王者之功名，不可胜日志也。财物货宝以大为重，政教功名者反是，能积微者速成。诗曰：“德如毛，民鲜克举之。”此之谓也。 注释《荀子》 “积微”","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"每日一库：Excelize——Go语言高效处理Excel的利器","slug":"每日一库：Excelize——Go语言高效处理Excel的利器","date":"2025-04-29T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Excelize——Go语言高效处理Excel的利器.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AExcelize%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86Excel%E7%9A%84%E5%88%A9%E5%99%A8.html","excerpt":"","text":"1. 库简介Excelize 是用 Go 语言编写的开源库，专注于处理 Excel 文件（XLSX 格式）。由 qax-os 组织维护，支持创建、读取、编辑复杂 Excel 文档，适用于报表生成、数据导入导出等场景。 GitHub - qax-os&#x2F;excelize: Go language library for reading and writing Microsoft Excel™ (XLAM &#x2F; XLSM &#x2F; XLSX &#x2F; XLTM &#x2F; XLTX) spreadsheets 2. 核心功能 基础操作：创建&#x2F;保存文件、增删工作表、读写单元格数据。 样式设置：自定义字体、颜色、边框、对齐方式等，支持合并单元格。 高级元素：插入图表（柱状图、折线图等）、图片、公式计算。 数据处理：数据验证（如下拉列表）、条件格式、数据透视表。 流式 API：处理大数据时通过 StreamWriter 逐行写入，降低内存占用。 并发安全：API 设计支持多 Goroutine 并发操作，适合高并发场景。 3. 快速入门示例12345678910111213141516171819package mainimport ( \"fmt\" \"github.com/xuri/excelize/v2\")func main() &#123; f := excelize.NewFile() defer f.Close() // 创建新Sheet并写入数据 index, _ := f.NewSheet(\"Sheet2\") f.SetCellValue(\"Sheet1\", \"A1\", \"Hello\") f.SetCellValue(\"Sheet2\", \"B2\", 123) f.SetActiveSheet(index) if err := f.SaveAs(\"Book1.xlsx\"); err != nil &#123; fmt.Println(\"保存失败:\", err) &#125;&#125; 4. 高级特性 样式定义：通过 NewStyle 创建样式对象，应用至单元格： 12style, _ := f.NewStyle(&amp;excelize.Style&#123;Font: &amp;excelize.Font&#123;Bold: true&#125;&#125;)f.SetCellStyle(\"Sheet1\", \"A1\", \"A1\", style) 插入图表：指定数据范围生成图表： 1f.AddChart(\"Sheet1\", \"E1\", `&#123;...&#125;`) // JSON 配置图表参数 流式写入：高效处理大数据： 123456streamWriter, _ := f.NewStreamWriter(\"Sheet1\")for row := 1; row &lt;= 10000; row++ &#123; cell, _ := excelize.CoordinatesToCellName(1, row) streamWriter.SetRow(cell, []interface&#123;&#125;&#123;fmt.Sprintf(\"Row %d\", row)&#125;)&#125;streamWriter.Flush() 添加三维簇状柱形图​​： 123456789chart := &amp;excelize.Chart&#123; Type: excelize.Col3DClustered, Series: []excelize.ChartSeries&#123; &#123;Name: \"Sheet1!$A$2\", Categories: \"Sheet1!$B$1:$D$1\", Values: \"Sheet1!$B$2:$D$2\"&#125;, // 添加更多数据系列... &#125;, Title: []excelize.RichTextRun&#123;&#123;Text: \"Fruit Sales Analysis\"&#125;&#125;,&#125;f.AddChart(\"Sheet1\", \"E1\", chart) ​​插入图片（支持缩放与打印设置）​​： 12345err := f.AddPicture(\"Sheet1\", \"A2\", \"image.png\", &amp;excelize.GraphicOptions&#123; ScaleX: 0.5, ScaleY: 0.5, PrintObject: &amp;enable, // 控制是否可打印&#125;) 5. 优势与适用场景 功能全面：覆盖 Excel 操作几乎所有需求，从基础到高级功能。 高性能：流式 API 和并发安全设计优化资源使用。 易用性：API 设计简洁，文档详尽，社区活跃（GitHub 19k+ Star）。 适用场景：Web 后端数据导出、自动化报表、数据分析工具等。 6. 对比与选型相较于 tealeg/xlsx，Excelize 更新更活跃，支持更多新特性（如公式、数据透视表）。若项目需复杂 Excel 操作或高性能处理，推荐优先选择 Excelize。 7. 总结Excelize 是 Go 生态中处理 Excel 的首选库，平衡了功能丰富性与性能，适合各类需要高效操作 Excel 文件的场景。通过其清晰的 API 和强大功能，开发者能轻松实现复杂的电子表格交互需求。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"}]},{"title":"She（Groove-Coverage-2004年发行的单曲）","slug":"She（Groove-Coverage-2004年发行的单曲）","date":"2025-04-28T08:52:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"She（Groove-Coverage-2004年发行的单曲）.html","link":"","permalink":"https://liangyuanzheng.com/She%EF%BC%88Groove-Coverage-2004%E5%B9%B4%E5%8F%91%E8%A1%8C%E7%9A%84%E5%8D%95%E6%9B%B2%EF%BC%89.html","excerpt":"","text":"She hangs out every day near by the beach 她每天躺在海滩边的吊床上 Havin’ a HEINEKEN fallin’ asleep喝杯海涅肯啤酒便入睡 She looks so sexy when she’s walking the sand漫步在沙滩的她看上去如此性感 Nobody ever put a ring on her hand她也不接受任何人的戒指 Swim to the oceanshore fish in the sea海边游泳海里捕鱼 She is the story the story is she她就是传说传说就是她 She sings to the moon and the stars in the sky她向天上的月亮和星星唱歌 Shining from high above you shouldn’t ask why那样高高闪耀着你又怎么知道为什么 She is the one that you never forget见过她你便永远不能忘记 She is the heaven-sent angel you met过她你便知道她是天使 Oh, she must be the reason why God made a girl噢，她就是上帝制造女孩的原因 She is so pretty all over the world即使走遍全世界她也是如此的美丽 She puts the rhythm, the beat in the drum她哼着小曲打着圆鼓 She comes in the morning and the evening she’s gone早上出现晚上就不见 Every little hour every second you live你活着的每分没秒 Trust in eternity that’s what she gives都相信永恒因为那是她带来的 She looks like Marilyn, walks like Suzanne她看上去像Marilyn，走路又像Suzanne She talks like Monica and Marianne她说话则像Monica和Marianne She wins in everything that she might do只要她愿意她可以得到一切 And she will respect you forever just you但她永远都尊重你只是因为是你 She is the one that you never forget见过她你便永远不能忘记 She is the heaven-sent angel you met见过她你便知道她是天使 Oh, she must be the reason why God made a girl噢，她就是上帝制造女孩的原因 She is so pretty all over the world即使走遍全世界她也是如此的美丽 She is so pretty all over the world即使走遍全世界她也是如此的美丽 She is so pretty她如此的美丽 She is like you and me她就像你和我 Like them like we像他们像我们 She is in you and me她就在你我中间 She is the one that you never forget见过她你便永远不能忘记 She is the heaven-sent angel you met见过她你便知道她是天使 Oh, she must be the reason why God made a girl噢，她就是上帝制造女孩的原因 She is so pretty all over the world即使走遍全世界她也是如此的美丽 (She is the one) She is the one她就是 (That you never forget) That you never forget你永远都不会忘记 She is the heaven-sent angel you met见过她你便知道她是天使 She’s the reason (oh she must be the reason) why God made a girl噢，她就是上帝制造女孩的原因 She is so pretty all over the world即使走遍全世界她也是如此的美丽 Oh…Na na na na na na….","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"TODO","slug":"todo","permalink":"https://liangyuanzheng.com/tags/todo/"},{"name":"英文","slug":"英文","permalink":"https://liangyuanzheng.com/tags/%E8%8B%B1%E6%96%87/"},{"name":"歌词","slug":"歌词","permalink":"https://liangyuanzheng.com/tags/%E6%AD%8C%E8%AF%8D/"}]},{"title":"每日一库：ImGo —— 简洁链式调用的 Go 图像处理库","slug":"每日一库：ImGo-——-简洁链式调用的-Go-图像处理库","date":"2025-04-26T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：ImGo-——-简洁链式调用的-Go-图像处理库.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AImGo-%E2%80%94%E2%80%94-%E7%AE%80%E6%B4%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84-Go-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%BA%93.html","excerpt":"","text":"1 项目简介ImGo 是一个基于 Go 语言的开源图像处理库，旨在提供类似 PHP 中 Intervention Image 的链式调用体验，让开发者能够通过简洁的代码实现复杂的图像操作，例如加载、调整尺寸、叠加图片、保存等。其命名来源于 “Image Golang” 的缩写，设计灵感源于弥补 Go 生态中缺乏直观链式调用图像处理工具的空白。 GitHub - fishtailstudio&#x2F;imgo: Golang image handling and manipulation library. Golang 图片处理库。 2 核心特性 链式调用语法：支持类似 Load().Resize().Insert().Save() 的链式操作，代码可读性高，逻辑清晰。 丰富的图像操作：包括调整大小、裁剪、叠加图片等基本操作，模糊、像素化、颜色调整（亮度、对比度）等特效，支持 jpeg、png、gif 等常见格式。 跨平台兼容性：基于 Go 语言开发，天然支持跨平台运行。 轻量高效：依赖简洁，资源占用低，适合高频次图像处理场景。 3 安装与使用通过 Go 模块直接安装： 1go get -u github.com/fishtailstudio/imgo ⓵ 加载图片 → 调整尺寸 → 叠加水印 → 保存 123456789package mainimport \"github.com/fishtailstudio/imgo\"func main() &#123; imgo.Load(\"background.png\"). Resize(250, 350). Insert(\"gopher.png\", 50, 50). Save(\"out.png\")&#125; 这段代码展示了从加载图片到保存的全流程，通过链式调用一气呵成。 ⓶ 模糊处理 1imgo.Load(\"input.jpg\").Blur(10).Save(\"blurred.jpg\") ⓷ 像素化效果​​ 1mgo.Load(\"input.jpg\").Pixelate(20).Save(\"pixelated.jpg\") ​​⓸ 绘制形状​​ 1imgo.Create(500, 500, \"#FFFFFF\").DrawRect(100, 100, 200, 200, \"#FF0000\").Save(\"rect.png\") ⓹ 创建纯色图像 1234567imgo.New(400, 300). // 创建一个 400x300 像素的空白图像 SetBgColor(imgo.RGB&#123;255, 200, 150&#125;). // 设置背景颜色为浅橙色 Text(\"Hello ImGo\", 100, 150, imgo.TextOption&#123; FontSize: 24, Color: imgo.Black, &#125;). // 添加文本 Save(\"text-image.png\") 4 设计背景开发者因 Go 生态中原有库（如 gg）文档不全且缺乏链式调用体验，受 PHP 的 Intervention Image 启发而创建 ImGo，旨在提供更符合直觉的 API 设计。 5 对比其他库 imaging：提供基础的调整大小、裁剪功能，但 API 为函数式调用，缺乏链式连贯性。 imagor：专注于高性能服务器端图像处理，适合 Web 服务，但复杂度较高。 ImGo 的优势在于 开发效率，适合需要快速实现图像处理逻辑的应用场景。 6 社区与贡献 项目鼓励开发者通过提交 Issue 或 Pull Request 参与改进。 文档和示例代码较为简洁，适合新手快速上手。 7 应用场景 Web 应用图片预处理：如用户上传图片的缩略图生成、水印添加。 批量图像处理脚本：结合命令行工具实现自动化操作。 ​​创意工具​​：通过代码生成艺术图像或动态图形。 教育或原型开发：链式语法易于教学和验证图像处理逻辑。 8 未来展望尽管当前功能聚焦基础操作，但未来可扩展方向包括： 滤镜效果（如模糊、锐化）。 格式转换支持（如 WebP 或 HEIC）。 性能优化：结合 libvips 等高效后端提升处理速度。 9 总结ImGo 凭借链式调用和简洁 API，成为 Go 生态中图像处理的轻量级优选。虽然功能尚未覆盖高级特效，但其设计哲学与易用性使其在快速开发场景中脱颖而出。对于需要复杂功能的用户，可结合其他高性能库（如 imagor）使用。 参考源码与文档： GitHub 仓库 快速入门示例","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"}]},{"title":"每日一库：ants-Go-高性能-Goroutine-池","slug":"每日一库：ants-Go-高性能-Goroutine-池","date":"2025-04-25T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：ants-Go-高性能-Goroutine-池.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Aants-Go-%E9%AB%98%E6%80%A7%E8%83%BD-Goroutine-%E6%B1%A0.html","excerpt":"","text":"每日一库：Ants —— 高性能低损耗的 Goroutine 池 GitHubAnts 是 Go 语言领域一款广受好评的高性能 Goroutine 池库，由开发者 panjf 2000 开源维护。它通过池化技术优化了原生 Goroutine 的资源管理问题，显著提升了大规模并发任务的执行效率和资源利用率，尤其适用于高并发场景下的任务调度与资源复用。 GitHub - panjf2000&#x2F;ants: 🐜🐜🐜 ants is the most powerful and reliable pooling solution for Go. 核心功能与特性 资源复用与动态管理Ants 通过预创建和复用 Goroutine，避免了频繁创建和销毁协程的开销。支持动态调整池容量，可根据任务负载自动扩缩容，确保资源合理分配。 高性能与低内存损耗相比原生 Goroutine，Ants 在批量任务场景下内存占用更低。例如，处理 100 万个任务时，Ants 的内存消耗仅为原生 Goroutine 的 60%-80%，同时吞吐量提升显著。 灵活的调度策略 阻塞与非阻塞模式：任务提交时，若池满可配置为阻塞等待或直接返回错误，适应不同场景需求。 任务超时控制：支持设置任务执行的超时时间，避免因任务卡死导致资源泄漏。 优雅关闭：提供 Release() 方法安全释放池资源，确保所有任务完成后再终止。 动态容量调整：运行时通过 Tune() 动态调整池的大小。 丰富的接口与扩展性 提供 Submit() 快速提交任务，支持同步和异步执行。 可获取池状态（如运行中的 Goroutine 数量、池容量等）。 支持自定义任务处理逻辑，例如绑定上下文或错误处理。 应用场景 高并发服务：如 Web 服务器处理海量 HTTP 请求时，通过限制并发数避免资源耗尽。 批量数据处理：ETL 任务、日志分析等需并行处理大量数据的场景。 实时任务调度：物联网设备监控、实时消息推送等低延迟要求的应用。 资源敏感型应用：嵌入式系统或内存受限环境中，需严格控制协程数量。 快速上手示例安装12345# v1 版本（传统）go get -u github.com/panjf2000/ants# 使用 Go Modules 安装 v2 版本（需 Go 1.16+）go get github.com/panjf2000/ants/v2 基础用法1）示例：提交并等待任务完成 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"sync\" \"time\" \"github.com/panjf2000/ants/v2\")func main() &#123; defer ants.Release() // 程序退出前释放池 var wg sync.WaitGroup task := func() &#123; defer wg.Done() time.Sleep(100 * time.Millisecond) fmt.Println(\"Task executed!\") &#125; // 创建容量为 10 的池 pool, _ := ants.NewPool(10) defer pool.Release() for i := 0; i &lt; 100; i++ &#123; wg.Add(1) _ = pool.Submit(func() &#123; task() &#125;) // 提交任务 &#125; wg.Wait() fmt.Printf(\"Running goroutines: %d\\n\", pool.Running())&#125; 2）示例：动态调整容量 12345678910111213// 创建容量为 10000 的池p, _ := ants.NewPool(10000)defer p.Release() // 使用完毕后释放// 提交任务for i := 0; i &lt; 1000; i++ &#123; ants.Submit(func() &#123; // 任务逻辑 &#125;)&#125;// 动态调整容量p.Tune(2000) // 扩容至 2000 3）示例：预分配内存 1p, _ := ants.NewPool(100000, ants.WithPreAlloc(true)) 4）示例：处理任务 panic 1234// 自定义 panic 处理函数p, _ := ants.NewPool(10, ants.WithPanicHandler(func(err interface&#123;&#125;) &#123; log.Printf(\"任务异常: %v\", err)&#125;)) 技术实现剖析 工作池架构Ants 维护一个 Goroutine 队列（Worker Pool），任务提交后从池中获取空闲 Worker 执行。Worker 执行完毕后回归池中，避免重复创建。 锁与原子操作优化使用 sync.Mutex 和原子计数器（如 int32）管理池状态，平衡性能与线程安全。 内存预分配通过对象池（sync. Pool）复用任务结构体，减少 GC 压力。 性能对比 场景 原生 Goroutine Ants 池化 内存占用（100 万任务） ~4.8 GB ~2.6 GB 任务完成时间 ~1.5 秒 ~1.2 秒 （数据来源：Ants 官方 Benchmark 测试） 性能优势• 内存高效：复用 Goroutine 减少内存分配。• 吞吐量提升：通过任务队列调度，减少 Goroutine 切换开销。• Benchmark 表现：官方测试显示，ants 池化后性能显著优于无限制的 Goroutine。 社区生态与资源 文档与示例：GitHub 仓库提供详细文档及多种场景的代码示例（如超时控制、自定义 Worker 函数）。 持续维护：项目定期更新，支持最新 Go 版本并修复潜在问题。 扩展性：可结合其他库（如 grpool）实现更复杂的任务调度策略。 总结Ants 通过池化技术解决了 Go 原生 Goroutine 在大规模并发场景下的资源管理难题，是构建高性能、高可靠并发应用的利器。其简洁的 API 设计、卓越的性能表现和灵活的扩展能力，使其成为 Go 开发者工具箱中的重要组件。无论是微服务架构还是数据处理流水线，Ants 都能显著提升系统的稳定性和效率。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"},{"name":"协程","slug":"协程","permalink":"https://liangyuanzheng.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"资治通鉴 庙号","slug":"庙号","date":"2025-04-24T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"庙号.html","link":"","permalink":"https://liangyuanzheng.com/%E5%BA%99%E5%8F%B7.html","excerpt":"","text":"庙号，是中国、朝鲜、越南古代帝王去世后，后人在太庙之中奉祀的追尊的名号。 起源庙号起源于商朝。最原始的庙号只有四种： 太：创基立业曰“太”，太祖汤、太宗太甲。高：功高者曰“高”，高祖王亥、高宗武丁。世：世代祭祀曰“世”，世祖盘庚、世宗且甲。中：中兴者曰“中”，中宗且乙。 周朝未使用庙号，仅使用谥号。 严谨 –&gt; 宽松到了唐朝开始，原本慎重严谨的庙号制度大为放宽。除了部分亡国之君及短命皇帝之外，一般都有庙号，原始的四种庙号就不够用了，因此逐渐参考谥法订出新的庙号，不过开国的前几代君王，其庙号大多仍使用传承自商朝的原始四个庙号。 自唐以后，庙号在前，谥号在后的连称方式，成为帝王的全号。 习惯的变化唐以前的皇帝有庙号的较少，因此一般称谥号，如汉武帝、隋炀帝。 唐以后皇帝基本都有庙号，而谥号从武则天开始字数不断增加，特别是明清时已经增加到十七至二十三字。所以，史书多称庙号，如唐太宗、宋太宗等。 自唐以后，谥号泛滥。 参考 庙号 - 维基百科，自由的百科全书 庙号_百度百科","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"DOING","slug":"doing","permalink":"https://liangyuanzheng.com/tags/doing/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"资治通鉴","slug":"资治通鉴","permalink":"https://liangyuanzheng.com/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"}]},{"title":"每日一库：cron-Go-高性能定时任务库","slug":"每日一库：cron-Go-高性能定时任务库","date":"2025-04-24T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：cron-Go-高性能定时任务库.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Acron-Go-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%BA%93.html","excerpt":"","text":"robfig/cron 是一个用于 Go 语言的定时任务调度库，支持标准的 cron 表达式语法，允许开发者以简单的方式定义和管理周期性任务。以下是它的核心特性和使用方法的详细介绍。 1 项目基本信息 项目名称：robfig&#x2F;cron 项目地址：GitHub - robfig&#x2F;cron 项目定位：Go 语言的定时任务调度库，支持标准 Cron 表达式解析、时区处理、任务链拦截等功能，适用于构建需要定时执行任务的应用程序（如批处理、数据同步、监控等）。 2 核心特性 Cron 表达式支持兼容 Unix&#x2F;Linux 的 cron 表达式语法（支持到秒级精度），例如 0 30 * * * * 表示每小时的第 30 分钟执行。 灵活的任务调度支持秒级（6 段）、分钟级（5 段）两种表达式格式。 任务链（Job Chaining）可以通过 JobWrapper 实现任务执行前后的拦截逻辑（如日志、统计、超时控制）。 任务恢复机制当某个任务执行时发生 panic，可通过 Recover() 恢复并记录错误。 轻量且线程安全适用于高并发场景，提供优雅的任务启停接口。 3 快速开始3.1 安装1go get github.com/robfig/cron/v3@v3.0.0 # v3 是最新稳定版 3.2 示例代码12345678910111213141516171819202122232425package mainimport (true\"fmt\"true\"github.com/robfig/cron/v3\")func main() &#123;truec := cron.New()true// 添加任务：每分钟执行一次true_, _ = c.AddFunc(\"* * * * *\", func() &#123;truetruefmt.Println(\"执行任务：每分钟触发\")true&#125;)true// 添加任务：每天10:30执行true_, _ = c.AddFunc(\"0 30 10 * * *\", func() &#123;truetruefmt.Println(\"执行任务：每天10:30\")true&#125;)truec.Start() // 启动调度器truedefer c.Stop() // 程序退出前停止trueselect&#123;&#125; // 阻塞主线程（或根据实际需求调整）&#125; 4 Cron 表达式格式⓵ 标准格式（5 段） 分 时 日 月 星期 示例：0 30 * * * 表示每小时的第 30 分钟执行。 ⓶ 扩展格式（6 段，支持秒） 秒 分 时 日 月 星期 示例：0 0 12 * * * 表示每天12:00:00执行。 5 高级功能5.1 自定义日志1234c := cron.New(truecron.WithLogger(truetruecron.VerbosePrintfLogger(log.New(os.Stdout, \"cron: \", log.LstdFlags)),) 5.2 错误处理任务执行时的 panic 会被捕获并记录： 1c := cron.New(cron.WithPanicLogger(log.Printf)) 5.3 任务链（JobWrapper）1234567891011// 添加一个带超时控制的任务c := cron.New()chain := cron.NewChain(truecron.Recover(cron.DefaultLogger), // 捕获 panictruecron.DelayIfStillRunning(cron.DefaultLogger),)// 将任务包装到链中_, _ = c.AddJob(\"0 0 * * * *\", chain.Then(cron.FuncJob(func() &#123;true// 执行任务&#125;)) 5.4 任务执行控制​​123456// 延迟执行直到前任务完成cron.New( cron.WithChain( cron.DelayIfStillRunning(logger), )) 5.5 ​​动态任务管理​​123// 运行时添加/删除任务entryID := c.Schedule(cron.Every(10*time.Minute), cron.FuncJob(task))c.Remove(entryID) 6 性能与可靠性​​ ​​精确调度​​：基于系统时间轮询，误差通常在毫秒级 ​​并发安全​​：支持多 goroutine 调用 AddFunc 和 Remove ​​资源占用​​：每个任务独立 goroutine 执行，需注意资源泄漏 7 常见问题⓵ 如何停止任务？ 调用 c.Stop() 会等待正在执行的任务完成后再关闭调度器。 ⓶ 如何动态添加&#x2F;删除任务？ 添加任务：entryID, _ := c.AddFunc(...) 删除任务：c.Remove(entryID) ⓷ 时区问题 默认使用本地时区，可通过 cron.WithLocation 指定： 12location, _ := time.LoadLocation(\"Asia/Shanghai\")c := cron.New(cron.WithLocation(location)) ⓸ v3 版本向后不兼容变更​ ​​导入路径​​：必须使用 github.com/robfig/cron/v3 ​​构造函数​​：使用函数式选项（如 cron.WithLogger()） ​​错误处理​​：不再自动恢复 panic（需手动添加 Recover 中间件） ⓹ ​v3 版本表达式解析调整​​​ 123// 旧版（默认含秒）：需显式切换解析器parser := cron.NewParser(cron.SecondOptional | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)cron.New(cron.WithParser(parser)) ⓺ v1 vs v3版本差异 v3 引入了模块化设计（如 cron.WithLogger 配置）。 v3 默认支持秒级精度（表达式为 6 段），而 v1 仅支持 5 段。 v3 的 API 更简洁（如 cron.New() 替代 cron.NewCron()）。 8 总结适用场景： 定时执行后台任务（如数据清理、报表生成）。 分布式系统中的定时心跳检测。 需要高精度（秒级）或复杂调度逻辑的任务。 优势： 代码简洁，API 设计友好。 社区活跃，稳定性高（广泛用于生产环境）。 对比标准库：Go 标准库的 time.Ticker 适合简单周期性任务，而 robfig/cron 更适合需要灵活 cron 表达式控制的场景。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"},{"name":"定时任务","slug":"定时任务","permalink":"https://liangyuanzheng.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"每日一库：Google-UUID（Go语言实现）","slug":"每日一库：Google-UUID（Go语言实现）","date":"2025-04-22T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Google-UUID（Go语言实现）.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AGoogle-UUID%EF%BC%88Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%89.html","excerpt":"","text":"Google 的 uuid 库是一个用于生成和操作 UUID（Universally Unique Identifier，通用唯一标识符） 的 Go 语言开源库，支持 UUID 的多个版本（v1-v5）。它提供简洁的 API，适合需要唯一标识符的分布式系统、数据库主键、日志追踪等场景。 GitHub - google&#x2F;uuid: Go package for UUIDs based on RFC 4122 and DCE 1.1: Authentication and Security Services. 核心功能 生成 UUID v1: 基于时间戳和 MAC 地址（可能涉及隐私，需谨慎使用）。 v3&#x2F;v5: 基于命名空间和字符串的哈希（v3 用 MD 5，v5 用 SHA-1）。 v4: 基于密码学安全的随机数生成（最常用，推荐默认使用）。 ​v6 &amp; v7​​：时间有序的 UUID（较新标准，适合作为数据库主键）。12345678910111213141516package mainimport ( \"fmt\" \"github.com/google/uuid\")func main() &#123; // 生成 v4 UUID id := uuid.New() fmt.Println(\"UUID v4:\", id) // 生成 v1 UUID idV1, _ := uuid.NewUUID() fmt.Println(\"UUID v1:\", idV1)&#125; 解析与格式化 从字符串解析 UUID，支持带&#x2F;不带连字符的格式。 格式化为标准字符串、URN 或字节数组。12345678910// 字符串解析s := \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"parsedUUID, err := uuid.Parse(s)if err != nil &#123; panic(err)&#125;fmt.Println(\"Parsed UUID:\", parsedUUID)// 转换为字节数组bytes := parsedUUID[:] 比较与零值检查 直接比较两个 UUID 是否相等。 检查 UUID 是否为零值（全零）。123456uuid1 := uuid.New()uuid2 := uuid.New()fmt.Println(\"Equal?\", uuid1 == uuid2) // falsezeroUUID := uuid.UUID&#123;&#125;fmt.Println(\"Is zero?\", zeroUUID == uuid.Nil) // true 特点与优势 安全性：v4 使用 crypto/rand 生成随机数，满足加密安全要求。 轻量高效：无外部依赖，性能优秀。 符合 RFC 4122：严格遵循 UUID 标准规范。 灵活的格式化：支持多种字符串和二进制格式转换。 适用场景 分布式系统唯一 ID（如微服务请求追踪）。 数据库主键或唯一约束字段。 防止冲突的临时文件名、会话 Token 等。 注意事项 版本选择 v4：默认推荐，无需担心隐私泄露。 v1：需注意 MAC 地址暴露风险。 v3&#x2F;v5：确保命名空间唯一性（如使用 DNS、URL 等）。 性能优化 避免频繁生成 UUID（如循环中），必要时可预生成批次。 存储优化 数据库存储时可用 BINARY(16) 代替字符串节省空间。 示例：生成命名空间 UUID（v5）12345// 使用 DNS 命名空间生成 UUID v5namespaceDNS := uuid.MustParse(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")name := \"example.com\"uuidV5 := uuid.NewSHA1(namespaceDNS, []byte(name))fmt.Println(\"UUID v5:\", uuidV5) 总结Google 的 uuid 库以简洁的 API 和可靠性成为 Go 生态中 UUID 生成的首选。无论是需要随机性（v4）还是基于命名空间的标识符（v3&#x2F;v5），它都能满足需求，且适合高并发场景。使用时注意版本特性，结合业务需求选择即可。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"DONE","slug":"done","permalink":"https://liangyuanzheng.com/tags/done/"},{"name":"uuid","slug":"uuid","permalink":"https://liangyuanzheng.com/tags/uuid/"}]},{"title":"每日一库：now-——-Go-语言时间处理工具库","slug":"每日一库：now-——-Go-语言时间处理工具库","date":"2025-04-21T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：now-——-Go-语言时间处理工具库.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Anow-%E2%80%94%E2%80%94-Go-%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%BA%93.html","excerpt":"","text":"简介jinzhu&#x2F;now 是一个专注于简化 Go 语言时间操作的轻量级库。它扩展了标准库 time 的功能，提供了一系列便捷方法，用于计算时间段的开始&#x2F;结束时刻、解析灵活的时间字符串，并支持自定义配置（如周起始日、时区等）。适用于日志统计、报表生成等需要复杂时间计算的场景。 GitHub - jinzhu&#x2F;now: Now is a time toolkit for golang 核心功能 时间计算 获取时间段的起始&#x2F;结束点：支持从分钟到年度的各粒度计算，如： 12now.BeginningOfDay() // 当天 00:00:00now.EndOfMonth() // 当月最后一天的 23:59:59.999999999 动态调整周起始日：默认以周日为一周开始，可配置为周一： 12now.WeekStartDay = time.Mondaynow.BeginningOfWeek() // 返回本周一的 00:00:00 时间解析 智能补全日期：支持不完整字符串的解析，自动填充缺失部分为当前时间： 123now.Parse(\"2017\") // 2017-01-01 00:00:00now.Parse(\"10-13\") // 当前年份的 10 月 13 日now.Parse(\"14\") // 当天 14:00:00 • 严格错误处理：Parse 返回错误，MustParse 在解析失败时触发 panic。 灵活配置 自定义时区与格式：支持指定时区和扩展时间格式： 123456loc, _ := time.LoadLocation(\"Asia/Shanghai\")config := &amp;now.Config&#123; TimeLocation: loc, TimeFormats: []string&#123;\"2006/01/02\"&#125;,&#125;t := config.Parse(\"2023/10/01\") 基于特定时间计算 可基于任意时间点（而非当前时间）进行计算： 12t := time.Date(2023, 2, 18, 17, 0, 0, 0, time.UTC)now.With(t).EndOfQuarter() // 2023-03-31 23:59:59.999999999 使用示例12345678910111213141516171819202122package mainimport ( \"fmt\" \"github.com/jinzhu/now\" \"time\")func main() &#123; // 计算当前时间的周结束时刻（默认周日为起始） endOfWeek := now.EndOfWeek() fmt.Println(\"End of Week (Sun):\", endOfWeek) // 配置周起始日为周一 now.WeekStartDay = time.Monday fmt.Println(\"End of Week (Mon):\", now.EndOfWeek()) // 解析字符串并处理错误 if t, err := now.Parse(\"2023-10-12 22:14\"); err == nil &#123; fmt.Println(\"Parsed Time:\", t) &#125;&#125; 扩展性 添加自定义时间格式：通过扩展 TimeFormats 支持更多格式： 12now.TimeFormats = append(now.TimeFormats, \"2006年01月02日\")t := now.MustParse(\"2023年10月01日\") 注意事项 精度处理：EndOf 系列方法返回纳秒级最大值（如 23:59:59.999999999），确保涵盖时间段的最后一刻。 错误处理：使用 Parse 时需检查错误，避免无效格式导致程序中断。 贡献与社区 作者：Jinzhu Zhang（联系邮箱： &#119;&#111;&#x73;&#109;&#x76;&#x70;&#64;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109; ） 开源贡献：欢迎提交 PR 添加新功能或修复问题。 总结Jinzhu&#x2F;now 凭借其简洁的 API 和灵活的配置，成为 Go 开发者处理复杂时间操作的利器。无论是统计时段的界定，还是动态时间解析，该库都能显著提升开发效率。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"日期","slug":"日期","permalink":"https://liangyuanzheng.com/tags/%E6%97%A5%E6%9C%9F/"}]},{"title":"每日一库：go-astisub-——-专注于​​多格式字幕文件的处理","slug":"每日一库：go-astisub-——-专注于​​多格式字幕文件的处理","date":"2025-04-20T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：go-astisub-——-专注于​​多格式字幕文件的处理.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Ago-astisub-%E2%80%94%E2%80%94-%E4%B8%93%E6%B3%A8%E4%BA%8E%E2%80%8B%E2%80%8B%E5%A4%9A%E6%A0%BC%E5%BC%8F%E5%AD%97%E5%B9%95%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86.html","excerpt":"","text":"项目简介go-astisub 是一个用 Go 语言编写的开源库，专注于多种字幕格式的解析、编辑和转换。支持主流格式如 .srt、.ssa/.ass、.stl、.ttml、.vtt（WebVTT）、teletext 等，提供时间轴调整、分段&#x2F;合并、格式转换等实用功能。适合需要处理字幕的开发者或视频处理工具链集成。 GitHub 地址：https://github.com/asticode/go-astisubGitHub - asticode&#x2F;go-astisub: Manipulate subtitles in GO (.srt, .ssa&#x2F;.ass, .stl, .ttml, .vtt (webvtt), teletext, etc.) 核心功能1. 格式支持： 输入&#x2F;输出格式：SRT、SSA&#x2F;ASS、STL、TTML、WebVTT、Teletext。 支持跨格式转换（如 SRT 转 TTML）。 2. 操作功能： 时间轴调整：整体偏移（Sync）、线性校正（基于两点时间戳的线性缩放）。 分段与合并：按时长分割字幕（Fragment）或合并多个字幕文件（Merge）。 优化：自动删除空白或重叠字幕，提升可读性。 反分段：合并被过度分割的字幕片段（Unfragment）。 3. CLI 工具： 提供命令行工具，无需编程即可完成常见操作： 123456# 转换格式astisub convert -i input.srt -o output.ttml# 时间轴线性校正（如修正不同步问题）astisub apply-linear-correction -i input.srt -a1 1s -d1 2s -a2 5s -d2 7s -o output.srt# 合并字幕astisub merge -i s1.srt -i s2.ttml -o merged.srt 安装通过 Go Modules 安装： 1go get github.com/asticode/go-astisub 使用示例场景：将 SRT 字幕转换为 WebVTT 格式，并整体延迟 2 秒。 1234567891011121314151617181920212223package mainimport ( \"github.com/asticode/go-astisub\" \"time\")func main() &#123; // 读取 SRT 文件 subs, err := astisub.OpenFile(\"input.srt\") if err != nil &#123; panic(err) &#125; // 调整时间：整体延迟 2 秒 subs.Add(time.Second * 2) // 保存为 WebVTT 格式 err = subs.Write(\"output.vtt\") if err != nil &#123; panic(err) &#125;&#125; 适用场景 视频处理工具：集成到视频转码、剪辑工具中自动调整字幕。 多语言支持：批量转换字幕格式以适应不同播放平台。 字幕修正：修复时间轴不同步问题或合并多语言字幕。 项目亮点 模块化设计：每个字幕格式有独立处理模块（如 srt.go、ttml.go），易于扩展。 测试覆盖：提供完备的测试用例（*_test.go），稳定性较高。 MIT 协议：允许商业使用和修改，无法律风险。 注意事项 错误处理：示例代码省略错误处理，实际使用需检查返回值（如文件解析失败）。 格式特性差异：转换时可能丢失高级样式（如 ASS 的特效），建议在支持最完整格式的 TTML 或 ASS 中编辑。 总结go-astisub 是 Go 生态中处理字幕的瑞士军刀，适合需要高可靠性字幕操作的场景。其简洁的 API 和多格式支持使其成为开发视频相关应用的理想选择。对于更复杂的字幕样式需求，建议结合专业工具（如 FFmpeg）使用。 GitHub 地址：asticode&#x2F;go-astisub推荐指数：★★★★☆（字幕处理需求的 Go 开发者必备）","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"字幕","slug":"字幕","permalink":"https://liangyuanzheng.com/tags/%E5%AD%97%E5%B9%95/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"}]},{"title":"每日一库：retry-go-——-Go-语言轻量级重试库","slug":"每日一库：retry-go-——-Go-语言轻量级重试库","date":"2025-04-19T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：retry-go-——-Go-语言轻量级重试库.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9Aretry-go-%E2%80%94%E2%80%94-Go-%E8%AF%AD%E8%A8%80%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%87%8D%E8%AF%95%E5%BA%93.html","excerpt":"","text":"概述retry-go 是一个简单易用的 Go 语言重试库，由 Avast 开源。它提供灵活的重试策略和丰富的配置选项，适用于需要网络请求、资源访问等场景的错误重试。与其他重试库（如 cenkalti/backoff）相比，retry-go 的接口更直观，支持带返回值重试和动态条件控制，适合快速集成到项目中。 Github：https://github.com/avast/retry-go GitHub - avast&#x2F;retry-go: Simple golang library for retry mechanism 核心特性 简洁的 API 设计：• retry.Do()：执行无返回值的重试逻辑。• retry.DoWithData()：执行带返回值的重试逻辑（支持泛型）。 多种延迟策略：• 指数退避（默认）、固定延迟、随机抖动，支持自定义组合。 灵活的重试条件：• 根据错误类型、重试次数、自定义逻辑动态控制是否重试。 上下文支持：• 集成 context.Context，支持超时或手动取消重试任务。 错误处理：• 收集所有重试错误，或仅返回最后一次错误。• 支持将错误标记为不可恢复（Unrecoverable），立即终止重试。 快速开始安装1go get github.com/avast/retry-go 基本用法：HTTP GET 重试123456789101112131415161718192021url := \"http://example.com\"var body []byteerr := retry.Do( func() error &#123; resp, err := http.Get(url) if err != nil &#123; return err &#125; defer resp.Body.Close() body, err = io.ReadAll(resp.Body) return err &#125;, retry.Attempts(3), // 最大重试次数 retry.Delay(time.Second),// 重试间隔)if err != nil &#123; log.Fatal(\"请求失败:\", err)&#125;fmt.Println(string(body)) 带返回值的重试使用 DoWithData 简化返回值处理： 1234567891011body, err := retry.DoWithData( func() ([]byte, error) &#123; resp, err := http.Get(url) if err != nil &#123; return nil, err &#125; defer resp.Body.Close() return io.ReadAll(resp.Body) &#125;, retry.Attempts(5),) 高级配置1. 延迟策略• 指数退避（默认）： 1retry.DelayType(retry.BackOffDelay) • 固定延迟： 12retry.DelayType(retry.FixedDelay)retry.Delay(500 * time.Millisecond) // 固定 500ms • 随机抖动： 12retry.DelayType(retry.RandomDelay)retry.MaxJitter(1 * time.Second) // 最大抖动 1s • 组合策略（如固定延迟 + 随机抖动）： 1234retry.DelayType(retry.CombineDelay( retry.FixedDelay, retry.RandomDelay,)) 2. 自定义重试条件通过 RetryIf 根据错误类型判断是否重试： 123456retry.Do( fetchData, retry.RetryIf(func(err error) bool &#123; return strings.Contains(err.Error(), \"timeout\") &#125;),) 标记不可恢复错误： 12345678err := retry.Do( func() error &#123; if criticalError &#123; return retry.Unrecoverable(errors.New(\"致命错误\")) &#125; return nil &#125;,) 3. 无限重试与上下文123456789ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)defer cancel()retry.Do( task, retry.Attempts(0), // 无限重试 retry.Context(ctx), // 绑定上下文 retry.Delay(time.Second),) 4. 重试回调记录每次重试日志： 123retry.OnRetry(func(attempt uint, err error) &#123; log.Printf(\"第 %d 次重试，错误: %v\", attempt, err)&#125;) 版本迁移注意• v 1 → v 2：retry.Delay 的语义从“基础单位”变为“最终延迟”，移除 retry.Units。• v 0 → v 1：函数名从 Retry 改为 Do，新增 Options 模式。 对比其他库 库名 特点 适用场景 retry-go 简单直观，支持泛型返回值 快速集成，通用重试逻辑 cenkalti&#x2F;backoff 复杂退避算法，Google 官方实现 高并发场景，精细控制 matryer&#x2F;try 链式调用，高人气 偏好流式接口的项目 总结retry-go 是 Go 生态中轻量级重试库的优选，尤其适合：• 需要快速实现 HTTP 请求重试。• 希望灵活控制重试条件与延迟策略。• 需要结合上下文管理（如超时取消）。 通过合理配置 Options，可以轻松应对从简单到复杂的需求，是提升系统容错能力的利器。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"工具箱","slug":"工具箱","permalink":"https://liangyuanzheng.com/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1/"}]},{"title":"千字文注","slug":"千字文注","date":"2025-04-19T06:13:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"千字文注.html","link":"","permalink":"https://liangyuanzheng.com/%E5%8D%83%E5%AD%97%E6%96%87%E6%B3%A8.html","excerpt":"","text":"《千字文》全文拼音及解读 注解天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。 玄黄：天地的颜色。玄，接近黑色的深青色。宇宙：指整个时间和空间，又指天地。 盈：满。 昃：倾斜。 辰：星辰。 宿：星宿。 寒来暑往，秋收冬藏。闰余成岁，律吕调阳。云腾致雨，露结为霜。 闰余成岁：指古代历法用闰月、闰日来调整年岁。 调阳：古代用于乐律的器具，共十二管，以竹管或金属管制成，阴阳各六个。其中六种阳调称为律，指的是表示单数的黄钟、太簇、姑洗、蕤宾、夷则、元射这六个管；六种阴调称为吕，指的是表示双数的大吕、夹钟、仲吕、林钟、南吕、应钟这六个管。十二律对应 12 个月。古人认为律吕可以调和阴阳节令。《汉书·律历志》“律十有二，阳六为律，阴六为吕。” 调阳：指用律吕调阴阳，能使时序不紊乱。 结：聚，合，凝。 金生丽水，玉出昆冈。剑号巨阙，珠称夜光。 金：黄金。 丽水：古代河流名，金沙江流经今云南丽江境内的一段被称为丽江，也称丽水，此处自古便出道黄金。《韩非子·内储说上》：“荆南之地，丽水之中生金，人多窃采金。” 昆冈：昆仑山，位于今新疆和田北，这里出产著名的和田玉。 巨阙：古代名剑，以锋利著称。《荀子·性恶》：“桓公之蔥，太公之阙，文王之录，庄君之曶，阖闾之干将、莫邪、巨阙、辟闾，此皆古之良剑也。” 夜光：传说夜间放光，也被称为夜明珠。 果珍李柰，菜重芥姜。海咸河淡，鳞潜羽翔。 柰 nai4：即沙果，也被称作花红，形似苹果，但比苹果小。 重：尊尚。 芥：种子可以研磨成芥末，作调味品。 姜：调味品，有辛辣味。 鳞潜：鱼儿在水中游。鱼有鳞片，故以鳞代指鱼类。潜，水中潜游。 羽翔：鸟儿在天空中飞翔。鸟儿的翅膀为羽毛，故以羽代指鸟。 龙师火帝，鸟官人皇。始制文字，乃服衣裳。 龙师：指太昊伏羲。《左传·昭公十七年》：“太昊氏以龙纪，故为龙师而龙名。” 火帝：炎帝，以火德王，以火名官。一说火帝指的是钻木取火的燧（sui 4）人氏。 鸟官：即少昊氏。黄帝之子少昊氏所封百官都带鸟字。 人皇：传说上古部落联盟领袖，与天皇、地皇合你三皇。 始制文字：黄帝时，史官仓颉创造了文字。 乃服衣裳：黄帝时嫘祖发明养蚕，制造衣服。衣裳：衣服的总称，上为衣下为裳。 推位让国，有虞陶唐。吊民伐罪，周发殷汤。 推位让国：禅让帝位。三代禅让，唐尧把天子之位让给虞舜，虞舜把天子之位禅让给夏禹。推和让都是辞让、禅（shan 4）让的意思。 有虞：即舜。帝尧将君位禅让于帝舜。舜帝，姚姓，名重华，号有虞氏。 陶唐：尧帝，姓尹祁，名放勋，因封于唐，称唐尧，因其曾被封于陶和唐，故又称陶唐。 吊：慰问，抚恤。伐：征讨，讨伐。 周发：周武王姬发。 殷汤：商汤，也叫成汤。 坐朝问道，垂拱平章。爱育黎首，臣伏戎羌。遐迩一体，率宾归王。 坐朝：君主坐在朝堂上，指听取并处理政事。 问道：请教治国的道理。 垂拱：垂衣拱手，什么都不做。常用来赞颂君主无为而治。 平章：辨别彰明。平者正之，使不倾；章者明之，使不昧。也作筹划之意，指将国家治理得很好。《尚书·尧典》：“九族既睦，平章百姓。” 爱：关怀。 育：养育，教化。 黎首：黎民黔首，指百姓。黎：黑色。首：头。古代百姓庶民不能着衣冠，露出黑色的头发，故用黎首指庶民、百姓。 戎羌：我国古代的两个少数民族，这里指代少数民族，泛指其他民族。旧有东夷、南蛮、西戎、北狄之说。 遐而：远近。一体：一样，一同。指无论远近都归一成为整体。 率宾：指四海之内。归：归顺。 鸣凤在竹，白驹食场。化被草木，赖及万方。 鸣凤在竹：凤为灵禽，只出现于有道之世。相传，凤以竹为食，故出现于竹林间。 白驹食场：白驹食于苗场。 化被草木：德化遍及草木。这里比喻有道君主的德泽。 赖及万方：恩典遍及万方。赖，利，这里是恩典的意思。 盖此身发，四大五常。恭惟鞠养，岂敢毁伤。 身发：身体发肤。 四大：有两种说法，一种指地、水、火、风，这是印度哲学中的概念，经由佛教传入中国，佛教认为这四种元素构成万物。四大也用来代指身体。第二种则是道教的概念，意为道、天、地、王（一说人），此说法出自老子。 五常：有多种解释。第一种，父义、母慈、兄友、弟恭、子孝；第二种、君臣、父子、兄弟、夫妻、朋友；第三种、仁、义、礼、智、信；第四种，金、木、水、火、土。 女慕贞洁，男效才良。知过必改，得能莫忘。罔谈彼短，靡恃己长。信使可覆，器欲难量。 得能莫忘：受到别人的恩惠不能忘怀。能，这里是恩惠、好处的意思。 器欲难量：气度深广，难以测量。 墨悲丝染，诗赞羔羊。景行维贤，克念作圣。德建名立，形端表正。 墨悲丝染：墨子，墨家学派创始人。悲，悲叹。《墨子·所染》：“子墨子言见染丝者而汉曰：‘染于苍则苍，染于黄则黄。所入者变，其色亦变。’”意思是墨家学派的创始人墨子感叹人如白丝，原因纯洁质朴，可一旦染了颜色，便失去了本来面目，想恢复本性已来不及。 诗赞羔羊：意指《诗经·召南·羔羊》，这篇诗歌以羔羊皮毛的洁白无瑕来比喻君子德行的纯洁。《毛传》：“在位皆节俭正直，德如羔羊也。” 空谷传声，虚堂习听。祸因恶积，福缘善庆。尺璧非宝，寸阴是竞。 资父事君，曰严与敬。孝当竭力，忠则尽命。 临深履薄，夙兴温凊。似兰斯馨，如松之盛。川流不息，渊澄取映。 似兰斯馨，如松之盛：像幽兰一样幽香，像松树一样茂盛。 容止若思，言辞安定。笃初诚美，慎终宜令。荣业所基，籍甚无竟。 荣业：盛大的功业。基：本，依靠。 籍甚：盛大。无竟：没有穷尽。 学优登仕，摄职从政。存以甘棠，去而益咏。 乐殊贵贱，礼别尊卑。上和下睦，夫唱妇随。 外受傅训，入奉母仪。诸姑伯叔，犹子比儿。孔怀兄弟，同气连枝。交友投分，切磨箴规。 外受傅训：出外接受师傅的教诲。 孔怀：非常关怀。孔：很，过甚。怀：思念，想念。 仁慈隐恻，造次弗离。节义廉退，颠沛匪亏。性静情逸，心动神疲。守真志满，逐物意移。坚持雅操，好爵自縻。 都邑华夏，东西二京。背邙面洛，浮渭据泾。 都邑华夏：华夏都邑。华夏：中国。都邑：京都，京城。 东西二京：指东都洛阳和西京长安。西京长安，义如其名，正是“长治久安”的意思，有“古都之首”的美誉，更是与开罗、雅典、罗马并称为“世界四大古都”。东京洛阳，也称“千年帝都”，洛河两岸分布着二里头夏都遗址、偃师商都、东周王城、汉魏古城、隋唐洛阳城等五大都城遗址，历史极为悠久。 浮渭居泾：指长安左邻渭水，右靠泾水。 宫殿盘郁，楼观飞惊。图写禽兽，画彩仙灵。丙舍旁启，甲帐对楹。 盘郁：曲折美盛的样子。 楼观：高大富丽的建筑物。 飞惊：形容建筑物高耸入云，令人惊叹。 图写禽兽，画彩仙灵：指宫殿楼阁画满彩色禽异兽和神仙形状。图、写，都是画的意思。 丙舍：后汉宫中正室两旁的房屋，基第三等称丙舍。 甲帐：汉武帝所造，用琉璃、夜光珠等为装饰，来供奉神灵的帐幕。 对楹：指堂前一左一右相对的柱子。 肆筵设席，鼓瑟吹笙。升阶纳陛，弁转疑星。 肆筵设席：陈设筵席。肆，陈设。 鼓瑟吹笙：指弹奏美妙的音乐以接待宾客。 升阶纳陛：指登上宫廷的台阶。升、纳，都是登的意思。阶、陛，都是台阶的意思。 弁（bian 4）转疑星：缀有珠玉的礼帽转动，好像满天的星斗闪烁一样。弁，古代男子戴的一种冠。有皮弁，爵弁之分。弁，本意是指古代一种尊贵的冠，也指掌管帝王的冕服及等制，又比喻首领、魁首。该文字在《仪礼·士冠礼》和《广韵》等文献均有记载。 右通广内，左达承明。既集坟典，亦聚群英。杜稿钟隶，漆书壁经。 广内：西汉宫廷藏书的地方，在建章宫中。后来泛指君王的藏书处。 达，到达。 承明：汉代宫殿名，位于未央宫中。承明殿旁边设有承明庐，为侍臣值宿所居之处。 既集坟典，亦聚群英：指广内、承明等殿，既收藏了书籍，又聚集了众多才俊。 坟典：即《三坟》《五典》，相传为中国最古老的书籍，分别记载了“三皇”、“五帝”的事迹。 杜稿：杜度的草书手稿。杜度，东汉人，能作文，善草书。 锤隶：指三国时锤繇（yao 1）的隶书。锤繇，字元常，工书法，尤精隶楷。 漆书：在竹木简上用漆书写的图书。 壁经：指鲁恭王刘余从孔子旧宅墙壁中得到的用古文写成的经书。 府罗将相，路侠槐卿。户封八县，家给千兵。 府：公卿相聚之所。罗，罗列。将相，文武大臣。 路，道路。侠，即夹，夹道。 槐卿：指三公九卿，泛指高级官员。周朝时，朝廷中三槐九棘，公卿大夫分坐其下，三公坐三槐之下，九卿坐九棘之下，此后用槐、棘分别代指三公、九卿。 家：公卿之家。给：供养。 高冠陪辇，驱毂振缨。世禄侈富，车驾肥轻。策功茂实，勒碑刻铭。 高冠陪辇：卫士陪侍护卫皇帝。高冠，指卫士。辇，古代天子所乘坐的车。 驱毂：乘车上朝，即驾车。毂，车轮中心的圆木，缨，帽子系带。 禄：指因官爵而得到的财富（爵禄）。侈富：豪富。 车驾肥轻：车驾华丽轻快。肥轻：“肥马轻裘”的略称。 策功：记功。茂：劝勉，鼓励。实：这里指功业。勒：刻。铭：碑。 磻溪伊尹，佐时阿衡。奄宅曲阜，微旦孰营。 磻溪：指姜太公吕尚。曾垂钓于磻溪。 伊尹：原为商汤妻有辛氏的陪嫁奴隶。后辅佐商汤灭夏桀。 佐时：辅佐当世之君治理国家。 阿衡：官名，相传伊尹曾任此职，辅佐商汤，主持朝政。 奄宅曲阜，微旦孰营：指平定曲阜后，没有周公旦谁来治理呢。奄宅，攻取平定。微，没有，表假设。营，经营，治理。周武王封周公旦于曲阜。 桓公匡合，济弱扶倾。绮回汉惠，说感武丁。俊乂密勿，多士寔宁。 桓公匡合：指齐桓公集合众力，匡正天下。. 绮：绮里季，“商山四皓”（绮里季、东园公、夏黄公、甪里先生）之一，这里用绮里季代指商山四皓。 汉惠：汉惠帝刘盈。 说：傅说。殷高祖武丁的宰相。 感：梦感，指商王武丁梦见圣人，后果然找到傅说以辅佐国政，国大治。 俊：乂才德出众的人。密勿：黾勉，努力。 多士寔宁：国家有众多人才就会安宁。寔，同“实”。 晋楚更霸，赵魏困横。假途灭虢，践土会盟。何遵约法，韩弊烦刑。 晋楚更霸：齐桓公、晋文公、秦穆公、楚庄王、宋襄公相继称霸，史称春秋五霸。 赵魏困横：赵魏困于连横。六国合纵抗秦，秦以连横抵抗。 假途灭虢：春秋时，晋献公借道灭虢国，回师时又灭虞国的故事。 践土会盟：晋文公城濮之战大胜楚国后，会集诸侯盟于践土，成就其霸主地位。践土，春秋时郑地，在今河南原阳县。 何遵约法：指萧何在刘邦约法三章的基础上重新制定刑律九章。 韩：即韩非子。 起翦颇牧，用军最精。宣威沙漠，驰誉丹青。 起翦颇牧：白起、王翦、廉颇、李牧。 宣威沙漠，驰誉丹青：这两句指两汉而言。 九州禹迹，百郡秦并。岳宗泰岱，禅主云亭。 禹：大禹。 百郡秦并：秦始皇吞并六国，统一天下，推行郡县制。 禅：封禅。 云亭：指云云山和亭亭山，它们是位于泰山南侧的支脉，是古代皇帝祭地的地方。 雁门紫塞，鸡田赤城。昆池碣石，钜野洞庭。旷远绵邈，岩岫杳冥。 雁门：雁门关。 紫塞：指长城。长城之土皆紫，故以紫塞代指长城。 鸡田：古代驿站名，位于今宁夏灵武境内。 赤城：相传是蚩尤居住的地方。 昆池：即滇池，又名昆明湖，位于云南昆明西南。 碣石：碣石山，位于今河北昌黎北。 巨野：古代大湖泽名，又称大野泽，位于今山东巨野北，已经干涸。 洞庭：洞庭湖。 岩岫杳冥：指洞穴深暗。岩岫，深广的洞穴。 治本于农，务兹稼穑。俶载南亩，我艺黍稷。税熟贡新，劝赏黜陟。 稼穑（se 4）：泛指农业劳动。务：从事于。兹：此，这个。 俶（chu 4）：开始。载：从事，劳作。南亩：农田。 黍稷：泛指五谷等农作物。 孟轲敦素，史鱼秉直。庶几中庸，劳谦谨敕。 敦素：敦厚素雅。 史鱼：春秋时卫国大夫，以直谏著称。 劳谦：辛劳谦虚。谨敕：谨慎。 聆音察理，鉴貌辨色。贻厥嘉猷，勉其祗植。 聆：聆听。音：这里指言语。察：审，体察。理：指所有表达的意思。 鉴：观察。貌：容貌。辨：辨别。色：神情。 贻：赠给。厥：其。嘉猷（you 2）：善谋，妙法。 祇（zhi 1）：敬。植：树立。 省躬讥诫，宠增抗极。 躬：反躬自省。讥、诫：劝诫。 抗极：亢极，炽盛。 殆辱近耻，林皋幸即。两疏见机，解组谁逼。索居闲处，沉默寂寥。 林皋 ：山林和水边地，引申为退隐之地。幸：侥幸。即：靠近。 两疏：指西汉疏广、疏受两叔侄。见机：根据形势决定。 解组谁逼：意谓疏辞官归隐是自己的选择，没有人逼迫。组：系官印的绶带，代指官印或官位。 索居：孤独散居。 求古寻论，散虑逍遥。欣奏累遣，戚谢欢招。 散虑：排解、遣散思虑杂念。 欣奏累遣：奏欣遣累。奏：进。欣：欢悦。遣：排除。累：拘系，劳累。 渠荷的历，园莽抽条。枇杷晚翠，梧桐早凋。陈根委翳，落叶飘摇。游鹍独运，凌摩绛霄。 渠荷：水沟中的荷花。 的历：光亮鲜明、光彩烂灼的样子。 莽：茂盛的草。抽条：长出新的叶子。 晚翠：是说枇杷耐寒，冬季树叶也是翠绿的。 陈根：逾年的宿草。委翳：萎谢。 落叶飘摇：枯落的树叶飘荡飞舞。 鹍（kun 1）：中国古代指像鹤的一种大鸟。运：飞翔。 凌摩：升入空中。摩，摩空之意，指逼近空中。绛宵：又名紫霄，古代神话中的九霄之一。 耽读玩市，寓目囊箱。易輶攸畏，属耳垣墙。 耽：沉溺。玩市：市场。寓目：观看。囊箱：装书的箱子。 易：轻忽。輶（you 2）：古代一种轻便的车子，此处引申为轻。攸（you 1）：所。畏：畏惧，有戒心。 属（zhu 3）：附着。垣：矮墙。此句出自《诗经·小雅·小弁》：“君子无易由言，耳属于垣。”意思是说，君子要小心言论，即使有墙相隔，也会有人将耳朵贴在墙上偷听。 具膳餐饭，适口充肠。饱饫烹宰，饥厌糟糠。亲戚故旧，老少异粮。 具：准备。膳：饭食，一般指肉食。 饱饫（yu 4）烹宰：不挨饿的人鸡鸭鱼肉才能使其满足。饫：满足。 饥厌糟糠：饥饿的人糟糠食物就可以令他满足。厌：满足。糟：酒渣。糠：指谷子的外壳。 亲戚故旧，老少异粮：要区分亲戚故旧中老者和少年的食物。 妾御绩纺，侍巾帷房。纨扇圆絜，银烛炜煌。昼眠夕寐，蓝笋象床。 御：从事。绩纺：纺织。侍：陪从在位尊者身边。帷房：张挂布幔的内室、闺房。 纨扇：用白色细绢制作的扇子。 絜（jie 2）：同洁，光洁，指扇子的质地。 银烛：精美的白色蜡烛。 炜煌：指烛光明亮辉煌。 弦歌酒宴，接杯举觞。矫手顿足，悦豫且康。 弦：指丝竹一类的弦乐器。接：接受。 矫手顿足：犹言手舞足蹈，形容高兴欢乐。 嫡后嗣续，祭祀烝尝。稽颡再拜，悚惧恐惶。 嫡：古代正妻所生拥的继承权的长子。后：后代。嗣、续 ：都是继承的意思。 祭祀烝尝：指祭祀供奉神灵和祖先的仪式有烝祭和尝祭。秋天的祭祀仪式称尝，冬天的祭祀仪式称烝。 稽（qi 3）颡（sang 3）再拜，悚惧恐惶：指行跪拜大礼的时候，心情要惶恐敬慎，极度虔诚。 笺牒简要，顾答审详。骸垢想浴，执热愿凉。 笺：细窄的条形竹片，可用来记写简短文字。 牒：古代书写用的本片或竹片，也指公文。 顾答审详：回答别人的提问越详细越好。顾答：回答。审详：详细。 骸：身体。 垢：污垢。 执热：酷热。 驴骡犊特，骇跃超骧。诛斩贼盗，捕获叛亡。 骡：俗称“马骡”，由公驴和母马交配所产。犊：小牛。特：成年公牛。 布射僚丸，嵇琴阮啸。恬笔伦纸，钧巧任钓。释纷利俗，并皆佳妙。毛施淑姿，工颦妍笑。年矢每催，曦晖朗曜。璇玑悬斡，晦魄环照。指薪修祜，永绥吉劭。矩步引领，俯仰廊庙。束带矜庄，徘徊瞻眺。孤陋寡闻，愚蒙等诮。谓语助者，焉哉乎也。 原文天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。寒来暑往，秋收冬藏。闰余成岁，律吕调阳。云腾致雨，露结为霜。金生丽水，玉出昆冈。剑号巨阙，珠称夜光。果珍李柰，菜重芥姜。海咸河淡，鳞潜羽翔。龙师火帝，鸟官人皇。始制文字，乃服衣裳。推位让国，有虞陶唐。吊民伐罪，周发殷汤。坐朝问道，垂拱平章。爱育黎首，臣伏戎羌。遐迩一体，率宾归王。鸣凤在竹，白驹食场。化被草木，赖及万方。盖此身发，四大五常。恭惟鞠养，岂敢毁伤。女慕贞洁，男效才良。知过必改，得能莫忘。罔谈彼短，靡恃己长。信使可覆，器欲难量。墨悲丝染，诗赞羔羊。景行维贤，克念作圣。德建名立，形端表正。空谷传声，虚堂习听。祸因恶积，福缘善庆。尺璧非宝，寸阴是竞。资父事君，曰严与敬。孝当竭力，忠则尽命。临深履薄，夙兴温凊。似兰斯馨，如松之盛。川流不息，渊澄取映。容止若思，言辞安定。笃初诚美，慎终宜令。荣业所基，籍甚无竟。学优登仕，摄职从政。存以甘棠，去而益咏。乐殊贵贱，礼别尊卑。上和下睦，夫唱妇随。外受傅训，入奉母仪。诸姑伯叔，犹子比儿。孔怀兄弟，同气连枝。交友投分，切磨箴规。仁慈隐恻，造次弗离。节义廉退，颠沛匪亏。性静情逸，心动神疲。守真志满，逐物意移。坚持雅操，好爵自縻。都邑华夏，东西二京。背邙面洛，浮渭据泾。宫殿盘郁，楼观飞惊。图写禽兽，画彩仙灵。丙舍旁启，甲帐对楹。肆筵设席，鼓瑟吹笙。升阶纳陛，弁转疑星。右通广内，左达承明。既集坟典，亦聚群英。杜稿钟隶，漆书壁经。府罗将相，路侠槐卿。户封八县，家给千兵。高冠陪辇，驱毂振缨。世禄侈富，车驾肥轻。策功茂实，勒碑刻铭。磻溪伊尹，佐时阿衡。奄宅曲阜，微旦孰营。桓公匡合，济弱扶倾。绮回汉惠，说感武丁。俊乂密勿，多士寔宁。晋楚更霸，赵魏困横。假途灭虢，践土会盟。何遵约法，韩弊烦刑。起翦颇牧，用军最精。宣威沙漠，驰誉丹青。九州禹迹，百郡秦并。岳宗泰岱，禅主云亭。雁门紫塞，鸡田赤城。昆池碣石，钜野洞庭。旷远绵邈，岩岫杳冥。治本于农，务兹稼穑。俶载南亩，我艺黍稷。税熟贡新，劝赏黜陟。孟轲敦素，史鱼秉直。庶几中庸，劳谦谨敕。聆音察理，鉴貌辨色。贻厥嘉猷，勉其祗植。省躬讥诫，宠增抗极。殆辱近耻，林皋幸即。两疏见机，解组谁逼。索居闲处，沉默寂寥。求古寻论，散虑逍遥。欣奏累遣，戚谢欢招。渠荷的历，园莽抽条。枇杷晚翠，梧桐早凋。陈根委翳，落叶飘摇。游鹍独运，凌摩绛霄。耽读玩市，寓目囊箱。易輶攸畏，属耳垣墙。具膳餐饭，适口充肠。饱饫烹宰，饥厌糟糠。亲戚故旧，老少异粮。妾御绩纺，侍巾帷房。纨扇圆絜，银烛炜煌。昼眠夕寐，蓝笋象床。弦歌酒宴，接杯举觞。矫手顿足，悦豫且康。嫡后嗣续，祭祀烝尝。稽颡再拜，悚惧恐惶。笺牒简要，顾答审详。骸垢想浴，执热愿凉。驴骡犊特，骇跃超骧。诛斩贼盗，捕获叛亡。布射僚丸，嵇琴阮啸。恬笔伦纸，钧巧任钓。释纷利俗，并皆佳妙。毛施淑姿，工颦妍笑。年矢每催，曦晖朗曜。璇玑悬斡，晦魄环照。指薪修祜，永绥吉劭。矩步引领，俯仰廊庙。束带矜庄，徘徊瞻眺。孤陋寡闻，愚蒙等诮。谓语助者，焉哉乎也。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"DOING","slug":"doing","permalink":"https://liangyuanzheng.com/tags/doing/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"古文","slug":"古文","permalink":"https://liangyuanzheng.com/tags/%E5%8F%A4%E6%96%87/"},{"name":"经典","slug":"经典","permalink":"https://liangyuanzheng.com/tags/%E7%BB%8F%E5%85%B8/"},{"name":"启蒙","slug":"启蒙","permalink":"https://liangyuanzheng.com/tags/%E5%90%AF%E8%92%99/"}]},{"title":"每日一库：Govalidator-——-Go-语言的强大验证与清理工具​","slug":"每日一库：Govalidator-——-Go-语言的强大验证与清理工具​","date":"2025-04-18T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Govalidator-——-Go-语言的强大验证与清理工具​.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AGovalidator-%E2%80%94%E2%80%94-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BC%BA%E5%A4%A7%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%B8%85%E7%90%86%E5%B7%A5%E5%85%B7%E2%80%8B.html","excerpt":"","text":"概述Govalidator 是一个 Go 语言库，专注于数据验证与清理，支持字符串、数字、切片、结构体及嵌套数据。灵感来源于 JavaScript 的 validator.js，它提供了丰富的内置验证函数，同时支持灵活的自定义扩展。 GitHub - asaskevich&#x2F;govalidator: [Go] Package of validators and sanitizers for strings, numerics, slices and structs 核心功能 安装与导入 1go get github.com/asaskevich/govalidator 导入到代码： 1import \"github.com/asaskevich/govalidator\" 强制字段验证• 启用 SetFieldsRequiredByDefault(true) 后，所有结构体字段需显式标记 valid 标签，否则验证失败。• 例外：使用 valid:&quot;-&quot; 或 valid:&quot;email,optional&quot; 跳过验证或设为可选。 内置验证器• 字符串：IsURL、IsEmail、IsIPv4、IsCreditCard 等。• 数值：IsInt、IsFloat、InRange。• 格式：IsJSON、IsBase64、IsUUID。• 国际化：IsUTFLetter、IsFullWidth。• 完整列表：超过 70 种验证函数，覆盖常见需求。 结构体验证 12345type User struct &#123; Name string `valid:\"required,alpha\"` Email string `valid:\"email\"`&#125;isValid, err := govalidator.ValidateStruct(User&#123;Name: \"Bob\", Email: \"bob@example.com\"&#125;) Map 验证 123456template := map[string]interface&#123;&#125;&#123; \"name\": \"required,alpha\", \"age\": \"numeric,range(18|99)\",&#125;input := map[string]interface&#123;&#125;&#123;\"name\": \"Alice\", \"age\": 25&#125;isValid, err := govalidator.ValidateMap(input, template) 自定义验证器• 无参数验证器： 123govalidator.TagMap[\"isDuck\"] = govalidator.Validator(func(str string) bool &#123; return str == \"duck\"&#125;) • 带参数验证器： 123govalidator.ParamTagMap[\"animal\"] = govalidator.ParamValidator(func(str string, params ...string) bool &#123; return str == params[0]&#125;) 错误处理• 自定义错误消息： 123type Ticket struct &#123; Name string `valid:\"required~Name cannot be empty\"`&#125; • 遍历多错误： 12345if errs, ok := err.(govalidator.Errors); ok &#123; for _, e := range errs.Errors() &#123; fmt.Println(e.Error()) &#125;&#125; 辅助工具• 字符串处理：Trim、PadLeft、Reverse、WhiteList（过滤字符）。• 切片操作：Each、Map、Filter、Count。• 类型转换：ToBoolean、ToFloat、ToString。 使用场景• API 请求验证：确保输入数据符合预期格式。• 数据清洗：过滤非法字符或格式化字符串。• 复杂结构校验：嵌套结构体或动态 Map 数据的规则验证。• 国际化支持：处理多语言字符集的验证需求。 注意事项• 破坏性变更：v 10 版本后，自定义验证函数需接收上下文参数 func(i interface{}, o interface{}) bool，以支持依赖验证。• 性能：大量数据验证时注意性能，可结合基准测试优化。• 错误消息：优先使用自定义错误提升可读性。 示例代码1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"github.com/asaskevich/govalidator\")func init() &#123; govalidator.SetFieldsRequiredByDefault(true)&#125;type Product struct &#123; ID string `valid:\"required,uuidv4\"` Name string `valid:\"required,alpha\"` Price float64 `valid:\"required,range(10|1000)\"`&#125;func main() &#123; p := Product&#123;ID: \"bad-id\", Name: \"Laptop123\", Price: 5.0&#125; isValid, err := govalidator.ValidateStruct(p) if err != nil &#123; for _, e := range err.(govalidator.Errors).Errors() &#123; fmt.Println(\"Error:\", e) &#125; &#125; fmt.Println(\"Is valid?\", isValid)&#125;// 输出：// Error: ID must be a valid UUIDv4// Error: Name must contain alphabetic characters only// Error: Price must be between 10 and 1000// Is valid? false 总结Govalidator 是 Go 生态中功能全面的验证库，适合需要严格数据校验的场景。通过组合内置规则与自定义逻辑，可轻松应对复杂业务需求。使用时注意版本升级的变更，合理设计验证规则以平衡灵活性与性能。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"工具箱","slug":"工具箱","permalink":"https://liangyuanzheng.com/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1/"},{"name":"校验","slug":"校验","permalink":"https://liangyuanzheng.com/tags/%E6%A0%A1%E9%AA%8C/"}]},{"title":"每日一库：Expr-Go-语言的高性能动态表达式引擎","slug":"每日一库：Expr-Go-语言的高性能动态表达式引擎","date":"2025-04-17T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Expr-Go-语言的高性能动态表达式引擎.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AExpr-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E5%8A%A8%E6%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E.html","excerpt":"","text":"概述Expr 是一个专为 Go 语言设计的表达式求值库，旨在通过简洁的语法实现动态配置、业务规则和条件判断。它强调安全性（内存安全、无副作用、无死循环）、高性能（基于字节码虚拟机优化）和无缝 Go 集成（直接复用 Go 类型，静态类型检查）。 GitHub - expr-lang&#x2F;expr: Expression language and expression evaluation for Go 核心特性 安全性优先• 内存安全：禁止访问无关内存，避免潜在漏洞。• 无副作用：表达式仅依赖输入计算输出，不修改外部状态。• 强制终止：防止无限循环，确保表达式执行可控。 深度集成 Go 生态• 无需类型重定义：直接使用已有的 Go 结构体、函数作为表达式环境变量。• 静态类型检查：编译阶段捕获类型错误（如 string + int 直接报错）。 高性能设计• 优化编译器 + 字节码虚拟机，适用于高频调用场景（如实时规则引擎）。 开发友好• 丰富的内置函数（all、filter、map 等）和操作符。• 清晰的错误提示，快速定位语法或逻辑问题。 快速上手安装： 1go get github.com/expr-lang/expr 示例 1：动态字符串生成 12345678910env := map[string]interface&#123;&#125;&#123; \"greet\": \"Hello, %v!\", \"names\": []string&#123;\"world\", \"you\"&#125;, \"sprintf\": fmt.Sprintf,&#125;code := `sprintf(greet, names[0])` // 输出 \"Hello, world!\"program, _ := expr.Compile(code, expr.Env(env))output, _ := expr.Run(program, env)fmt.Println(output) 示例 2：业务规则验证 1234567type Tweet struct&#123; Len int &#125;type Env struct&#123; Tweets []Tweet &#125;code := `all(Tweets, &#123;.Len &lt;= 240&#125;)` // 检查所有推文长度 ≤240program, _ := expr.Compile(code, expr.Env(Env&#123;&#125;))env := Env&#123;Tweets: []Tweet&#123;&#123;42&#125;, &#123;98&#125;, &#123;69&#125;&#125;&#125;output, _ := expr.Run(program, env) // 输出 true 适用场景 动态业务规则（如 Uber Eats 的商家配置、Wish 的促销规则） 实时条件判断（如游戏匹配算法、风控系统） 配置验证（如 K8s 资源策略、网络流分类） 交互式工具（如 REPL 环境、DSL 实现） 谁在使用？• Uber、GoDaddy：动态配置电商&#x2F;服务策略• ByteDance、Aviasales：业务规则引擎• Argo Rollouts、CoreDNS：基础设施逻辑控制• Chaos Mesh、CrowdSec：安全与混沌工程 总结Expr 凭借其安全性、性能和Go 原生友好性，成为动态规则场景的优选方案。若你的项目需要灵活表达式求值（如用户自定义条件、实时策略调整），Expr 能以极低成本接入，避免重复造轮子的同时保障代码健壮性。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"}]},{"title":"每日一库：Uber-开源的-Go-依赖注入库-dig​","slug":"每日一库：Uber-开源的-Go-依赖注入库-dig​","date":"2025-04-16T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Uber-开源的-Go-依赖注入库-dig​.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9AUber-%E5%BC%80%E6%BA%90%E7%9A%84-Go-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%BA%93-dig%E2%80%8B.html","excerpt":"","text":"1. 简介dig（Dependency Injection for Go）是 Uber 开源的一款基于反射的依赖注入工具，专为 Go 语言设计。它通过自动管理对象间的依赖关系，简化代码结构，适用于构建应用框架（如 Uber 的 Fx）或初始化复杂依赖图。 GitHub - uber-go&#x2F;dig: A reflection based dependency injection toolkit for Go. 2. 核心特点• 反射驱动：无需代码生成，通过反射分析函数参数和返回值，自动解析依赖。• 容器化管理：通过 dig.Container 管理所有依赖的构造函数和实例。• 启动时依赖解析：适合在应用启动阶段构建依赖图，避免运行时开销。• 稳定性：遵循 SemVer 规范，v 1 版本无破坏性变更。• 轻量级：核心代码简洁，适合作为底层工具集成到框架中。 3. 使用场景• ✅ 适用场景： • 构建应用框架（如 Fx）。 • 初始化阶段集中管理复杂依赖（如配置、数据库连接、服务层）。• ❌ 不适用场景： • 替代完整的应用框架（需结合 Fx 等）。 • 运行时动态依赖注入。 4. 快速入门示例代码12345678910111213141516171819202122232425262728293031323334package daemonimport (true\"fmt\"true\"go.uber.org/dig\")type Config struct &#123;trueAddr string&#125;func NewConfig() *Config &#123;truereturn &amp;Config&#123;Addr: \":8080\"&#125;&#125;type Server struct &#123;truecfg *Config&#125;func NewServer(cfg *Config) *Server &#123;truereturn &amp;Server&#123;cfg: cfg&#125;&#125;func ABC() &#123;truec := dig.New()truec.Provide(NewConfig)truec.Provide(NewServer)truec.Invoke(func(s *Server) &#123;truetruefmt.Println(\"Server started at\", s.cfg.Addr)true&#125;)&#125; 输出1Server started at :8080 5. 高级功能5.1 组注入（Grouping）将多个相同类型的实例注入为切片，适用于插件化场景： 123456789c.Provide(func() *Logger &#123; return NewFileLogger() &#125;, dig.Group(\"loggers\"))c.Provide(func() *Logger &#123; return NewConsoleLogger() &#125;, dig.Group(\"loggers\"))// 使用时注入 []*Loggerc.Invoke(func(loggers []*Logger) &#123; for _, l := range loggers &#123; l.Log(\"Hello\") &#125;&#125;) 5.2 装饰器（Decorators）动态增强已有依赖： 123c.Decorate(func(l *Logger) *Logger &#123; return l.WithLevel(\"debug\")&#125;) 5.3 接口绑定通过返回接口类型实现接口-具体类型绑定： 123456type Writer interface &#123; Write([]byte) &#125;type FileWriter struct&#123;&#125;func NewWriter() Writer &#123; return &amp;FileWriter&#123;&#125; &#125;c.Provide(NewWriter) // 依赖注入时识别为 Writer 接口 6. 性能与注意事项• 性能：反射在启动时一次性解析依赖，对运行时性能无影响，但大型项目可能增加启动时间。• 错误处理：支持构造函数返回 error，容器会捕获并终止初始化。• 循环依赖检测：启动时自动检测循环依赖（如 A → B → A）并报错。 7. 对比其他工具 工具 特点 适用场景 dig 反射驱动，灵活，启动时解析 中小项目、框架集成 wire 代码生成，编译时检查，高性能 大型项目、追求性能 Fx 基于 dig 的应用框架，生命周期管理 全功能应用开发 8. 总结dig 是 Go 生态中轻量且强大的依赖注入工具，适合需要灵活依赖管理的场景。结合 Fx 可构建完整的应用框架，但需注意反射带来的启动开销。对于性能敏感项目，可考虑代码生成方案（如 wire）。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"设计与实现","slug":"设计与实现","permalink":"https://liangyuanzheng.com/tags/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"}]},{"title":"每日一库：Lancet-——-Go-语言高效工具库","slug":"每日一库：Lancet-——-Go-语言高效工具库","date":"2025-04-16T01:53:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"每日一库：Lancet-——-Go-语言高效工具库.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93%EF%BC%9ALancet-%E2%80%94%E2%80%94-Go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7%E5%BA%93.html","excerpt":"","text":"项目简介Lancet 是一个全面、高效且可复用的 Go 语言工具库，灵感来源于 Java 的 Apache Commons 和 JavaScript 的 Lodash。它提供了 600+ 实用函数，覆盖字符串、切片、日期时间、加密、并发、数据结构等高频场景，旨在简化开发流程，减少重复代码。 • GitHub 地址: duke-git&#x2F;lancet• 核心特点: • 全面性：支持字符串处理、加密、数据结构、网络工具等。 • 高效轻量：仅依赖 Go 标准库和 golang.org/x，无冗余依赖。 • 强测试：每个导出函数均有单元测试，保障代码质量。 • 泛型支持：v 2.x.x 基于 Go 1.18+ 泛型重构，提供更灵活的类型处理。 安装指南根据 Go 版本选择合适版本： 12345// Go 1.18+ 安装 v2.x.xgo get github.com/duke-git/lancet/v2// Go 1.18 以下安装 v1.x.x（最新 v1.4.3）go get github.com/duke-git/lancet 核心功能概览 常用数据类型处理• 字符串处理 (strutil)：反转、驼峰&#x2F;蛇形命名、子串截取等。 12s := \"hello\"reversed := strutil.Reverse(s) // \"olleh\" • 切片操作 (slice)：去重、过滤、分块、排序等。• Map 工具 (maputil)：合并、过滤、转换、交集差集计算。 算法与数据结构• 排序算法 (algorithm)：冒泡、堆排、快排等。• LRU 缓存：基于 LRU 算法实现内存缓存。• 并发结构 (concurrency)：协程管理、通道合并、超时控制。 加密与安全 (cryptor)支持 AES、DES、RSA 等加密算法，以及 HMAC、MD 5、SHA 系列哈希。 1encrypted := cryptor.AesEcbEncrypt(data, key) // AES-ECB 加密 日期时间处理 (datetime)提供时间计算、格式化、范围判断等功能： 1now := datetime.GetNowDateTime() // \"2023-10-01 12:34:56\" 数据验证 (validator)校验邮箱、URL、IP、身份证号、密码强度等： 1isValid := validator.IsEmail(\"user@example.com\") // true 高级特性• 函数式编程 (function)：防抖、重试、管道组合。• 流处理 (stream)：类似 Java Stream 的链式操作。• 元组与可选值 (tuple, optional)：简化多返回值处理。 示例场景场景 1：高效处理切片 1234import \"github.com/duke-git/lancet/v2/slice\"nums := []int&#123;1, 2, 3, 4&#125;filtered := slice.Filter(nums, func(n int) bool &#123; return n%2 == 0 &#125;) // [2,4] 场景 2：并发控制 12345import \"github.com/duke-git/lancet/v2/concurrency\"ch := concurrency.NewChannel()ch.TrySend(\"data\") // 非阻塞发送result, ok := ch.TryReceive() // 非阻塞接收 场景 3：数据验证 123import \"github.com/duke-git/lancet/v2/validator\"isStrong := validator.IsStrongPassword(\"Passw0rd!\", 8) // 校验强度 为何选择 Lancet？• 减少重复代码：覆盖大部分工具需求，避免重复造轮子。• 性能优化：函数经过优化，适合高性能场景。• 社区活跃：持续更新，贡献者友好（见 CONTRIBUTION.md）。 总结Lancet 是 Go 开发者提升效率的利器，尤其适合需要快速实现复杂逻辑的中大型项目。其模块化设计允许按需引入，避免项目膨胀。通过丰富的文档和测试用例，开发者可快速上手，建议结合官方示例探索更多功能！","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"Golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"每日一库","slug":"每日一库","permalink":"https://liangyuanzheng.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%BA%93/"},{"name":"工具箱","slug":"工具箱","permalink":"https://liangyuanzheng.com/tags/%E5%B7%A5%E5%85%B7%E7%AE%B1/"}]},{"title":"搞懂异地多活，看这篇就够了","slug":"搞懂异地多活，看这篇就够了","date":"2024-12-09T11:34:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"搞懂异地多活，看这篇就够了.html","link":"","permalink":"https://liangyuanzheng.com/%E6%90%9E%E6%87%82%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB%EF%BC%8C%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html","excerpt":"","text":"本文系外部转贴，查看原文 在软件开发领域，「异地多活」是分布式系统架构设计的一座高峰，很多人经常听过它，但很少人理解其中的原理。 异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？ 这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。 有幸，我曾经深度参与过一个中等互联网公司，建设异地多活系统的设计与实施过程。所以今天，我就来和你聊一聊异地多活背后的的实现原理。 认真读完这篇文章，我相信你会对异地多活架构，有更加深刻的理解。 这篇文章干货很多，希望你可以耐心读完。 01 系统可用性要想理解异地多活，我们需要从架构设计的原则说起。 现如今，我们开发一个软件系统，对其要求越来越高，如果你了解一些「架构设计」的要求，就知道一个好的软件架构应该遵循以下 3 个原则： 高性能 高可用 易扩展 其中，高性能意味着系统拥有更大流量的处理能力，更低的响应延迟。例如 1 秒可处理 10W 并发请求，接口响应时间 5 ms 等等。 易扩展表示系统在迭代新功能时，能以最小的代价去扩展，系统遇到流量压力时，可以在不改动代码的前提下，去扩容系统。 而「高可用」这个概念，看起来很抽象，怎么理解它呢？通常用 2 个指标来衡量： 平均故障间隔 MTBF（Mean Time Between Failure）：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高 故障恢复时间 MTTR（Mean Time To Repair）：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小 可用性与这两者的关系： 可用性（Availability）&#x3D; MTBF &#x2F; (MTBF + MTTR) * 100% 这个公式得出的结果是一个「比例」，通常我们会用「N 个 9」来描述一个系统的可用性。 从这张图你可以看到，要想达到 4 个 9 以上的可用性，平均每天故障时间必须控制在 10 秒以内。 也就是说，只有故障的时间「越短」，整个系统的可用性才会越高，每提升 1 个 9，都会对系统提出更高的要求。 我们都知道，系统发生故障其实是不可避免的，尤其是规模越大的系统，发生问题的概率也越大。这些故障一般体现在 3 个方面： 硬件故障：CPU、内存、磁盘、网卡、交换机、路由器 软件问题：代码 Bug、版本迭代 不可抗力：地震、水灾、火灾、战争 这些风险随时都有可能发生。所以，在面对故障时，我们的系统能否以「最快」的速度恢复，就成为了可用性的关键。 可如何做到快速恢复呢？ 这篇文章要讲的「异地多活」架构，就是为了解决这个问题，而提出的高效解决方案。 下面，我会从一个最简单的系统出发，带你一步步演化出一个支持「异地多活」的系统架构。 在这个过程中，你会看到一个系统会遇到哪些可用性问题，以及为什么架构要这样演进，从而理解异地多活架构的意义。 02 单机架构我们从最简单的开始讲起。 假设你的业务处于起步阶段，体量非常小，那你的架构是这样的： 这个架构模型非常简单，客户端请求进来，业务应用读写数据库，返回结果，非常好理解。 但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。 如何避免这个问题呢？我们很容易想到一个方案：备份。 你可以对数据做备份，把数据库文件「定期」cp 到另一台机器上，这样，即使原机器丢失数据，你依旧可以通过备份把数据「恢复」回来，以此保证数据安全。 这个方案实施起来虽然比较简单，但存在 2 个问题： 恢复需要时间：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」 数据不完整：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期 很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。 那有什么更好的方案，既可以快速恢复业务？还能尽可能保证数据完整性呢？ 这时你可以采用这个方案：主从副本。 03 主从副本你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」，就像这样： 我们一般把原实例叫作主库（master），新实例叫作从库（slave）。这个方案的优点在于： 数据完整性高：主从副本实时同步，数据「差异」很小 抗故障能力提升：主库有任何异常，从库可随时「切换」为主库，继续提供服务 读性能提升：业务应用可直接读从库，分担主库「压力」读压力 这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能。 同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。 因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。 从这个方案你可以看出，提升可用性的关键思路就是：冗余。 没错，担心一个实例故障，那就部署多个实例，担心一个机器宕机，那就部署多台机器。 到这里，你的架构基本已演变成主流方案了，之后开发新的业务应用，都可以按照这种模式去部署。 但这种方案还有什么风险吗？ 04 风险不可控现在让我们把视角下放，把焦点放到具体的「部署细节」上来。 按照前面的分析，为了避免单点故障，你的应用虽然部署了多台机器，但这些机器的分布情况，我们并没有去深究。 而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。 如果恰好连接这个机柜的交换机 &#x2F; 路由器发生故障，那么你的应用依旧有「不可用」的风险。 虽然交换机 &#x2F; 路由器也做了路线冗余，但不能保证一定不出问题。 部署在一个机柜有风险，那把这些机器打散，分散到不同机柜上，是不是就没问题了？ 这样确实会大大降低出问题的概率。但我们依旧不能掉以轻心，因为无论怎么分散，它们总归还是在一个相同的环境下：机房。 那继续追问，机房会不会发生故障呢？ 一般来讲，建设一个机房的要求其实是很高的，地理位置、温湿度控制、备用电源等等，机房厂商会在各方面做好防护。但即使这样，我们每隔一段时间还会看到这样的新闻： 2015 年 5 月 27 日，杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝 2021 年 7 月 13 日，B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问 2021 年 10 月 9 日，富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易 … 可见，即使机房级别的防护已经做得足够好，但只要有「概率」出问题，那现实情况就有可能发生。虽然概率很小，但一旦真的发生，影响之大可见一斑。 看到这里你可能会想，机房出现问题的概率也太小了吧，工作了这么多年，也没让我碰上一次，有必要考虑得这么复杂吗？ 但你有没有思考这样一个问题：不同体量的系统，它们各自关注的重点是什么？ 体量很小的系统，它会重点关注「用户」规模、增长，这个阶段获取用户是一切。等用户体量上来了，这个阶段会重点关注「性能」，优化接口响应时间、页面打开速度等等，这个阶段更多是关注用户体验。 等体量再大到一定规模后你会发现，「可用性」就变得尤为重要。像微信、支付宝这种全民级的应用，如果机房发生一次故障，那整个影响范围可以说是非常巨大的。 所以，再小概率的风险，我们在提高系统可用性时，也不能忽视。 分析了风险，再说回我们的架构。那到底该怎么应对机房级别的故障呢？ 没错，还是冗余。 05 同城灾备想要抵御「机房」级别的风险，那应对方案就不能局限在一个机房内了。 现在，你需要做机房级别的冗余方案，也就是说，你需要再搭建一个机房，来部署你的服务。 简单起见，你可以在「同一个城市」再搭建一个机房，原机房我们叫作 A 机房，新机房叫 B 机房，这两个机房的网络用一条「专线」连通。 有了新机房，怎么把它用起来呢？这里还是要优先考虑「数据」风险。 为了避免 A 机房故障导致数据丢失，所以我们需要把数据在 B 机房也存一份。最简单的方案还是和前面提到的一样：备份。 A 机房的数据，定时在 B 机房做备份（拷贝数据文件），这样即使整个 A 机房遭到严重的损坏，B 机房的数据不会丢，通过备份可以把数据「恢复」回来，重启服务。 这种方案，我们称之为「冷备」。为什么叫冷备呢？因为 B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用。 但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证。 所以，我们还是需要用「主从副本」的方式，在 B 机房部署 A 机房的数据副本，架构就变成了这样： 这样，就算整个 A 机房挂掉，我们在 B 机房也有比较「完整」的数据。 数据是保住了，但这时你需要考虑另外一个问题：如果 A 机房真挂掉了，要想保证服务不中断，你还需要在 B 机房「紧急」做这些事情： B 机房所有从库提升为主库 在 B 机房部署应用，启动服务 部署接入层，配置转发规则 DNS 指向 B 机房，接入流量，业务恢复 看到了么？A 机房故障后，B 机房需要做这么多工作，你的业务才能完全「恢复」过来。 你看，整个过程需要人为介入，且需花费大量时间来操作，恢复之前整个服务还是不可用的，这个方案还是不太爽，如果能做到故障后立即「切换」，那就好了。 因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「提前」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样： 这样的话，A 机房整个挂掉，我们只需要做 2 件事即可： B 机房所有从库提升为主库 DNS 指向 B 机房，接入流量，业务恢复 这样一来，恢复速度快了很多。 到这里你会发现，B 机房从最开始的「空空如也」，演变到现在，几乎是「镜像」了一份 A 机房的所有东西，从最上层的接入层，到中间的业务应用，到最下层的存储。 两个机房唯一的区别是，A 机房的存储都是主库，而 B 机房都是从库。 这种方案，我们把它叫做「热备」。 热的意思是指，B 机房处于「待命」状态，A 故障后 B 可以随时「接管」流量，继续提供服务。热备相比于冷备最大的优点是：随时可切换。 无论是冷备还是热备，因为它们都处于「备用」状态，所以我们把这两个方案统称为：同城灾备。 同城灾备的最大优势在于，我们再也不用担心「机房」级别的故障了，一个机房发生风险，我们只需把流量切换到另一个机房即可，可用性再次提高，是不是很爽？（后面还有更爽的） 06 同城双活我们继续来看这个架构。 虽然我们有了应对机房故障的解决方案，但这里有个问题是我们不能忽视的：A 机房挂掉，全部流量切到 B 机房，B 机房能否真的如我们所愿，正常提供服务？ 这是个值得思考的问题。 这就好比有两支军队 A 和 B，A 军队历经沙场，作战经验丰富，而 B 军队只是后备军，除了有军人的基本素养之外，并没有实战经验，战斗经验基本为 0。 如果 A 军队丧失战斗能力，需要 B 军队立即顶上时，作为指挥官的你，肯定也会担心 B 军队能否真的担此重任吧？ 我们的架构也是如此，此时的 B 机房虽然是随时「待命」状态，但 A 机房真的发生故障，我们要把全部流量切到 B 机房，其实是不敢百分百保证它可以「如期」工作的。 你想，我们在一个机房内部署服务，还总是发生各种各样的问题，例如：发布应用的版本不一致、系统资源不足、操作系统参数不一样等等。现在多部署一个机房，这些问题只会增多，不会减少。 另外，从「成本」的角度来看，我们新部署一个机房，需要购买服务器、内存、硬盘、带宽资源，花费成本也是非常高昂的，只让它当一个后备军，未免也太「大材小用」了！ 因此，我们需要让 B 机房也接入流量，实时提供服务，这样做的好处，一是可以实时训练这支后备军，让它达到与 A 机房相同的作战水平，随时可切换，二是 B 机房接入流量后，可以分担 A 机房的流量压力。这才是把 B 机房资源优势，发挥最大化的最好方案！ 那怎么让 B 机房也接入流量呢？很简单，就是把 B 机房的接入层 IP 地址，加入到 DNS 中，这样，B 机房从上层就可以有流量进来了。 但这里有一个问题：别忘了，B 机房的存储，现在可都是 A 机房的「从库」，从库默认可都是「不可写」的，B 机房的写请求打到本机房存储上，肯定会报错，这还是不符合我们预期。怎么办？ 这时，你就需要在「业务应用」层做改造了。 你的业务应用在操作数据库时，需要区分「读写分离」（一般用中间件实现），即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。 这会涉及到你用的所有存储，例如项目中用到了 MySQL、Redis、MongoDB 等等，操作这些数据库，都需要区分读写请求，所以这块需要一定的业务「改造」成本。 因为 A 机房的存储都是主库，所以我们把 A 机房叫做「主机房」，B 机房叫「从机房」。 两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。 业务改造完成后，B 机房可以慢慢接入流量，从 10%、30%、50% 逐渐覆盖到 100%，你可以持续观察 B 机房的业务是否存在问题，有问题及时修复，逐渐让 B 机房的工作能力，达到和 A 机房相同水平。 现在，因为 B 机房实时接入了流量，此时如果 A 机房挂了，那我们就可以「大胆」地把 A 的流量，全部切换到 B 机房，完成快速切换！ 到这里你可以看到，我们部署的 B 机房，在物理上虽然与 A 有一定距离，但整个系统从「逻辑」上来看，我们是把这两个机房看做一个「整体」来规划的，也就是说，相当于把 2 个机房当作 1 个机房来用。 这种架构方案，比前面的同城灾备更「进了一步」，B 机房实时接入了流量，还能应对随时的故障切换，这种方案我们把它叫做「同城双活」。 因为两个机房都能处理业务请求，这对我们系统的内部维护、改造、升级提供了更多的可实施空间（流量随时切换），现在，整个系统的弹性也变大了，是不是更爽了？ 那这种架构有什么问题呢？ 07 两地三中心还是回到风险上来说。 虽然我们把 2 个机房当做一个整体来规划，但这 2 个机房在物理层面上，还是处于「一个城市」内，如果是整个城市发生自然灾害，例如地震、水灾（河南水灾刚过去不久），那 2 个机房依旧存在「全局覆没」的风险。 真是防不胜防啊？怎么办？没办法，继续冗余。 但这次冗余机房，就不能部署在同一个城市了，你需要把它放到距离更远的地方，部署在「异地」。 通常建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。 假设之前的 A、B 机房在北京，那这次新部署的 C 机房可以放在上海。 按照前面的思路，把 C 机房用起来，最简单粗暴的方案还就是做「冷备」，即定时把 A、B 机房的数据，在 C 机房做备份，防止数据丢失。 这种方案，就是我们经常听到的「两地三中心」。 两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。 这种架构方案，通常用在银行、金融、政企相关的项目中。它的问题还是前面所说的，启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作。 所以，要想真正的抵御城市级别的故障，越来越多的互联网公司，开始实施「异地双活」。 08 伪异地双活这里，我们还是分析 2 个机房的架构情况。我们不再把 A、B 机房部署在同一个城市，而是分开部署，例如 A 机房放在北京，B 机房放在上海。 前面我们讲了同城双活，那异地双活是不是直接「照搬」同城双活的模式去部署就可以了呢？ 事情没你想的那么简单。 如果还是按照同城双活的架构来部署，那异地双活的架构就是这样的： 注意看，两个机房的网络是通过「跨城专线」连通的。 此时两个机房都接入流量，那上海机房的请求，可能要去读写北京机房的存储，这里存在一个很大的问题：网络延迟。 因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「不可忽视」的因素了。 北京到上海的距离大约 1300 公里，即使架设一条高速的「网络专线」，光纤以光速传输，一个来回也需要近 10ms 的延迟。 况且，网络线路之间还会经历各种路由器、交换机等网络设备，实际延迟可能会达到 30ms ~ 100ms，如果网络发生抖动，延迟甚至会达到 1 秒。 不止是延迟，远距离的网络专线质量，是远远达不到机房内网络质量的，专线网络经常会发生延迟、丢包、甚至中断的情况。总之，不能过度信任和依赖「跨城专线」。 你可能会问，这点延迟对业务影响很大吗？影响非常大！ 试想，一个客户端请求打到上海机房，上海机房要去读写北京机房的存储，一次跨机房访问延迟就达到了 30ms，这大致是机房内网网络（0.5 ms）访问速度的 60 倍（30ms &#x2F; 0.5ms），一次请求慢 60 倍，来回往返就要慢 100 倍以上。 而我们在 App 打开一个页面，可能会访问后端几十个 API，每次都跨机房访问，整个页面的响应延迟有可能就达到了秒级，这个性能简直惨不忍睹，难以接受。 看到了么，虽然我们只是简单的把机房部署在了「异地」，但「同城双活」的架构模型，在这里就不适用了，还是按照这种方式部署，这是「伪异地双活」！ 那如何做到真正的异地双活呢？ 09 真正的异地双活既然「跨机房」调用延迟是不容忽视的因素，那我们只能尽量避免跨机房「调用」，规避这个延迟问题。 也就是说，上海机房的应用，不能再「跨机房」去读写北京机房的存储，只允许读写上海本地的存储，实现「就近访问」，这样才能避免延迟问题。 还是之前提到的问题：上海机房存储都是从库，不允许写入啊，除非我们只允许上海机房接入「读流量」，不接收「写流量」，否则无法满足不再跨机房的要求。 很显然，只让上海机房接收读流量的方案不现实，因为很少有项目是只有读流量，没有写流量的。所以这种方案还是不行，这怎么办？ 此时，你就必须在「存储层」做改造了。 要想上海机房读写本机房的存储，那上海机房的存储不能再是北京机房的从库，而是也要变为「主库」。 你没看错，两个机房的存储必须都是「主库」，而且两个机房的数据还要「互相同步」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。 因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。 怎么实现这种「双主」架构呢？它们之间如何互相同步数据？ 如果你对 MySQL 有所了解，MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「数据同步中间件」来实现双向同步的功能。 此外，除了数据库这种有状态的软件之外，你的项目通常还会使用到消息队列，例如 RabbitMQ、Kafka，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房。 看到了么，这一下子复杂度就上来了，单单针对每个数据库、队列开发同步中间件，就需要投入很大精力了。 业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。 很多有能力的公司，也会采用自研同步中间件的方式来做，例如饿了么、携程、美团都开发了自己的同步中间件。 我也有幸参与设计开发了 MySQL、Redis&#x2F;Codis、MongoDB 的同步中间件，有时间写一篇文章详细聊聊实现细节，欢迎持续关注。:) 现在，整个架构就变成了这样： 注意看，两个机房的存储层都互相同步数据的。有了数据同步中间件，就可以达到这样的效果： 北京机房写入 X &#x3D; 1 上海机房写入 Y &#x3D; 2 数据通过中间件双向同步 北京、上海机房都有 X &#x3D; 1、Y &#x3D; 2 的数据 这里我们用中间件双向同步数据，就不用再担心专线问题，专线出问题，我们的中间件可以自动重试，直到成功，达到数据最终一致。 但这里还会遇到一个问题，两个机房都可以写，操作的不是同一条数据那还好，如果修改的是同一条的数据，发生冲突怎么办？ 用户短时间内发了 2 个修改请求，都是修改同一条数据 一个请求落在北京机房，修改 X &#x3D; 1（还未同步到上海机房） 另一个请求落在上海机房，修改 X &#x3D; 2（还未同步到北京机房） 两个机房以哪个为准？ 也就是说，在很短的时间内，同一个用户修改同一条数据，两个机房无法确认谁先谁后，数据发生「冲突」。 这是一个很严重的问题，系统发生故障并不可怕，可怕的是数据发生「错误」，因为修正数据的成本太高了。我们一定要避免这种情况的发生。解决这个问题，有 2 个方案。 第一个方案，数据同步中间件要有自动「合并」数据、解决「冲突」的能力。 这个方案实现起来比较复杂，要想合并数据，就必须要区分出「先后」顺序。我们很容易想到的方案，就是以「时间」为标尺，以「后到达」的请求为准。 但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题。例如： 第 1 个请求落到北京机房，北京机房时钟是 10:01，修改 X &#x3D; 1 第 2 个请求落到上海机房，上海机房时钟是 10:00，修改 X &#x3D; 2 因为北京机房的时间「更晚」，那最终结果就会是 X &#x3D; 1。但这里其实应该以第 2 个请求为准，X &#x3D; 2 才对。 可见，完全「依赖」时钟的冲突解决方案，不太严谨。 所以，通常会采用第二种方案，从「源头」就避免数据冲突的发生。 10 如何实施异地双活既然自动合并数据的方案实现成本高，那我们就要想，能否从源头就「避免」数据冲突呢？ 这个思路非常棒！ 从源头避免数据冲突的思路是：在最上层接入流量时，就不要让冲突的情况发生。 具体来讲就是，要在最上层就把用户「区分」开，部分用户请求固定打到北京机房，其它用户请求固定打到上海 机房，进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免「跨机房」。 所以这时，你需要在接入层之上，再部署一个「路由层」（通常部署在云服务器上），自己可以配置路由规则，把用户「分流」到不同的机房内。 但这个路由规则，具体怎么定呢？有很多种实现方式，最常见的我总结了 3 类： 按业务类型分片 直接哈希分片 按地理位置分片 1、按业务类型分片 这种方案是指，按应用的「业务类型」来划分。 举例：假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。 这样一来，应用 1、2 的所有业务请求，只读写北京机房存储，应用 3、4 的所有请求，只会读写上海机房存储。 这样按业务类型分片，也可以避免同一个用户修改同一条数据。 这里按业务类型在不同机房接入流量，还需要考虑多个应用之间的依赖关系，要尽可能的把完成「相关」业务的应用部署在同一个机房，避免跨机房调用。 例如，订单、支付服务有依赖关系，会产生互相调用，那这 2 个服务在 A 机房接入流量。社区、发帖服务有依赖关系，那这 2 个服务在 B 机房接入流量。 2、直接哈希分片 这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。 举例：一共 200 个用户，根据用户 ID 计算哈希值，然后根据路由规则，把用户 1 - 100 路由到北京机房，101 - 200 用户路由到上海机房，这样，就避免了同一个用户修改同一条数据的情况发生。 3、按地理位置分片 这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。 拿外卖服务举例，你要点外卖肯定是「就近」点餐，整个业务范围相关的有商家、用户、骑手，它们都是在相同的地理位置内的。 针对这种特征，就可以在最上层，按用户的「地理位置」来做分片，分散到不同的机房。 举例：北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。 提醒：这 3 种常见的分片规则，第一次看不太好理解，建议配合图多理解几遍。搞懂这 3 个分片规则，你才能真正明白怎么做异地多活。 总之，分片的核心思路在于，让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问。 阿里在实施这种方案时，给它起了个名字，叫做「单元化」。 当然，最上层的路由层把用户分片后，理论来说同一个用户只会落在同一个机房内，但不排除程序 Bug 导致用户会在两个机房「漂移」。 安全起见，每个机房在写存储时，还需要有一套机制，能够检测「数据归属」，应用层操作存储时，需要通过中间件来做「兜底」，避免不该写本机房的情况发生。（篇幅限制，这里不展开讲，理解思路即可） 现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换，简直不要太爽。 不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。 这里还有一种情况，是无法做数据分片的：全局数据。例如系统配置、商品库存这类需要强一致的数据，这类服务依旧只能采用写主机房，读从机房的方案，不做双活。 双活的重点，是要优先保证「核心」业务先实现双活，并不是「全部」业务实现双活。 至此，我们才算实现了真正的「异地双活」！ 到这里你可以看出，完成这样一套架构，需要投入的成本是巨大的。 路由规则、路由转发、数据同步中间件、数据校验兜底策略，不仅需要开发强大的中间件，同时还要业务配合改造（业务边界划分、依赖拆分）等一些列工作，没有足够的人力物力，这套架构很难实施。 11 异地多活理解了异地双活，那「异地多活」顾名思义，就是在异地双活的基础上，部署多个机房即可。架构变成了这样： 这些服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。 但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。 所以业界又把这一架构又做了进一步优化，把「网状」架构升级为「星状」： 这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房。 这样做的好处是，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。 但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。 至此，我们的系统彻底实现了「异地多活」！ 多活的优势在于，可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」，大大提高了系统的可用性。 同时，我们也再也不用担心系统规模的增长，因为这套架构具有极强的「扩展能力」。 怎么样？我们从一个最简单的应用，一路优化下来，到最终的架构方案，有没有帮你彻底理解异地多活呢？ 总结好了，总结一下这篇文章的重点。 1、一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要 2、系统发生故障并不可怕，能以「最快」的速度恢复，才是高可用追求的目标，异地多活是实现高可用的有效手段 3、提升高可用的核心是「冗余」，备份、主从副本、同城灾备、同城双活、两地三中心、异地双活，异地多活都是在做冗余 4、同城灾备分为「冷备」和「热备」，冷备只备份数据，不提供服务，热备实时同步数据，并做好随时切换的准备 5、同城双活比灾备的优势在于，两个机房都可以接入「读写」流量，提高可用性的同时，还提升了系统性能。虽然物理上是两个机房，但「逻辑」上还是当做一个机房来用 6、两地三中心是在同城双活的基础上，额外部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害，但启用灾备机房需要时间 7、异地双活才是抵御「城市」级别灾害的更好方案，两个机房同时提供服务，故障随时可切换，可用性高。但实现也最复杂，理解了异地双活，才能彻底理解异地多活 8、异地多活是在异地双活的基础上，任意扩展多个机房，不仅又提高了可用性，还能应对更大规模的流量的压力，扩展性最强，是实现高可用的最终方案 后记这篇文章我从「宏观」层面，向你介绍了异地多活架构的「核心」思路，整篇文章的信息量还是很大的，如果不太好理解，我建议你多读几遍。 因为篇幅限制，很多细节我并没有展开来讲。这篇文章更像是讲异地多活的架构之「道」，而真正实施的「术」，要考虑的点其实也非常繁多，因为它需要开发强大的「基础设施」才可以完成实施。 不仅如此，要想真正实现异地多活，还需要遵循一些原则，例如业务梳理、业务分级、数据分类、数据最终一致性保障、机房切换一致性保障、异常处理等等。同时，相关的运维设施、监控体系也要能跟得上才行。 宏观上需要考虑业务（微服务部署、依赖、拆分、SDK、Web 框架）、基础设施（服务发现、流量调度、持续集成、同步中间件、自研存储），微观上要开发各种中间件，还要关注中间件的高性能、高可用、容错能力，其复杂度之高，只有亲身参与过之后才知道。 我曾经有幸参与过，存储层同步中间件的设计与开发，实现过「跨机房」同步 MySQL、Redis、MongoDB 的中间件，踩过的坑也非常多。当然，这些中间件的设计思路也非常有意思，有时间单独分享一下这些中间件的设计思路。 值得提醒你的是，只有真正理解了「异地双活」，才能彻底理解「异地多活」。在我看来，从同城双活演变为异地双活的过程，是最为复杂的，最核心的东西包括，业务单元化划分、存储层数据双向同步、最上层的分片逻辑，这些是实现异地多活的重中之重。 希望我分享的架构经验，对你有所启发。 - EOF - 推荐阅读 点击标题可跳转 1、吃透 MQ 2、这 40 个 Python 可视化图表案例，强烈建议收藏！ 3、Redis 夺命连环 11 问 看完本文有收获？请转发分享给更多人 推荐关注「数据分析与开发」，提升数据技能 点赞和在看就是最大的支持 ❤️","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"收藏","slug":"收藏","permalink":"https://liangyuanzheng.com/tags/%E6%94%B6%E8%97%8F/"},{"name":"review","slug":"review","permalink":"https://liangyuanzheng.com/tags/review/"}]},{"title":"Awesome-LLM","slug":"Awesome-LLM","date":"2024-11-15T01:52:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"Awesome-LLM.html","link":"","permalink":"https://liangyuanzheng.com/Awesome-LLM.html","excerpt":"","text":"Awesome-LLM 🔥 Large Language Models (LLM) have taken the NLP community AI community the Whole World by storm. Here is a curated list of papers about large language models, especially relating to ChatGPT. It also contains frameworks for LLM training, tools to deploy LLM, courses and tutorials about LLM and all publicly available LLM checkpoints and APIs. Awesome-LLM Milestone Papers Other Papers LLM Leaderboard Open LLM LLM Data LLM Evaluation LLM Training Framework LLM Deployment LLM Applications LLM Books Great thoughts about LLM Miscellaneous Awesome-Chinese-LLM整理开源的中文大语言模型，以规模较小、可私有化部署、训练成本较低的模型为主，包括底座模型，垂直领域微调及应用，数据集与教程等。 自 ChatGPT 为代表的大语言模型（Large Language Model, LLM）出现以后，由于其惊人的类通用人工智能（AGI）的能力，掀起了新一轮自然语言处理领域的研究和应用的浪潮。尤其是以 ChatGLM、LLaMA 等平民玩家都能跑起来的较小规模的 LLM 开源之后，业界涌现了非常多基于 LLM 的二次微调或应用的案例。本项目旨在收集和梳理中文 LLM 相关的开源模型、应用、数据集及教程等资料，目前收录的资源已达 100+个！ 目录 1. 模型 1.1 文本 LLM 模型 1.2 多模态 LLM 模型 2. 应用 2.1 垂直领域微调 医疗 法律 金融 教育 科技 电商 网络安全 农业 2.2 LangChain 应用 2.3 其他应用 3. 数据集 预训练数据集 SFT 数据集 偏好数据集 4. LLM 训练微调框架 5. LLM 推理部署框架 6. LLM 评测 7. LLM 教程 LLM 基础知识 提示工程教程 LLM 应用教程 LLM 实战教程 8. 相关仓库 Star History Awesome-LLMOpsAn awesome &amp; curated list of best LLMOps tools for developers。 Table of Contents Model Large Language Model CV Foundation Model Audio Foundation Model Serving Large Model Serving Frameworks&#x2F;Servers for Serving Observability Security LLMOps Search Vector search Code AI Training IDEs and Workspaces Foundation Model Fine Tuning Frameworks for Training Experiment Tracking Visualization Model Editing Data Data Management Data Storage Data Tracking Feature Engineering Data&#x2F;Feature enrichment Large Scale Deployment ML Platforms Workflow Scheduling Model Management Performance ML Compiler Profiling AutoML Optimizations Federated ML Awesome Lists awesome-LLMs-In-China中国大模型大全，全面收集有明确来源的大模型情况，包括机构、来源信息和分类等，随时更新。 旨在记录中国大模型发展情况，欢迎在Issues中提供提供线索和素材 使用数据请注明来源：微信公众号：走向未来 和 仓库：https://github.com/wgwang/awesome-LLMs-In-China Awesome family related to LLMS includes: https://github.com/wgwang/awesome-LLM-benchmarks https://github.com/wgwang/awesome-LLMs-In-China https://github.com/wgwang/awesome-open-foundation-models 大模型相关的 Awesome 系列包括： 大模型评测数据集： https://github.com/wgwang/awesome-LLM-benchmarks 中国大模型列表： https://github.com/wgwang/awesome-LLMs-In-China 开源开放基础大模型列表： https://github.com/wgwang/awesome-open-foundation-models awesome-LLM-resourses ：★★★★☆这个好 全世界最好的 LLM 资料总结 | Summary of the world’s best LLM resources. 数据 Data 微调 Fine-Tuning 推理 Inference 评估 Evaluation 体验 Usage 知识库 RAG 智能体 Agents 搜索 Search 书籍 Book 课程 Course 教程 Tutorial 论文 Paper Tips Awesome-Domain-LLM自以 ChatGPT 为代表的大语言模型出现以后，掀起了新一轮研究和应用浪潮，出现了许多包括 LLaMA、ChatGLM、Baichuan、Qwen 等在内的通用模型。随后，来自不同领域的从业人员在通用模型的基础上通过持续预训练&#x2F;指令微调将其应用于垂直领域。 本项目旨在收集和梳理垂直领域的开源模型、数据集及评测基准。欢迎大家贡献本项目未收录的开源模型、数据集、评测基准等内容，一起推动大模型赋能各行各业！ 🤖 模型 🌐 通用模型 🧩 领域模型 🏥 医疗 ⚖ 法律 💰 金融 🎓 教育 ➕ 其他 📚 数据集 📏 评测基准 📎 附录 ✨ 点赞历史 🤝 友情链接 awesome_LLMs_interview_notesLLMs interview notes and answers","categories":[{"name":"LLM","slug":"llm","permalink":"https://liangyuanzheng.com/categories/llm/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"索引下推","slug":"索引下推","date":"2024-10-31T11:50:00.000Z","updated":"2025-10-27T00:35:41.797Z","comments":true,"path":"索引下推.html","link":"","permalink":"https://liangyuanzheng.com/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.html","excerpt":"","text":"mysql 架构 MySQL 服务层：也就是 SERVER 层，用来解析 SQL 的语法、语义、生成查询计划、接管从 MySQL 存储引擎层上推的数据进行二次过滤等等。 MySQL 存储引擎层：按照 MySQL 服务层下发的请求，通过索引或者全表扫描等方式把数据上传到 MySQL 服务层。 MySQL 索引扫描：根据指定索引过滤条件，遍历索引找到索引键对应的主键值后回表过滤剩余过滤条件。 MySQL 索引过滤：通过索引扫描并且基于索引进行二次条件过滤后再回表。 Mysql 性能优化：什么是索引下推？索引条件下推优化 （Index Condition Pushdown (ICP) ） 是 MySQL 5.6 添加的，用于优化数据查询。 不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给 MySQL Server，MySQL Server 进行过滤条件的判断。 当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server 将这一部分判断条件下推给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL Server 传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。 例如一张表，建了一个联合索引（name, age），查询语句：select * from t_user where name like &#39;张%&#39; and age=10;，由于 name 使用了范围查询，根据最左匹配原则： 不使用 ICP，引擎层查找到 name like &#39;张%&#39; 的数据，再由 Server 层去过滤 age=10 这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段 age。 没有使用 ICP 但是，使用了索引下推优化，把 where 的条件放到了引擎层执行，直接根据 name like &#39;张%&#39; and age=10 的条件进行过滤，减少了回表的次数。 使用 ICP 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。 索引下推的使用条件ICP 目标是减少全行记录读取，从而减少 IO 操作，只能用于非聚簇索引。聚簇索引本身包含的表数据，也就不存在下推一说。只能用于 range、 ref、 eq_ref、ref_or_null 访问方法；Where 条件中是用 and 而非 or 的时候。ICP 适用于分区表。ICP 不支持基于虚拟列上建立的索引，比如说函数索引ICP 不支持引用子查询作为条件。ICP 不支持存储函数作为条件，因为存储引擎无法调用存储函数。 123456# 查看索引下推是否开启select @@optimizer_switch# 开启索引下推set optimizer_switch=\"index_condition_pushdown=on\";# 关闭索引下推set optimizer_switch=\"index_condition_pushdown=off\"; 通过执行计划查看是否使用索引下推除此之外我们还可以看一下执行计划，看到Extra一列里Using index condition，这就是用到了索引下推。 12345+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | tuser | NULL | range | na_index | na_index | 102 | NULL | 2 | 25.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+ 参考文献什么是索引下推？（深入精讲）Mysql 性能优化：什么是索引下推？","categories":[{"name":"数据库","slug":"数据库","permalink":"https://liangyuanzheng.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"IT技术社区","slug":"IT技术社区","date":"2024-10-29T10:32:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"IT技术社区.html","link":"","permalink":"https://liangyuanzheng.com/IT%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA.html","excerpt":"","text":"传统 IT 技术社区 csdn 博客园 51cto chinaunix ITEye 新型的技术社区 segmentfault 掘金 开发者头条 开源中国 helloworld.net 国外技术社区 dev：dev社区和国内的掘金社区很相似，技术分类也比较多，像Java、Python、js、分布式等应有尽有，文章质量普遍都还不错，其实如果平时多留意不难发现，掘金上有一些文章是翻译自dev社区。 stack overflow：一个问答类的技术社区，和国内知乎比较相似，但与知乎不同的是stackoverflow 更垂直于技术，不像知乎内容比较杂。 simple programmer：简单的程序员，这个网站上纯技术文章不多，指导建议性的文章比较多。讲述一些职场、以及软件开发中的一些“ 潜规则” tutorialspoint：网站提供很多课程、技术文章，还有一些很实用的工具，比如：JSON 格式化，base64 转化工具等。 sitepoint：sitepoint 是一个偏向前端、移动端的技术网站，有一些高质量的前端方面的文章、电子书。 Google Developers：开发者社区，不吹不黑摸着良心说还是比较权威的。 daniweb： daniweb 也是一个质量比较高的问答平台，看着有点像社交平台感脚。 Dzone：Dzone 是一个技术涵盖比较全面的网站，像云平台、数据库、物联网、开发运维、Java 语言等都有。 dreamincode：dreamincode、以及下边的 bytes 是两个相对小众的技术博客，界面和 博客园 风格颇为相似，属于简约而不简单的那种。 bytes：","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"域名系统（DNS）","slug":"域名系统（DNS）","date":"2024-10-24T06:18:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"域名系统（DNS）.html","link":"","permalink":"https://liangyuanzheng.com/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%EF%BC%88DNS%EF%BC%89.html","excerpt":"","text":"域名系统域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 DNS 最早于 1983 年由保罗·莫卡派乔斯（Paul Mockapetris）发明。 资源记录类型DNS 系统中，常见的资源记录类型有： A 记录：主机记录。A 记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的 IP 地址上。 CNAME 记录：别名记录。CNAME 记录用于将某个别名指向到某个 A 记录上，这样就不需要再为某个新名字另外创建一条新的 A 记录。 AAAA 记录：IPv 6 主机记录。与 A 记录对应，用于将特定的主机名映射到一个主机的IPv 6 地址。 SRV 记录：服务位置记录。用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。 NS 记录：域名服务器记录。用来指定该域名由哪个 DNS 服务器来进行解析。 NAPTR 记录：它提供了正则表达式方式去映射一个域名。NAPTR 记录非常著名的一个应用是用于 ENUM 查询。 记录 说明 A 主机记录。A 记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的 IP 地址上。 CNAME 别名记录。CNAME 记录用于将某个别名指向到某个 A 记录上，这样就不需要再为某个新名字另外创建一条新的 A 记录。 AAAA IPv 6 主机记录。与 A 记录对应，用于将特定的主机名映射到一个主机的IPv 6 地址。 SRV 服务位置记录。用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。 NS 域名服务器记录。用来指定该域名由哪个 DNS 服务器来进行解析。 NAPTR 它提供了正则表达式方式去映射一个域名。NAPTR 记录非常著名的一个应用是用于 ENUM 查询。 域名解析过程 域名系统","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"TODO","slug":"todo","permalink":"https://liangyuanzheng.com/tags/todo/"}]},{"title":"Linux dig 命令：查询单个域名的 DNS 信息","slug":"20241023115736-Linux-dig-命令","date":"2024-10-23T03:57:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20241023115736-Linux-dig-命令.html","link":"","permalink":"https://liangyuanzheng.com/20241023115736-Linux-dig-%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"本文系外部转帖，查看原文 Dig 命令主要用来从 DNS 域名服务器查询主机地址信息。 查询单个域名的 DNS 信息Dig 命令最典型的用法就是查询单个主机的信息。 Dig 命令默认的输出信息比较丰富，大概可以分为 5 个部分。第一部分显示 dig 命令的版本和输入的参数。第二部分显示服务返回的一些技术详情，比较重要的是 status。如果 status 的值为 NOERROR 则说明本次查询成功结束。第三部分中的 “QUESTION SECTION” 显示我们要查询的域名。第四部分的 “ANSWER SECTION” 是查询到的结果。第五部分则是本次查询的一些统计信息，比如用了多长时间，查询了哪个 DNS 服务器，在什么时间进行的查询等等。 默认情况下 dig 命令查询 A 记录，上图中显示的 A 即说明查询的记录类型为 A 记录。在尝试查询其它类型的记录前让我们先来了解一下常见的 DNS 记录类型。 常见 DNS 记录的类型类型目的A地址记录，用来指定域名的 IPv 4 地址，如果需要将域名指向一个 IP 地址，就需要添加 A 记录。AAAA用来指定主机名 (或域名) 对应的 IPv 6 地址记录。CNAME如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录。MX如果需要设置邮箱，让邮箱能够收到邮件，需要添加 MX 记录。NS域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。SOASOA 这种记录是所有区域性文件中的强制性记录。它必须是一个文件中的第一个记录。TXT可以写任何东西，长度限制为 255。绝大多数的 TXT 记录是用来做 SPF 记录 (反垃圾邮件)。 查询 CNAME 类型的记录除了 A 记录，常见的 DNS 记录还有 CNAME，我们可以在查询时指定要查询的 DNS 记录类型： 1$ dig abc.filterinto.com CNAME 这样结果中就只有 CNAME 的记录。其实我们可以在查询中指定任何 DNS 记录的类型。 从指定的 DNS 服务器上查询由于一些原因，希望从指定的 DNS 服务器上进行查询 (从默认的 DNS 服务器上获得的结果可能不准确)。指定 DNS 服务器的方式为使用 @ 符号： 1$ dig @&lt;span&gt;8.8&lt;/span&gt;.&lt;span&gt;8.8&lt;/span&gt; abc.filterinto.com 从上图可以看到本次查询的 DNS 服务器为 8.8.8.8。 如果不指定 DNS 服务器，dig 会依次使用 &#x2F;etc&#x2F;resolv. Conf 里的地址作为 DNS 服务器： 上面查询的 DNS 服务器就变成了： 反向查询在前面的查询中我们指定了查询服务器为 8.8.8.8，这是谁家的 DNS 服务器？其实我们可以使用 dig 的 -x 选项来反向解析 IP 地址对应的域名： 好吧，应该是谷歌家的，可以放心使用了。 控制显示结果Dig 命令默认返回的结果展示详细的信息，如果要获得精简的结果可以使用 +short 选项： 1$ dig +&lt;span&gt;short&lt;/span&gt; abc.filterinto.com 这下显示的结果就清爽多了。其实我们还可以通过更多选项来控制输出的内容，比如只想显示 “ANSWER SECTION” 的内容： 1$ dig abc.filterinto.com +nocomments +noquestion +noauthority +noadditional +nostats 这个结果很不错，就是使用的选项太多了 (dig 命令有很多这样的选项，详情请参考使用手册)。我们可以换一种优雅一些的方式来实现和上面相同的结果： 1$ dig abc.filterinto.com +noall +answer 查看 TTL (Time to Live)TTL 是 DNS 解析中很重要的指标，主要是控制 DNS 记录在 DNS 服务器上的缓存时间： 查询结果中的单位是秒。通过下面的命令可以显示精简一些测结果： 1$ dig +nocmd +noall +answer +ttlid abc.filterinto.com 跟踪整个查询过程如果你好奇 dig 命令执行查询时都经历了哪些过程，你可以尝试使用 +trace 选项。它会输出从根域到最终结果的所有信息： 1$ dig +trace abc.filterinto.com 上图中显示的并不是一个完整的结果，感兴趣的朋友可以自己尝试。 总结Dig 是一个很给力 DNS 查询工具，本文仅介绍了其常见用法，更多的命令选项及使用方法请查看 man page。","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"复用：设计模式","slug":"10-复用：设计模式","date":"2024-09-05T06:46:00.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"10-复用：设计模式.html","link":"","permalink":"https://liangyuanzheng.com/10-%E5%A4%8D%E7%94%A8%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"复用：设计模式业务场景内行的设计者知道：不是解决任何问题都要从头做起。他们更愿意复用以前使用过的解决方案。当找到一个好的解决方案，他们会一遍一遍地使用。因此，你会在许多面向对象系统中看到类和相互通信的对象的重复模式。 设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，就能一次又一次地使用该方案而不必做重复劳动。 模式依目的可划分为三种： 创建型（Creational）：与对象创建有关，增加已有代码的灵活性和可复用性； 结构型（Structural）：处理类或对象的组合，并保持结构的灵活的高效； 行为型（Behavioral）：描述类或对象怎样交互和怎样分配职责。 案例各设计模式并不是孤立的，他们之间有着千丝万缕的联系： ——摘自 GOF 的 《设计模式：可复用面向对象软件的基础》。 限于篇幅，本文不再罗列各模式的具体实现。Go 版本实现可参考：《golang-design-pattern》 ⓵ 创建型模式 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 创建者模式（Builder） 原型模式（Prototype） 单例模式（Singleton） ⓶ 结构型模式 外观模式（Facade） 适配器模式（Adapter） 代理模式（Proxy） 组合模式（Composite） 享元模式（Flyweight） 装饰模式（Decorator） 桥模式（Bridge） ⓷ 行为型模式 中介者模式（Mediator） 观察者模式（Observer） 命令模式（Command） 迭代器模式（Iterator） 模板方法模式（Template Method） 策略模式（Strategy） 状态模式（State） 备忘录模式（Memento） 解释器模式（Interpreter） 职责链模式（Chain of Responsibility） 访问者模式（Visitor） 小结正如前面提到的：“不是解决任何问题都要从头做起”。 设计模式是一种在软件设计中解决问题的方法论，它可以提高代码的可维护性、可重用性和可扩展性，同时也有助于提高软件系统的可靠性和稳定性。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"DOING","slug":"doing","permalink":"https://liangyuanzheng.com/tags/doing/"}]},{"title":"诗词歌赋《合辑》","slug":"01-诗词歌赋《合辑》","date":"2024-08-27T16:00:00.000Z","updated":"2025-10-27T00:35:41.787Z","comments":true,"path":"01-诗词歌赋《合辑》.html","link":"","permalink":"https://liangyuanzheng.com/01-%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B%E3%80%8A%E5%90%88%E8%BE%91%E3%80%8B.html","excerpt":"","text":"《前出师表》——诸葛亮先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈於内，忠志之士忘身於外者，盖追先帝之殊遇，欲报之於陛下也。诚宜开张圣（德），以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。将军向宠，性行淑均，晓畅军事，试用於昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行陈和睦，优劣得所。亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨於桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，原陛下亲之信之，则汉室之隆，可计日而待也。 臣本布衣，躬耕於南阳，苟全性命於乱世，不求闻达於诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣於草庐之中，谘臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任於败军之际，奉命於危难之间，尔来二十有一年矣。先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐讬付不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝，而忠陛下之职分也。 至於斟酌损益，进尽忠言，则攸之、祎、允之任也。原陛下讬臣以讨贼兴复之效；不效，则治臣之罪，以告先帝之灵。〔若无兴德之言，则〕责攸之、祎、允等之慢，以彰其咎。陛下亦宜自谋，以谘诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激，今当远离，临表涕零，不知所言。 《后出师表》诸葛亮先帝虑汉、贼不两立，王业不偏安，故讬臣以讨贼也。以先帝之明，量臣之才，故知臣伐贼才弱敌强也；然不伐贼，王业亦亡，惟坐待亡，孰与伐之？是故讬臣而弗疑也。 臣受命之日，寝不安席，食不甘味，思惟北征，宜先入南，故五月渡泸，深入不毛，并日而食。臣非不自惜也，顾王业不得偏全於蜀都，故冒危难以奉先帝之遗意也，而议者谓为非计。今贼适疲於西，又务於东，兵法乘劳，此进趋之时也。谨陈其事如左： 高帝明并日月，谋臣渊深，然涉险被创，危然后安。今陛下未及高帝，谋臣不如良、平，而欲以长计取胜，坐定天下，此臣之未解一也。刘繇、王朗各据州郡，论安言计，动引圣人，群疑满腹，众难塞胸，今岁不战，明年不征，使孙策坐大，遂并江东，此臣之未解二也。曹操智计殊绝於人，其用兵也，仿佛孙、吴，然困於南阳，险於乌巢，危於祁连，逼於黎阳，几败北山，殆死潼关，然后伪定一时耳，况臣才弱，而欲以不危而定之，此臣之未解三也。曹操五攻昌霸不下，四越巢湖不成，任用李服而李服图之，委夏侯而夏侯败亡，先帝每称操为能，犹有此失，况臣驽下，何能必胜？此臣之未解四也。自臣到汉中，中间期年耳，然丧赵云、阳群、马玉、阎芝、丁立、白寿、刘郃、邓铜等及曲长屯将七十馀人，突将无前。賨、叟、青羌散骑、武骑一千馀人，此皆数十年之内所纠合四方之精锐，非一州之所有，若复数年，则损三分之二也，当何以图敌？此臣之未解五也。今民穷兵疲，而事不可息，事不可息，则住与行劳费正等，而不及今图之，欲以一州之地与贼持久，此臣之未解六也。 夫难平者，事也。昔先帝败军於楚，当此时，曹操拊手，谓天下以定。然后先帝东连吴、越，西取巴、蜀，举兵北征，夏侯授首，此操之失计而汉事将成也。然后吴更违盟，关羽毁败，秭归蹉跌，曹丕称帝。凡事如是，难可逆见。臣鞠躬尽力，死而后已，至於成败利钝，非臣之明所能逆睹也。 《定风波》苏轼·北宋 三月七日，沙湖道中遇雨，雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此(词)。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？ 一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 一蓑烟雨任平生 释义： 已而：不久，一会儿。 吟啸：吟咏长啸。 芒鞋：草鞋。 一蓑烟雨任平生：披着蓑衣在风雨里过一辈子也处之泰然。一蓑（suō）：蓑衣，用棕制成的雨披。 料峭：微寒的样子。 萧瑟：风雨吹落的声音。 也无风雨也无晴：风雨天气和晴朗天气是一样的，没有差别。也无风雨也无【晴】：晴与情谐音，手法为双关 ，意在指感情上也是如此。 《诉衷情·江山靠谁守》毛泽东 存疑。这首词可能不是主席写的。 《诉衷情·江山靠谁守》 当年忠贞为国筹，何曾怕断头？ 如今天下红遍，江山靠谁守？ 业未竟，身躯倦，鬓已秋。 你我之辈，忍将夙愿，付与东流？ 这首诗是毛主席去世前一年(1975 年），82 岁时写给周总理的。当时，毛主席身体不好，疾病缠身，周总理也身患癌症，亦在重病危急中。毛主席已经预感到，革命将发生曲折，他和周总理等老一辈无产阶级革命家夙愿将要“付与东流”。他问自己，也问周总理，社会主义的红色江山究竟“靠谁守”？ 这首词，字数虽然不多，但情感真挚，读来沧桑心碎，令人潸然泪下。其中“如今天下红遍，江山靠谁守”一句表达了对革命事业前途的担忧！正因为如此，许多版本的《毛泽东诗词》都不敢承认这首词；而更多版本则把它诞生的时间 1975 年 12 月 26 日改为 1974 年。其实这首词就是 1975 年毛泽东最后一个生日里独自观看故事影片《难忘的战斗》之后，又得知周恩来病情加重而写下的观后感…… 《哥舒歌》西鄙人·唐代 北斗七星高，哥舒夜带刀。至今窥牧马，不敢过临洮。 译文 黑夜里北斗七星挂得高高，哥舒翰勇猛守边夜带宝刀。吐蕃族至今牧马只敢远望，他们再不敢南来越过临洮。 注释 哥舒：指哥舒翰，是唐玄宗的大将，突厥族哥舒部的后裔。哥舒是以部落名称作为姓氏。《全唐诗》题下注：“天宝中，哥舒翰为安西节度使，控地数千里，甚著威令，故西鄙人歌此。”北斗七星：大熊座的一部分。窥：窃伺。牧马：指吐蕃越境放牧，指侵扰活动。临洮：今甘肃省洮河边的岷县。一说今甘肃省临潭县。秦筑长城西起于此。 《问刘十九》白居易·唐代 绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ 韵译 新酿的米酒，色绿香浓；小小红泥炉，烧得殷红。天快黑了大雪将至，能否一顾寒舍共饮一杯暖酒？ 意译 我家新酿的米酒还未过滤，酒面上泛起一层绿泡，香气扑鼻。用红泥烧制成的烫酒用的小火炉也已准备好了。天色阴沉，看样子晚上即将要下雪，能否留下与我共饮一杯？ 注释 刘十九：白居易留下的诗作中，提到刘十九的不多，仅两首。但提到刘二十八、二十八使君的，就很多了。刘二十八就是刘禹锡。刘十九乃其堂兄刘禹铜，系洛阳一富商，与白居易常有应酬。绿蚁：指浮在新酿的没有过滤的米酒上的绿色泡沫。醅（pēi）：酿造。绿蚁新醅酒：酒是新酿的酒。新酿酒未滤清时，酒面浮起酒渣，色微绿，细如蚁，称为“绿蚁”。雪：下雪，这里作动词用。无：表示疑问的语气词，相当于“么”或“吗” 《鹿柴》王维·唐代 空山不见人，但闻人语响。返景入深林，复照青苔上。 译文幽静的山谷里看不见人，只听到人说话的声音。落日余光映入了深林，又照在幽暗处的青苔上。 注释 鹿柴（zhài）：王维在辋川别业的胜景之一（在今陕西省蓝田县西南）。柴：通“寨”、“砦”，用树木围成的栅栏。但：只。返景（jǐng）：日光。一说“返景中景，同‘影’。意思是太阳将落时通过云彩反射的阳光”。复：又。 《相思》王维·唐代 红豆生南国，春来发几枝。愿君多采撷，此物最相思。 译文红豆生长在阳光明媚的南方，每逢春天不知长多少新枝。希望思念的人儿多多采摘，因为它最能寄托相思之情。 注释 相思：题一作“相思子”，又作“江上赠李龟年”。 红豆：又名相思子，一种生在江南地区的植物，结出的籽像豌豆而稍扁，呈鲜红色。 “春来”句：一作“秋来发故枝”。 “愿君”句：一作“劝君休采撷”。采撷（xié）：采摘。 相思：想念。 《登鹳雀楼》王之涣·唐代 白日依山尽，黄河入海流。欲穷千里目，更上一层楼。 译文站在高楼上，只见夕阳依傍着山峦慢慢沉落，滔滔黄河朝着大海汹涌奔流。想要看到千里之外的风光，那就要再登上更高的一层楼。 注释 鹳（guàn）雀（què）楼：旧址在山西永济市，前对中条山，下临黄河。传说常有鹳雀在此停留，故有此名。白日：太阳。依：依傍。尽：消失。 这句话是说太阳依傍山峦沉落。欲：想要得到某种东西或达到某种目的的愿望，但也有希望、想要的意思。穷：尽，使达到极点。千里目：眼界宽阔。更：再。 《行宫》元稹·唐代 寥落古行宫，宫花寂寞红。白头宫女在，闲坐说玄宗。 译文 曾经富丽堂皇的古行宫已是一片荒凉冷落，宫中艳丽的花儿在寂寞寥落中开放。幸存的几个满头白发的宫女，闲坐无事只能谈论着玄宗轶事。 注释 寥（liáo）落：寂寞冷落。行宫：皇帝在京城之外的宫殿。这里指当时东都洛阳的皇帝行宫上阳宫。宫花：行宫里的花。白头宫女：据白居易《上阳白发人》，一些宫女天宝末年被“潜配”到上阳宫，在这冷宫里一闭四十多年，成了白发宫人。说：谈论。玄宗：指唐玄宗。 《竹里馆》王维·唐代 独坐幽篁里，弹琴复长啸。深林人不知，明月来相照。 译文 独自闲坐在幽静竹林，一边弹琴一边高歌长啸。深深的山林中无人知晓，只有一轮明月静静与我相伴。 注释竹里馆：辋川别墅胜景之一，房屋周围有竹林，故名。幽篁（huáng）：幽深的竹林。啸（xiào）：撮口发出长而清脆的声音，类似于打口哨。深林：指“幽篁”。相照：与“独坐”相应，意思是说，左右无人相伴，唯有明月似解人意，偏来相照。长啸：撮口而呼，这里指吟咏、歌唱。古代一些超逸之士常用来抒发感情。魏晋名士称吹口哨为啸。 《相见欢·林花谢了春红 》李煜李煜·五代 林花谢了春红，太匆匆。无奈朝来寒雨晚来风。胭脂泪，相留醉，几时重。自是人生长恨水长东。(相留 一作：留人) 相见欢 《滕王阁序》王勃南昌故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰，台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。 时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得仙人之旧馆。层台耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，列冈峦之体势。披绣闼，俯雕甍，山原旷其盈视，川泽盱其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰迷津，青雀黄龙之轴。虹销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。 遥襟俯畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，指吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？ 嗟乎！时运不济，命运多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时。所赖君子安贫，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空怀报国之心；阮藉猖狂，岂效穷途之哭！ 勃三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今晨捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？ 鸣呼！胜地不常，盛筵难再。兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙诚，恭疏短引。一言均赋，四韵俱成。请洒潘江，各倾陆海云尔。 滕王高阁临江渚，佩玉鸣鸾罢歌舞。画栋朝飞南浦云，珠帘暮卷西山雨。闲云潭影日悠悠，物换星移几度秋。阁中帝子今何在？槛外长江空自流。 《秘色武器》陆龟蒙 唐九秋风露越窑开，夺得千峰翠色来。好向中宵盛沆瀣，共嵇中散斗遗杯。 这里说的是瓷器。 汤显祖《牡丹亭记题词》情不知所起一往而深天下女子有情，宁有如杜丽娘者乎！梦其人即病，病即弥连，至手画形容传于世而后死。死三年矣，复能溟莫中求得其所梦者而生。如丽娘者，乃可谓之有情人耳。情不知所起，一往而深。生者可以死，死可以生。生而不可与死，死而不可复生者，皆非情之至也。梦中之情，何必非真，天下岂少梦中之人耶？必因荐枕而成亲，待挂冠而为密者，皆形骸之论也。 传杜太守事者，仿佛晋武都守李仲文、广州守冯孝将儿女事。予稍为更而演之。至于杜守收考柳生，亦如汉睢阳王收考谈生也。 嗟夫，人世之事，非人世所可尽。自非通人，恒以理相格耳。第云理之所必无，安知情之所必有邪！ 《酬乐天杨州初逢席上见赠》刘禹锡·唐 巴山楚水凄凉地，二十三年弃置身。怀旧空吟闻笛赋，到乡翻似烂柯人。沉舟侧畔千帆过，病树前头万木春。今日听君歌一曲，暂凭杯酒长精神。 《大林寺桃花》白居易·唐代 人间四月芳菲尽，山寺桃花始胜开。长恨春归无觅处，不知转入此中来。 《早春呈水部十八员外》 韩愈 唐代韩愈·唐 天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。 《鸟鸣涧》王维 唐代王维·唐代 人闲桂花落，夜静春山空。月出惊山鸟，时鸣春涧中。 《望江南·超然台作》苏轼·北宋 春未老，风细柳斜斜。试上超然台上看，半壕春水一城花。烟雨暗千家。寒食后，酒醒却咨嗟。休对故人思故国，且将新火试新茶。诗酒趁年华。 https://m.gushiwen.cn/shiwenv_b8148e70fea6.aspx 《江南春》杜牧 唐杜牧·唐 千里茑啼绿映红，水村山郭酒旗风。南朝四百八十寺，多少楼台烟雨中。 https://m.gushiwen.cn/shiwenv_33cbdb2cf9b3.aspx 《咏柳》贺知章·唐代 碧玉妆成一树高，万条垂下绿丝绦。不知细叶谁裁出，二月春风似剪刀。 https://m.gushiwen.cn/shiwenv_9936770100ef.aspx 春日朱熹·宋 胜日寻芳泗水滨，无边光景一时新。等闲识得东风面，万紫千红总是春。 https://m.gushiwen.cn/shiwenv_ba4626c44270.aspx 《破阵子·为陈同甫赋壮词以寄之》辛弃疾 宋辛弃疾 宋 醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声，沙场秋点兵。马作的卢飞快，弓如霹雳弦惊。了却君王天下事，赢得生前身后名。可怜白发生！ https://m.gushiwen.cn/shiwenv_9822debcdc64.aspx 《青玉案·元夕》辛弃疾 宋辛弃疾 宋 东风夜放花千树，更吹落雨、星如雨。宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。蛾儿雪柳黄金缕，笑语盈盈暗香去。众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。 https://m.gushiwen.cn/shiwenv_51aa3a553057.aspx 静夜思李白·唐代 床前明月光，疑是地上霜。举头望明月，低头思故乡。 注释 静夜思：静静的夜里，产生的思绪。床：今传五种说法。一指井台。已经有学者撰文考证过。中国教育家协会理事程实将考证结果写成论文发表在刊物上，还和好友创作了《诗意图》。二指井栏。从考古发现来看，中国最早的水井是木结构水井。古代井栏有数米高，成方框形围住井口，防止人跌入井内，这方框形既像四堵墙，又像古代的床。因此古代井栏又叫银床，说明井和床有关系，其关系的发生则是由于两者在形状上的相似和功能上的类同。古代井栏专门有一个字来指称，即“韩”字。《说文》释“韩”为“井垣也”，即井墙之意。三“床”即“窗”的通假字。本诗中的‘床’字，是争论和异议的焦点。我们可以做一下基本推理。本诗的写作背景是在一个明月夜，很可能是月圆前后，作者由看到月光，再看到明月，又引起思乡之情。既然作者抬头看到了明月，那么作者不可能身处室内，在室内随便一抬头，是看不到月亮的。因此我们断定，‘床’是室外的一件物什，至于具体是什么，很难考证。从意义上讲，‘床’可能与‘窗’通假，而且在窗户前面是可能看到月亮的。但是，参照宋代版本，‘举头望山月’，便可证实作者所言乃是室外的月亮。从时间上讲，宋代版本比明代版本在对作者原意的忠诚度上，更加可靠。四取本义，即坐卧的器具，《诗经·小雅·斯干》有“载寐之牀”，《易·剥牀·王犊注》亦有“在下而安者也。”之说，讲得即是卧具。五马未都等认为，床应解释为胡床。胡床，亦称“交床”、“交椅”、“绳床”。古时一种可以折叠的轻便坐具，马扎功能类似小板凳，但人所坐的面非木板，而是可卷折的布或类似物，两边腿可合起来。现代人常为古代文献中或诗词中的“胡床”或“床”所误。至迟在唐时，“床”仍然是“胡床”（即马扎，一种坐具）。 疑：好像。举头：抬头。 《早发白帝城》李白·唐代 朝辞白帝彩云间，千里江陵一日还。两岸猿声啼不住，轻舟已过万重山。 https://m.gushici.net/shici/23/7153.html 咏鹅骆宾王·唐 鹅，鹅，鹅，曲项向天歌。白毛浮绿水，红掌拨清波。 https://m.gushici.net/shici/38/3523.html 《清明》杜牧·唐 清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。 https://m.gushiwen.cn/shiwenv_d3e3283daac5.aspx 《夜宿山寺》李白·唐代 危楼高百尺，手可摘星辰。不敢高声语，恐惊天上人。 https://m.gushiwen.cn/shiwenv_85f036fcc038.aspx 《西江月·夜行黄沙道中》辛弃疾 宋 明月别枝惊鹊，清风半夜鸣蝉(chán)。稻花香里说丰年，听取蛙(wā)声一片。 七八个星天外，两三点雨山前。旧时茅(máo)店社林边，路转溪桥忽见。(溪桥 一作：溪头) https://m.gushici.net/shici/14/50414.html 《晓出净慈寺送林子方》杨万里·宋代 毕竟西湖六月中，风光不与四时同。接天连叶无穷碧，映日荷花别样红。 译文及注释 译文到底是西湖六月天的景色，风光与其它季节大不相同。密密层层的荷叶铺展开去，一片无边无际的青翠碧绿，像与天相接，阳光下的荷花分外鲜艳娇红。 注释晓：太阳刚刚升起。净慈寺：全名“净慈报恩光孝禅寺”，与灵隐寺为杭州西湖南北山两大著名佛寺。林子方：作者的朋友，官居直阁秘书。毕竟： 到底。六月中：六月的时候。四时：春夏秋冬四个季节。在这里指六月以外的其他时节。同：相同。接天：像与天空相接。无穷：无边无际。无穷碧：因莲叶面积很广，似与天相接，故呈现无穷的碧绿。映日：太阳映照。别样：宋代俗语，特别，不一样。别样红：红得特别出色 创作背景 林子方与诗人志同道合、互视对方为知己。后来，林子方被调离皇帝身边，赴福州任职，职位知福州。林子方甚是高兴，自以为是仕途升迁。杨万里则不这么想，送林子方赴福州时，写下此诗，劝告林子方不要去福州。 赏析 这是一首描写西湖六月美丽景色的诗，这首诗是诗中有画，画中有诗的典范作品。 诗人开篇即说毕竟六月的西湖景色，风光不与其他季节相同，这两句质朴无华的诗句，更加说明夏天的西湖景色的与众不同。这两句是写六月西湖给诗人的总的感受。“毕竟”二字，突出了六月西湖风光的独特、非同一般，给人以丰富美好的想象。首句看似突兀，实际造句大气，虽然读者还不曾从诗中领略到西湖美景，但已能从诗人赞叹的语气中感受到了。诗句似脱口而出，是大惊大喜之余最直观的感受，因而更强化了西湖之美。 然后，诗人用充满强烈色彩对比的句子，给读者描绘出一幅大红大绿、精彩绝艳的画面：“接天莲叶无穷碧，映日荷花别样红。”这两句具体地描绘了“毕竟”不同的风景图画：随着湖面而伸展到尽头的荷叶与蓝天融合在一起，造成了“无穷”的艺术空间，涂染出无边无际的碧色；在这一片碧色的背景上，又点染出阳光映照下的朵朵荷花，红得那么娇艳、那么明丽。连天“无穷碧”的荷叶和映日“别样红”的荷花，不仅是春、秋、冬三季所见不到，就是夏季也只在六月中荷花最旺盛的时期才能看到。诗人抓住了这盛夏时特有的景物，概括而又贴切。这种在谋篇上的转化，虽然跌宕起伏，却没有突兀之感。看似平淡的笔墨，给读者展现了令人回味的艺术境地。 诗人的中心立意不在畅叙友谊，或者纠缠于离愁别绪，而是通过对西湖美景的极度赞美，曲折地表达对友人的眷恋。从艺术上来说，除了白描以外，此诗还有两点值得注意：一是虚实相生。前两句直陈，只是泛说，为虚；后两句描绘，展示具体形象，为实。虚实结合，相得益彰。二是刚柔相济。后两句所写的莲叶荷花，一般归入阴柔美一类，而诗人却把它写得非常壮美，境界阔大，有“天”，有“日”。语言也很有气势：“接天”“无穷”。这样，阳刚与柔美，就在诗歌中得到了和谐统一。 参考文献 https://m.gushici.net/shici/59/60637.html https://so.gushiwen.cn/shiwenv_3ab4125fd0f1.aspx 《七绝·诉情》南山一花奴·现代 忽有故人心上过，回首山河已是秋。两处相思同淋雪，此生也算共白头。 《己亥杂诗·其一百五十七》龚自珍·清 问我清游何日最，木樨风外等秋潮。忽有故人心上过，乃是虹生与子潇。 《八阵图》杜甫·唐代 功盖三分国，名成八阵图。江流石不转，遗恨失吞吴。 别董大高适·唐 千里黄云白曰曛，北风吹雁雪纷纷。莫愁前路无知己，天下谁人不识君。 《回乡偶书(二首)》 贺知章 唐回乡偶书(其一)贺知章·唐 少小离家老大回，乡音无改鬓毛衰。儿童相见不相识，笑问客从何处来。 回乡偶书(其二)贺知章·唐 离别家乡岁月多，近来人事半消磨。惟有门前镜湖水，春风不改旧时波。 词句注释 ⑴ 偶书：随便写的诗。偶，说明诗写作得很偶然，是随时有所见、有所感就写下来的。⑵ 少小离家：贺知章三十七岁中进士，在此以前就离开家乡。老大：年纪大了。贺知章回乡时已年逾八十。⑶ 乡音：家乡的口音。无改：没什么变化。一作“难改”。鬓毛衰：老年人须发稀疏变少。鬓毛，额角边靠近耳朵的头发。一作“面毛”。衰，此处应是减少的意思。⑷ 相见：即看见我。相，带有指代性的副词。不相识：即不认识我。⑸ 笑问：笑着询问。一作“却问”，一作“借问”。⑹ 消磨：逐渐消失、消除。⑺ 镜湖：湖泊名，在今浙江绍兴会稽山的北麓，方圆三百余里。贺知章的故乡就在镜湖边上。 创作背景：贺知章在唐玄宗天宝三载（744），辞去朝廷官职，告老返回故乡越州永兴（今浙江杭州萧山），时已八十六岁。此时距他离开家乡已有五十多个年头了。人生易老，世事沧桑，他心头有无限感慨，于是写下了这组诗。 《终南望余雪》祖咏·唐 终南阴岭秀，积雪浮云端。林表明霁色，城中增暮寒。 忆江南(词三首) 白居易 唐白居易·唐代 江南好，风景旧曾谙。日出江花红胜火，春来江水绿如蓝。能不忆江南？江南忆，最忆是杭州。山寺月中寻桂子，郡亭枕上看潮头。何日更重游？江南忆，其次忆吴宫。吴酒一杯春竹叶，吴娃双舞醉芙蓉。早晚复相逢？ 《绝句二首》杜甫·唐杜甫·唐代 其一迟日江山丽，春风花草香。泥融飞燕子，沙暖睡鸳鸯。 其二江碧鸟逾白，山青花欲燃。今春看又过，何日是归年。 村居高鼎·清 草长莺飞二月天，拂堤杨柳醉春烟。儿童放学归来早，忙趁东风放纸鸢。 译文农历二月，青草渐渐发芽生长，黄莺飞来飞去，轻拂堤岸的杨柳陶醉在春天的雾气中。村里的孩子们早早就放学回家，赶紧趁着东风把风筝放上蓝天。 注释村居：在乡村里居住时见到的景象。拂堤杨柳：杨柳枝条很长，垂下来，微微摆动，像是在抚摸堤岸。醉：迷醉，陶醉。春烟：春天水泽、草木等蒸发出来的雾气。散学：放学。纸鸢：泛指风筝，它是一种纸做的形状像老鹰的风筝。鸢：老鹰。 春雪韩愈·唐 新年都未有芳华，二月初惊见草芽。白雪却嫌春色晚，故穿庭树作飞花。 惠崇春江晚景二首苏轼·北宋 其一竹外桃花三两枝，春江水暖鸭先知。蒌蒿满地芦芽短，正是河豚欲上时。 其二两两归鸿欲破群，依依还似北归人。遥知朔漠多风雪，更待江南半月春。 春夜喜雨杜牧·唐 好雨知时节，当春乃发生。随风潜入夜，润物细无声。野径云俱黑，江船火独明。晓看红湿处，花重锦官城。 钱塘湖春行白居易·唐代 孤山寺北贾亭西，水面初平云脚低。几处早莺争䁔树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 《枫桥夜泊》张继·唐代 月落乌啼霜满天，江枫渔火对愁眠。姑苏城外寒山寺，夜半钟声到客船。 游园不值叶绍翁·宋 应怜屐（ji，一声）齿印苍苔，小扣柴扉久不开。春色满园关不住，一枝红杏出墙来。 译文也许是园主担心我的木屐踩坏他那爱惜的青苔，我轻轻地敲打柴门久久不开。满园子的春色是关不住的，开得正旺的红杏有一枝枝条伸到墙外来了。 https://so.gushiwen.cn/shiwenv_a31b957aba53.aspx 桃花源记陶渊明·魏晋 晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近，忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷。渔人甚异之，复前行，欲穷其林。 林尽水源，使得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田、美池、桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫（tiáo），并怡然自乐。 见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔（间隔一作：隔绝）。问今是何世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。余人各复延至其家，皆出酒食。停数日，辞去。此中人语云：“不足为外人道也。” 既出，得其船，便扶向路，处处志之。入郡下，诣太守，说如此。太守即遣人随其往，寻向所志，遂迷，不复得路。 南阳刘子骥，高尚士也，闻之，欣然规往。未果，寻病终。后遂无问津者。 桃花源记 《卜算子·送鲍浩然之浙东》王观·〔宋代〕 水是眼波横，山是眉峰聚。欲问行人去那边？眉眼盈盈处。才始送春归，又送君归去。若到江南赶上春，千万和春住。 https://so.gushiwen.cn/shiwenv_ee1bd6238d4a.aspx 陋室铭刘禹锡·唐 山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘清。谈笑有鸿儒，往来无白丁。可调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭 。孔子云：何陋之有？ 词句注释：陋室：简陋的屋子。铭：古代刻在器物上用来警戒自己或称述功德的文字，后来成为一种文体。名：出名，有名。灵：神异。斯是陋室，惟吾德馨（xīn）：这是简陋的屋舍，只因我（住屋的人）的品德好（就不感到简陋了）。斯，这。馨，能散布很远的香气，这里指德行美好。苔痕上阶绿，草色入帘青：苔痕蔓延到台阶上，使台阶都绿了；草色映入竹帘，使室内染上青色。鸿儒：博学的人。鸿，大。白丁：平民，指没有功名的人。调：调弄。素琴：不加装饰的琴。金经：指佛经（佛经用泥金书写）。无丝竹之乱耳：没有世俗的乐曲扰乱心境。丝，指弦乐器。竹，指管乐器。无案牍（dú）之劳形：没有官府公文劳神伤身。案牍，指官府文书。形，形体，躯体。南阳诸葛庐： 诸葛亮 隐居南阳住的草庐。西蜀子云亭：扬子云在西蜀的屋舍。西蜀，今四川。子云，即扬雄（前 53—18），字子云，蜀郡成都（今属四川）人，西汉哲学家、文学家。何陋之有：语出《论语·子罕》，意思是有什么简陋的呢？ https://so.gushiwen.cn/shiwenv_6c1ea9b7dd44.aspx 《夜雨寄北》李商隐 唐李商隐·唐 君问归期未有期，巴山夜雨涨秋池。何当共剪西窗烛，却话巴山夜雨时。 这首诗有三个结构：现在时，将来时，过去时。以回答的口吻，叙述今天的天气。畅想未来相聚时，与你讲讲今晚巴山的这场大雨。但是，这时他的妻子已经去世了。 《小池》杨万里·宋代 泉眼无声惜细流，树阴照水爱晴柔。（阴一作：荫）小荷才露尖尖角，早有蜻蜓立上头。 译文及注释 译文泉眼悄然无声是因舍不得细细的水流，映在水里的树阴喜欢这晴天里柔和的风光。小荷叶刚从水面露出尖尖的角，就有一只小蜻蜓立在它的上头。 注释泉眼：泉水的出口。惜：吝惜。照水：映在水里。晴柔：晴天里柔和的风光。尖尖角：初出水端还没有舒展的荷叶尖端。上头：上面，顶端。为了押韵，“头”不读轻声。 赏析 《小池》是一首七言绝句。全诗运用丰富新颖的想象以及拟人手法，细腻地描写了小池周边自然景物的特征和变化，宛如一幅花草虫鸟彩墨画。画面之中，池、泉、流、荷和蜻蜓，落笔都小，却玲珑剔透，生机盎然，表现了诗人对小池夏景及对大自然的喜爱之情。 创作背景 《小池》载于《诚斋集·江湖集》卷七，此集中所录之诗基本上按任职时间及季节的先后顺序来排列。《小池》诗其前第八个诗题是《丙申岁朝》。“丙申”即是宋孝宗淳熙三年（1176），“岁朝”是指农历正月初一，由此可知《小池》诗当作于当年春节之后。《小池》诗其前第一、二个诗题分别是《夏日绝句》《暮春小雨》，可见这两首诗是创作于是春末夏初。《小池》诗其后第五个诗题是《极暑题钓雪舟》，表明当年极热之日作者仍在吉水“钓雪舟”书斋居住。吉水乃至江西、湖南境内，荷花首次开花的时间是农历五月初，依据《小池》诗中的“树阴”“小荷”“尖尖角”等词汇，由此可以推论，此诗的创作时间应是淳熙三年（1176）五月初。其创作地点在吉水县境内，题中的“小池”当指杨万里故居“父子侯第”正前方的大水塘。 参考文献 小池 《西江月 ·夜行黄沙道中》辛弃疾·宋 明月别枝惊鹊，清风半夜鸣蝉。稻花香里说丰年，听取蛙声一片。七八个星天外，两三点雨山前。旧时茅店社林边，路转溪桥忽见。（溪桥一作：溪头） 译文及注释 译文皎洁的月光从树枝间掠过，惊飞了枝头喜鹊，清凉的晚风吹来仿佛听见了远处的蝉叫声。田里稻花飘香，蛙声阵阵，似乎在告诉人们今年是一个丰收年。天边几颗星星忽明忽暗，山前下起了淅淅沥沥的小雨。往日的小茅草屋还在土地庙的树林旁，道路转过溪水的源头，它便忽然出现在眼前。 注释西江月：词牌名。黄沙：黄沙岭，在江西上饶的西面。别枝惊鹊：惊动喜鹊飞离树枝。鸣蝉：蝉叫声。旧时：往日。茅店：茅草盖的乡村客店。社林：土地庙附近的树林。社，土地神庙。古时，村有社树，为祀神处，故曰社林。见：同“现”，显现，出现。 赏析 从《西江月》前两句“明月别枝惊鹊，清风半夜鸣蝉”表面看来，写的是风、月、蝉、鹊这些极其平常的景物，然而经过作者巧妙的组合，结果平常中就显得不平常了。鹊儿的惊飞不定，不是盘旋在一般树头，而是飞绕在横斜突兀的枝干之上。因为月光明亮，所以鹊儿被惊醒了；而鹊儿惊飞，自然也就会引起“别枝”摇曳。同时，知了的鸣叫声也是有其一定时间的。夜间的鸣叫声不同于烈日炎炎下的嘶鸣，而当凉风徐徐吹拂时，往往特别感到清幽。总之，“惊鹊”和“鸣蝉”两句动中寓静，把半夜“清风”、“明月”下的景色描绘得令人悠然神往。 接下来“稻花香里说丰年，听取蛙声一片。”把人们的关注点从长空转移到田野，表现了词人不仅为夜间黄沙道上的柔和情趣所浸润，更关心扑面而来的漫村遍野的稻花香，又由稻花香而联想到即将到来的丰年景象。此时此地，词人与人民同呼吸的欢乐，尽在言表。稻花飘香的“香”，固然是描绘稻花盛开，也是表达词人心头的甜蜜之感。在词人的感觉里，俨然听到群蛙在稻田中齐声喧嚷，争说丰年。先出“说”的内容，再补“声”的来源。以蛙声说丰年，是词人的创造。 前四句就是单纯的抒写当时夏夜山道的景物和词人的感受，然而其核心却是洋溢着丰收年景的夏夜。因此，与其说这是夏景，还不如说是眼前夏景将给人们带来的幸福。 下阕开头，词人就树立了一座峭拔挺峻的奇峰，运用对仗手法，以加强稳定的音势。“七八个星天外，两三点雨山前”，在这里，“星”是寥落的疏星，“雨”是轻微的阵雨，这些都是为了与上阕的清幽夜色、恬静气氛和朴野成趣的乡土气息相吻合。特别是一个“天外”一个“山前”，本来是遥远而不可捉摸的，可是笔锋一转，小桥一过，乡村林边茅店的影子却意想不到地展现在人们的眼前。词人对黄沙道上的路径尽管很熟，可总因为醉心于倾诉丰年在望之乐的一片蛙声中，竟忘却了越过“天外”，迈过“山前”，连早已临近的那个社庙旁树林边的茅店，也都没有察觉。前文“路转”，后文“忽见”，既衬出了词人骤然间看出了分明临近旧屋的欢欣，又表达了他由于沉浸在稻花香中以至忘了道途远近的怡然自得的入迷程度，相得益彰，体现了作者深厚的艺术功底，令人玩味无穷。 从表面上看，这首词的题材内容不过是一些看来极其平凡的景物，语言没有任何雕饰，没有用一个典故，层次安排也完全是平平淡淡。然而，正是在看似平淡之中，却有着词人潜心的构思，淳厚的感情。在这里，读者也可以领略到稼轩词于雄浑豪迈之外的另一种境界。 创作背景 公元 1181 年（宋孝宗淳熙八年），辛弃疾因受奸臣排挤，被免罢官，回到上饶带湖家居，并在此生活了近十五年。在此期间，他虽也有过短暂的出仕经历，但以在上饶居住为多，在此留下了不少词作。这首词即是其中年时代经过江西上饶黄沙岭道时写的一首词。 参考文献 西江月·夜行黄沙道中 《蝉》虞世南虞世南 垂緌（ruí）饮清露，流响出疏桐。居高声自远，非是藉秋风。 注释垂緌（ruí）：古人结在颔下的帽缨下垂部分，蝉的头部伸出的触须，形状与其有些相似。清露：纯净的露水。古人以为蝉是喝露水生活的，其实是刺吸植物的汁液。流响：指连续不断的蝉鸣声。疏：开阔、稀疏。藉：凭借。 《舟夜书所见》查慎行·清代 月黑见渔灯，孤光一点萤。微微风簇浪，散作满河星。 译文漆黑无月的夜里，孤零零的一盏渔灯像萤火虫一样闪现在河面。一阵微风吹来，河面漾起了层层细浪，水面上的光点随着波浪散开，如同满河星光。 注释孤光：孤零零的灯光。簇：聚集。 《赋得古草原送别》白居易·唐代 离离原上草，一岁不枯荣。野火烧不尽，春风吹又生。远芳侵古道，晴翠按荒城。又送王孙去，萋萋满别情。 《绝句》杜甫·唐代 两个黄鹂鸣翠柳，一行白鹭上青天。窗寒西岭千秋雪，门泊东吴万里船。 译文两只黄鹂在翠绿的柳树间鸣叫，一行白鹭直冲向蔚蓝的天空。坐在窗前可以看见西岭千年不化的积雪，门前停泊着自万里外的东吴远行而来的船只。 注释西岭：西岭雪山。千秋雪：指西岭雪山上千年不化的积雪。泊：停泊。东吴：古时候吴国的领地，江苏省一带。万里船：不远万里开来的船只。 《江雪》柳宗元·唐代 千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。 译文所有山上飞鸟的身影已经绝迹，所有道路都不见人的踪迹。江面孤舟上，一位披戴着蓑笠的老翁，独自在漫天风雪中垂钓。 注释绝：无，没有。万径：虚指，指千万条路。人踪：人的脚印。孤：孤零零。蓑笠（suō lì）：蓑衣和斗笠 笠：用竹篾编成的帽子。独：独自。 《小儿垂钓》胡令能·唐代 蓬头稚子学垂纶，侧坐莓苔草映身。路人借问遥招手，怕得鱼惊不应人。 译文一个头发蓬乱的小孩在河边学钓鱼，侧身坐在莓苔上绿草遮映着他的身影。听到有过路的人问路远远地摆了摆手，不敢回应路人生怕惊动了鱼儿。 注释蓬头：形容小孩可爱。稚子：年龄小的、懵懂的孩子。垂纶：钓鱼。纶：钓鱼用的丝线。莓：一种野草。苔：苔藓植物。映：遮映。借问：向人打听。鱼惊：鱼儿受到惊吓。应：回应，答应，理睬。 《梅花》王安石·宋代 墙角数枝梅，淩寒独自开。遥知不是雪，为有暗香来。 译文墙角有几枝梅花，正冒着严寒独自盛开。远远的就知道洁白的梅花不是雪，因为有梅花的幽香传来。 注释凌寒：冒着严寒。遥：远远地。知：知道。为（wèi）：因为。暗香：指梅花的幽香。 《望庐山瀑布》李白·唐代 日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。 译文及注释 译文香炉峰在阳光的照射下生起紫色烟霞，从远处看去瀑布好似白色绢绸悬挂山前。高崖上飞腾直落的瀑布好像有几千尺，让人怀疑是银河从天上泻落到人间。 注释香炉：指香炉峰。紫烟：指日光透过云雾，远望如紫色的烟云。遥看：从远处看。挂：悬挂。前川：一作“长川”。川：河流，这里指瀑布。直：笔直。三千尺：形容山高。这里是夸张的说法，不是实指。疑：怀疑。银河：古人指银河系构成的带状星群。九天：开的最高处，形容极高。一作“半天”。 《画鸡》唐寅·明代 头上红冠不用裁，满身雪白走将来。（裁一作：戴）平生不敢轻言语，一叫千门万户开。 译文鸡头上的红色冠子不用裁剪，因为是天生的，它身披雪白的羽毛雄赳赳地走来。它的一生从来不敢轻易鸣叫，但是它叫的时候，千家万户的门都会打开。 注释裁：裁剪，这里是制作的意思。将：助词，用在动词和来、去等表示趋向的补语之间。平生：平素，平常。轻：随便，轻易。言语：这里指啼鸣，喻指说话，发表意见。一：一旦。千门万户：指众多的人家。 《寻者不遇》贾岛·唐代 松下问童子，言师采药去。只在此山中，云深不知处。 译文松树下询问隐者的弟子，他说他的师傅已经去往山中采药。只知道就在这座大山里，可山中云雾缭绕不知道他所在的具体地方。 注释寻：寻访。隐者：隐士，隐居在山林中的人。古代指不肯做官而隐居在山野之间的人。一般指的是贤士。不遇：没有遇到，没有见到。童子：没有成年的人，小孩。在这里是指“隐者”的弟子、学生。言：回答，说。云深：指山上云雾缭绕。处：行踪，所在。 《赠汪集伦》李白·唐代 李白乘舟将欲行，忽闻岸上踏歌声。桃花潭水深千尺，不及汪伦送我情。 《春晓》孟浩然·唐代 春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少。 《池上》白居易·唐代 小娃撑小艇，偷采白莲回。不解藏踪迹，浮萍一道开。 译文小孩子撑着小船，偷偷地从池塘里采了白莲回来。他不懂得掩藏自己的行踪，水面上的浮萍被小船划开，留下了一条长长的痕迹。 注释小娃：指小孩子。艇：船。白莲：白色的莲花。踪迹：指被小艇划开的浮萍。浮萍：水生植物，椭圆形叶子浮在水面，叶下面有须根，夏季开白花。 《古朗月行》节选李白·唐代 小时不识月，呼作白玉盘。又疑瑶台镜，飞在青云端。 《悯农》李绅·唐代 其一春种一粒粟，秋收万颗子。四海无闲田，农夫犹饿死。 其二锄禾日当午，汗滴禾下土。谁知盘中餐，粒粒皆辛苦？ 《画》王维·唐代 远看山有色，近听水无声。春去花还在，人来鸟不惊。 译文远看高山色彩明亮，走到近处却听不到流水的声音。春天过去了花仍在争奇斗艳，人走近了鸟却没有被惊动。 注释色：颜色，也有景色之意。惊：吃惊，害怕。 《江南》汉乐府 两汉 江南可采莲，莲叶何田田。鱼戏莲叶间。鱼戏莲叶东，鱼戏莲叶西，鱼戏莲叶南，鱼戏莲叶北。 译文江南又到了适宜采莲的季节了，莲叶浮出水面，挨挨挤挤，重重叠叠，迎风招展。在茂密如盖的荷叶下面，欢快的鱼儿在不停的嬉戏玩耍。一会儿在这儿，一会儿又忽然游到了那儿，说不清究竟是在东边，还是在西边，还是在南边，还是在北边。 《赠刘景文》苏轼·宋 荷尽已无擎雨盖，菊残犹有傲霜枝。一年好景君须记，最是橙黄橘绿时。（最是，一作：正是） 《山行》杜牧·唐 远上寒山石径斜，白云生处有人家。（生处，一作：深处）停车坐爱枫林晚，霜叶红于二月花。 《司马光》佚名·宋 群儿戏于庭，一儿登瓮，足跌没水中。众皆弃去，光持石击瓮破之，水迸，儿得活。 《望洞庭》刘禹锡·唐 湖光秋月两相和，潭面无风镜未磨。遥望洞庭山水翠，白银盘里一青螺。（山水翠，一作：山水色） 《饮湖上初晴后雨二首》苏轼·宋 其二：水光潋滟晴方好，山色空蒙雨亦奇。欲把西湖比西子，淡妆浓抹总相宜。 《望天门山》李白·唐 天门中断楚江开，碧水东来至此回。两青山相对出，孤帆一片日边来。 《夜书所见》叶绍翁·宋 萧萧梧叶送寒声，江上秋风动客情。知有儿童挑促织，夜深篱落一灯明。 《九月九日忆山东兄弟》王维·唐代 独在异乡为异客，每逢佳节倍思亲。遥知兄弟登高处，遍插茱萸少一人。 《元日》王安石·宋代 爆竹声中一岁除，春风送䁔入屠苏。千门万户曈曈日，总把新桃换旧符。 《三衢道中》曾几·宋代 梅子黄时日日晴，小溪泛尽却山行。绿阴不减来时路，添得黄鹂四五声。 《采莲曲》王昌龄·唐代 荷花罗裙一色裁，芙蓉向脸两边开。乱入池中看不见，闻歌始觉有人来。 《所见》袁枚·清 牧童骑黄牛，歌声振林樾。意欲捕鸣蝉，忽然闭口立。 《暮江吟》白居易·唐代 一道残阳辅水中，半江瑟瑟半江红。可怜九月初三夜，露似真珠月似弓。 注释：暮：黄昏。江：指长江。一说指长安城东南的胜景曲江池。吟：古代诗歌的一种形式。 《行香子·述怀》苏轼·宋代 清夜无尘，月色如银。酒斟时、须满十分。浮名浮利，虚苦劳神。汉隙中驹，石中火，梦中身。虽抱文章，开口谁亲。且陶陶、乐尽天真。几时归去，作个闲人。对一张琴，一壶酒，一溪云。 《过零丁洋》文天祥·宋代 辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。惶恐滩头说惶恐，零丁洋里汉零丁。人生自古谁无死？留取丹心照汗青。 《望岳》杜甫·唐代 岱宗夫如何？齐鲁青未了。造化钟神秀，阴阳割昏晓。荡胸生层云，决眦入归鸟。会当凌绝顶，一览众山小。 《茅屋为秋风所破歌》杜甫·唐代 八月秋高风怒号，卷我屋上三重茅。茅飞渡江洒江郊，高者挂罥（juàn）长林梢，下者飘转沉塘坳。南村群童欺我老无力，忍能对面为盗贼。公然抱茅入竹去，唇焦口燥呼不得，归来倚仗自叹息。俄顷风定云墨色，秋天漠漠向昏黑。布衾多年冷似铁，娇儿恶卧踏里裂。床头屋漏无干处，雨脚如麻未断绝。自经丧乱少睡眠，长夜沾湿何由彻！安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。呜乎！何时眼前突兀见此屋，吾庐独破受冻死亦足！ 注释：罥（juàn）：悬挂；缠绕。 《行路难》李白·唐代 其一 金樽清酒斗十千，玉盘珍馐值万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海。 《满江红·写怀》岳飞·宋代 怒发冲冠，凭栏处、潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！ 靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山缺。壮志饥餐胡虏肉，笑谈渴饮匈奴血。待从头、收拾旧山河，朝天阙。 注释： 栏，通：阑。 壮志，一作：壮士。 山缺，一作：山阙。 《送东阳马生序》宋濂·明代 余幼时即嗜学。家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。录毕，走送之，不敢稍逾约。以是人多以书假余，余因得遍观群书。既加冠，益慕圣贤之道。又患无硕师名人与游，尝趋百里外，从乡之先达执经叩问。先达德隆望尊，门人弟子填其室，未尝稍降辞色。余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。 当余之从师也，负箧曳屣行深山巨谷中。穷冬烈风，大雪深数尺，足肤皲裂而不知。至舍，四支僵劲不能动，媵人持汤活灌，以衾拥覆，久而乃和。寓逆旅，主人日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则缊袍敝衣处其间，略无慕艳意，以中有足乐者，不知口休之奉不若人也。盖余之勤且艰若此。今虽耄老，未有所成，犹幸预君子之列，而承天子之宠光，缀公卿之后，日侍坐备顾问，四海亦谬称其氏名，况才之过于余者乎？ 今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵读书，无奔走之劳矣；有司业、博士为之师，未有问而不告、求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。其业有不精、德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！ 东阳马生君则，在太学已二年，流辈甚称其贤。余朝京师，生以乡人子谒余，撰长书以为贽，辞甚畅达。与之论辨，言和而色夷。自谓少时用心于学甚劳，是可谓善学者矣。其将归见其亲也，余故道为学之难以告之。谓余勉乡人以学者，余之志也；诋我夸际遇之盛而骄乡人者，岂知予者哉！ 注释： 箧（qiè）：小箱子。 曳（yè）：拖拉；牵引。 媵（yìng）：1.陪送出嫁。2.陪嫁的人。3.妾。 诋（dǐ）：1.责骂；毁谤。 《劝学诗》朱熹·宋代 少年易老学难成，一寸光阴不可轻。未觉池塘春草梦，阶前梧叶已秋声。 译文及注释 译文青春的日子十分容易逝去，学问却很难获得成功，所以每一寸光阴都不能轻易放过。还没从美丽的春色中一梦醒来，台阶前的梧桐树叶就已经在秋风里沙沙作响了。 注释学：学问，学业、事业。一寸光阴：日影移动一寸的时间，形容时间短暂。轻：轻视，轻松放过。未觉：没有觉醒；未感觉到。池塘春草梦：东晋诗人谢灵运《登池上楼》中有“池塘生春草，园柳变鸣禽”，是歌咏南国早春的句子。阶：台阶。梧：梧桐，落叶乔木。 临安春雨初霁陆游·宋代 世味年来薄似纱，谁令骑马客京华。小楼一夜听春雨，深巷明朝卖杏花。矮纸斜行闲作草，晴窗细乳戏分茶。素衣莫起风尘叹，犹及清明可到家。 己亥杂诗龚自珍·清代 忽有故人心上过，回首山河已是秋。两处相思同淋雪，此生也算共白头。 Mountains and rivers in poems 将进酒（李白·唐）君不见黄河之水天上来，奔流到海不复回。君不见高堂明镜悲白发，朝如青丝暮成雪。人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。烹羊宰牛且为乐，会须一饮三百杯。岑夫子，丹丘生。将进酒，杯莫停。与君歌一曲，请君为我倾耳听。钟鼓馔玉不足贵，但愿长醉不愿醒。古来圣贤皆寂寞，惟有饮者留其名。陈王昔时宴平乐，斗酒十千恣欢谑。主人何为言少钱？径须沽取对君酌。五花马，千金裘。呼儿将出换美酒，与尔同销万古悉。 前赤壁赋（苏轼·宋）壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间，白露横江，水光接天，纵一苇之所如，凌万顷之茫然。浩浩乎如凭虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 於是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空眀兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之，其声呜呜然，如怨、如慕、如泣、如诉，馀音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐，而问客曰：“何为其然也？” 客曰：“‘月眀星稀，乌鹊南飞’，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，鬱乎苍苍，此非孟德之困於周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵於江渚之上，侣鱼蝦而友麋鹿；驾一叶之扁舟，举匏樽以相属。寄蜉蝣於天地，渺浮海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨遊，抱眀月而长终。知不可乎骤得，托遗响於悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未嘗往也；盈虚者如彼，而卒莫消长也，盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物與我皆无尽也，而又何羡乎？且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之眀月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盤狼籍，相与枕藉乎舟中，不知东方之既白。 轼去岁作此赋，未尝轻出以示人，见者盖一二人而已。 钦之有使至求近文，遂亲书以寄。多难畏事。 钦之爱我，必深藏之不出也。又有后赤壁赋，笔倦未能写，当俟后信。轼白。 琵琶行 〈并序〉 （白居易·唐） 元和十年，予左迁九江郡司马。明年秋，送客湓浦口，闻船中夜弹琵琶者，听其音铮铮然，有京都声。问其人，本长安倡女，尝学琵琶于穆、曹二善才，年长色衰，委身为贾人妇。遂命酒使快弹数曲，曲罢悯默，自叙少小时欢乐事，今漂沦憔悴，转徙于江湖间。予出官二年，恬然自安；感斯人言，是夕始觉有迁谪意，因为长句，歌以赠之，凡六百一十六言，命曰《琵琶行》。 浔阳江头夜送客，枫叶荻花秋瑟瑟。主人下马客在船，举酒欲饮无管弦。醉不成欢惨将别，别时茫茫江浸月。忽闻水上琵琶声，主人忘归客不发。寻声暗问弹者谁，琵琶声停欲语迟。移船相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱琵琶半遮面。转轴拨弦三两声，未成曲调先有情。弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢撚抹复挑，初为霓裳后六幺。大弦嘈嘈如急雨，小弦切切如私语。嘈嘈切切错杂弹，大珠小珠落玉盘。间关莺语花底滑，幽咽泉流水下滩。水泉冷涩弦凝绝，凝绝不通声暂歇。别有幽愁暗恨生，此时无声胜有声。银瓶乍破水浆迸，铁骑突出刀枪鸣。曲终收拨当心画，四弦一声如裂帛。东船西舫悄无言，唯见江心秋月白。沉吟放拨插弦中，整顿衣裳起敛容。自言本是京城女，家在虾蟆陵下住。十三学得琵琶成，名属教坊第一部。曲罢曾教善才服，妆成每被秋娘妒。五陵年少争缠头，一曲红绡不知数。钿头银篦击节碎，血色罗裙翻酒污。今年欢笑复明年，秋月春风等闲度。弟走从军阿姨死，暮去朝来颜色故。门前冷落车马稀，老大嫁作商人妇。商人重利轻别离，前月浮梁买茶去。去来江口守空船，绕船月明江水寒。夜深忽梦少年事，梦啼妆泪红阑干。我闻琵琶已叹息，又闻此语重唧唧。同是天涯沦落人，相逢何必曾相识。我从去年辞帝京，谪居卧病浔阳城。浔阳地僻无音乐，终岁不闻丝竹声。住近湓江地低湿，黄芦苦竹绕宅生。其间旦暮闻何物，杜鹃啼血猿哀鸣。春江花朝秋月夜，往往取酒还独倾。岂无山歌与村笛，呕哑嘲哳难为听。今夜闻君琵琶语，如听仙乐耳暂明。莫辞更坐弹一曲，为君翻作《琵琶行》。感我此言良久立，却坐促弦弦转急。凄凄不似向前声，满座重闻皆掩泣。座中泣下谁最多？江州司马青衫湿。 岳阳楼记 （范仲淹·北宋）庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上；属予作文以记之。 予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千；此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？ 若夫霪雨霏霏，连月不开；阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。 至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极。登斯楼也，则有心旷神怡，宠辱皆忘，把酒临风，其喜洋洋者矣。 嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲。居庙堂之高，则忧其民；处江湖之远，则忧其君。是进亦忧，退亦忧；然则何时而乐耶？其必曰：“先天下之忧而忧，后天下之乐而乐”欤！噫！微斯人，吾谁与归？ 时六年九月十五日。 诫子书诸葛亮·两汉 夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！ 诗歌励志秋天","categories":[{"name":"诗词歌赋","slug":"诗词歌赋","permalink":"https://liangyuanzheng.com/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"诗词","slug":"诗词","permalink":"https://liangyuanzheng.com/tags/%E8%AF%97%E8%AF%8D/"},{"name":"古文","slug":"古文","permalink":"https://liangyuanzheng.com/tags/%E5%8F%A4%E6%96%87/"},{"name":"诗歌","slug":"诗歌","permalink":"https://liangyuanzheng.com/tags/%E8%AF%97%E6%AD%8C/"}]},{"title":"跟大师学语文-文章作法","slug":"跟大师学语文-文章作法","date":"2024-08-22T11:50:00.000Z","updated":"2025-10-27T00:35:41.797Z","comments":true,"path":"跟大师学语文-文章作法.html","link":"","permalink":"https://liangyuanzheng.com/%E8%B7%9F%E5%A4%A7%E5%B8%88%E5%AD%A6%E8%AF%AD%E6%96%87-%E6%96%87%E7%AB%A0%E4%BD%9C%E6%B3%95.html","excerpt":"","text":"时间 备注 2024-08-22 第一次阅读。一本指导如何写作的好书。 2024-10-13 阅读完。 笔记读《跟大师学语文-文章作法》 书中共收录了语文教育大师夏丏尊、叶圣陶先生的五本关于语文学习的指导性名著。 身处一个持续学习持续输出的时代，平时少不了总结一些知识点。刚开始写时，怎么也总结不好。要么写几行草草了事，要么长篇大论不知所云，抑或东拼西凑杂乱无章。 冥冥之中自有天意，我遇到了《跟大师学语文-文章作法》。 好文章如何作法？道亦有道，写作也是有方法的。文章有内容和形式两方面。所谓好文章，就是达意表情。 书中提到，写作最为要紧的两个基本条件：真实、明确。（1）真实： 文章是传达自己意思和情感给别人的东西。（2）明确： 文章要能使读的人了解，才算达到了作文的目的，所以难解及容易误解的文章，都不能算是好的。 理解了这些，你会突然明白。原来写作如此简单，把你想表达的讲明白，读者能理解清楚，这样的就是好文章。从此，不必再因文章太短而去凑字数，因为事儿就那么简单；也不再因长篇大论而强行删减，因为几句话讲不明白这么多道理。 正如书中所说：法则没用而有用，就在这一点，作文法的真价值，也就在这一点。 书中详细讲述了各类文体的特点、写法，还有很多的案例。注意，书中的内容很多是当年的教案整理而来，因此不仅对于我们的写作有指导性作用，对于学生写作的意义更大，也可能更有用。 绝非标题党，是真大师。 “跟大师学语文”丛书出版说明这套丛书此次共收录了《文章作法》、《文话七十二讲》、《文章讲话》、《怎样写作》和《语文随笔》五本关于语文学习的指导性名著。它们的作者就是著名的语文教育大师夏丏尊、叶圣陶先生。这就是丛书名的由来。 法则没用而有用，就在这一点，作文法的真价值，也就在这一点。 第一章 作者就有的态度文章有内容和形式两方面。所谓好文章，就是达意表情。 怎样作法，最要紧的基本条件有两个：真实、明确。（1）真实文章是传达自己意思和情感给别人的东西。“情者，文之经；辞者，理之纬；经正而后纬成，理定而后辞畅；此立文之本也。” （2）明确文章要能使读的人了解，才算达到了作文的目的，所以难解及容易误解的文章，都不能算是好的。 要注意的点： 勿模仿、勿剿袭 须自己造辞，勿漫用成语或典故 注意符号和分段 [!PDF|yellow] 跟大师学语文-文章作法, p.15 为了使文章的头绪清楚，应当把关于各个小的中心思想的文字作成一段；换句话说，就是一个小的中心思想应当作一段，而一段中也只应当有一个小的中心思想。文章的内容若十分复杂，一段里面还可分成几小段。分段的标准或依空间的位置，或依时间的顺序，或依事理自然的秩序，全看文章的内容怎样。至于每段的长短，这是全无关系的。 用字上的注意 第二章 记事文第一节 记事文的意义将人和物的状态、性质、效用等，依照作者所目见、耳闻或想象的情形记述的文字，称为记事文。 第一节 记事文的第一步记事文以记述经验为目的 要作记事文先须经验事物，或目见，或耳闻，或参考书籍，从各方面收集材料，更将所得材料按适当的次序排列起来。 [!PDF|yellow] 跟大师学语文-文章作法, p.19 在初学的人，没有腹案的功夫的，并须将各材料一一地用短文记出。 第三节 材料的取舍和整理选择材料的标准：一是适切题目，二是注重特色。 材料取舍完了，其次便是整理。凡是同类的材料，务必集合在一处，将冗繁支离的删去。 (跟大师学语文-文章作法, p.21)西湖 第四节 记事文的顺序记事文的顺序大概有两种，一以观察的顺序为标准，一以事物本身的关系为标准。 作复杂的记事文，先须注目于关系事物全体的材料，然后顺次及于各部分；各部分的材料中，又是先列大的，后列小的。 (跟大师学语文-文章作法, p.22)现在参考书籍，作《鸽》的记事文 (跟大师学语文-文章作法, p.23)这文的顺序画出图来，恰如下所示。凡事所记的事物非一见一闻就能明了，要从书籍上查考它的效用、构造历史……的，都应该用这个方法来记述。 第五节 文学的记事文 (跟大师学语文-文章作法, p.26)例如以《月》为题，就有下面的两种作法：（一）月是星体中最和人相近的。在天空中一面绕着地球转动，同时随了地球绕太阳而行。它和地球一样，还有自转。它的自转和绕着地球转动，都大约是二十七日又零一周，所以地球上的人只能和它的大部份相见。月上也有山，山岭最高的约二万六千尺至一万七千尺；如阿奔那尼（Apennines）一山，壁立雄峻的奇峰竟有三千多个。它的本体原是黑暗的，只是反射太阳的光以为光。太阳照着的部份全向地球的时候，看去很圆，这叫做“望”。太阳不照着的全黑的部份向着地球的时候，叫做“晦”。太阳照着的和没有照着的各有一部份向着地球的时候，叫做“弦”。（二）窗外好像水国，近的屋，远的山，都用不很明白的轮廓，画在空中。屋角树林的下面，晕着神秘的色光。熄灯以后，月光闯入室内，在床上铺着一条青黄色的光带。夜静了，不知哪里来的呜咽幽扬的笛声，还隐约地在枕上听得。上面的第一篇，读了虽然可以得到关于月的状态和性质的知识，却不能感到月色的美感和月夜的情趣；这便是科学的记事文。第二篇，却恰好相反，只能给读者以月色的美感和月夜的情趣，至于月的性质和状态，却一点不曾写到；这是文学的记事文。 特别注意下列各项：（1）想象（2）注意特色（3）杼述心情要作好的文字，非对于事物有锐敏的感觉不可。（4）使用含着动作的词句凡要表示事物，必须在事物有动作的时候，不可在它静止的时候。 第三章 叙事文第一节 叙事文的意义记述人和物的动作、变化、或事实的推移的现象的文字，称为叙事文。 (跟大师学语文-文章作法, p.30)宝钗与黛玉回至园中。宝钗因约黛玉往藕香榭去，黛玉因说还要洗澡，便各自散了。 叙事文原和记事文一样，同是记述事物的文字；不过记事文以记述事物的状态、性质、效用为主；而叙事文以记述事物的动作、变化为主。所以记事文是静的，空间的；叙事文是动的，时间的。 (跟大师学语文-文章作法, p.30)（一）牵牛花有红的，紫的，颜色虽很美观，但少实用。这是述说牵牛花的形状和性质的，是记事文。（二）院里的牵牛花，红的，紫的，都很鲜艳地开了。这是述说牵牛花的变化的，是叙事文。 第二节 记事文和叙事文的混合文体的分类原只是为说明便利和作者自身态度不同，实际上并没有纯粹属于某种体裁的文字，记事文和叙事文虽因所记述的对象不同而有区别，在一篇关于事物的记述的文字中，总是相互混杂的。 第三节 叙事文的要素叙事文既是记述现象的，所以也有四个要素：（一）现象的主体，（二）现象的演变，（三）现象发生的时间，（四）现象发生的场所。 第四节 叙事文的主想材料选择的标准：除适切题目和注意特色以外，还因文目的而定。这个目的在叙事文中就是主想，大体有三类：（一）以授与教训为主。例如传记等。（二）以授与知识为主。例如历史等。（三）以授与趣味为主。例如小说等。总括一句，第一类以善为主，第二类以真为主，第三类以美为主。 但有一点需要注意，就是同一材料应当取舍不是材料本身的重要与否的问题，而是与主想的关系重要与否的问题。 第五节 叙事的观察点叙事文所叙述的材料，不但是从作者自己经验得来，还有从别人的传说或书籍的记载得来的。 叙事文的观察点，就是作者所站的地位，可分为三种：（一）居于发动者一边（二）居于受动者一边（三）居于旁观者一边作叙事文须确定一种的观察点，全篇统一，不应摇动。通常的叙事文，以居于旁观者的地位的居多。 亦非绝对，参考《观察点的变动》 叙事文因观察点不同，对于同一材料，可作成各方面的文字。这步功夫，在学作叙事文上很重要。有这样功夫的作者，对于一件事就能理解要从哪方面叙述才省事。 第六节 观察点的变动照前节所说，叙事文的观察点不应变更，使文气一致而不散漫、冗繁。但这只是一般的原则，在长篇的或复杂的叙事文，要将各方面的情形都表现得适当，却不得不变动。 叙述一件事，哪几方面的关系重要，以及哪些应当表现，哪些不应当表现，全依靠事件的性质，由作者自己的意见去判断，没有一个简明的标准。 第七节 叙事文的流动叙事文的对象是事物的现象的展开，这展开的情形被叙述成文字的时候，就成了文字上的流动。现象的展开不止，文字的流动也就仍然继续，所以流动是叙事文的特色。 快的叙事文，以叙述事件的轮廓为目的； 慢的叙事文，以叙述事件的情况为目的。 第八节 叙事文流动的中止叙事文的特色既然在流动，所以不但这流动须快慢适当，还须慎防中止。所谓流动中止，就是由时间的、动的叙事文，突然转到冗长的、空间的、静的记事文；或插入说明，使动态一时停滞。 第九节 叙事文流动的顺逆叙事文是把事物的变化来展开的，所以流动的方向也有两种：第一种，照那变化自然的顺序，依次叙述，这是顺的；第二种，因为要叙明变化的前因后果，或并行的事件，不能全然依照自然的顺序而要有所颠倒，这是逆的。 第四章 说明文第一节 说明文的意义解说事物，剖释事理，阐明意象；以便使人得到关于事、事理或意象的知识的文字，称为说明文。 说明文和科学的记事文最重要的区别：对象的范围不同。科学的记事文比较具体；说明文比较抽象。 第二节 说明文的用途和题式说明文本来是用较浅近明了易于理解的文字去解明事物或事理，使它的关系明了，范围确定，意义清晰，给人以关于该事物或事理的普遍的正确的知识，所以用途很广。 说明文题式通常有疑问式和直述式两种。 第三节 说明文的条件说明文最简单的形式，就是单语的定义：复杂的说明文，无非是单语的定义的集合和它们的引申。 要想使人明了，说明文作法的条件须加多：（一）所属的种类（二）所具的特色（三）所含的种类（四）显明的实例（五）对称和疑似（六）语义的限定 [!PDF|yellow] 跟大师学语文-文章作法, p.51 上述各项，是说明作文法上的要件，现在以“文学”为题应用各要件，示范如下：文学是一种艺术（一），换句话说，就是以文字做成的艺术（二）。纯粹的文学通常不以日用为目的（五），因体裁上有小说，诗歌，戏曲等分别（三）。《红楼梦》是小说，《长恨歌》是诗歌，《西厢记》是戏曲（四）。文学不是普通的文字，也不是科学（六）。韩愈的《原道》，王船山的《读通鉴论》等，不是文学，物理学讲义，化学教科书等，也不是文学（四）。我国古来，凡是文字都称文学，但是现在的所谓文学完全是小说，诗歌，戏曲的总称，和从前的意义是不同的（六）。 第四节 条件的省略说明文原是为未知事物的人作的。但遇某部分确已非常明了的时候，也可以省略。（1）普通的省略：容易明了而不至误解的事物，或只以使人知道一个概要的，都可以只说大概。（2）因比较而省略的：利用读者所已知的事物，两相比较以说明的时候，和已知事物相同的条件，就可省略，这是常用的省略法。 第五章 议论文第一节 议论文的意义发挥自己的主张，批评别人的意见，以使人承认自己的目的文字，称为议论文。 与说明文的区别： 第一是目的不同。说明文的目的是在使别人有所知，议论文不但要使人有所知，还要有所信。 第二性质不同。试就两者的题式看就可明了。说明文大概用单语为题。论论文的题目原是文章的根本主张的概括的缩写，所以表面虽是单语，内容依然是命题。 第三是态度不同。说明文偏客观，议论文恰好相反。 第二节 命题断定用言语或文字表示出来称为命题。 作议论文的第一步，就是认定自己所要提出的命题。命题确定了，然后加以证明。所要注意的就是保持论点，不要变更，使议论出了本命题范围以外。 第三节 证明命题既经认定，就应当加以证明，证明可分两种。（一）直接证明。即是对于一种主张，找出积极的理由来证明。（二）间接证明。就是所谓反证，对于一种主张，先证明对方面的谬误，使自己所说的牢固。大概，发表自己的主张，不能不有直接的证明；反驳他人的议论，间接证明最有用。 第四节 演绎法、归纳法和类推法演绎法、归纳法和类推法，是论证的基本方法。要知道详细，须求之于论理学。 （一）演绎法。用含义比较广括的命题做基础，来论证含义较狭的命题，这是演绎法。演绎法最基本的形式，通常称为三段论（大前提、小前提、断案）。 演绎法的议论，全以两前提做基础，所以如前提中有一个不稳固，全论就不免谬误。 繁复的议论文大概就是由许多三段论法联合而成的。 （二）归纳法。归纳法和演绎法恰好相反，是集合部份而论证全体的论法。 归纳法中应遵守的两个条件： 部份事件的集合须普遍而且没有反例； 有明确的因果关系。这两个条件如果能满足一个，大概可以认为没有错误。最有力的归纳法，是第一、第二两个条件都能满足的。 （三）类推法。根据已知的事例而推断出相类的事例的方法，这是类推法。 类推法就遵守的两个条件： 所举的类似点，须是事物的固有性，而不是偶有性； 被推的事物须不含有与断案矛盾的性质。 第五节 证据的性质分类判断一件事，总是以经验做根据，而依前两节所举的方法找出证据来。由性质上，证据有种种的不同： （一）因果论。以原因证明结果。 （二）例证论。将和结论相同的事例来做议论的证据。例证论以部分来推全体，或以甲部分来推乙部分。 （三）譬喻论。譬喻论和例证论相似，不过例证论是引用和结论相同的事例做证据，譬喻论是引用和结论相似的事例做证据。譬喻论中所要紧的，就是两方面的类似的关系。 （四）符号论。符号论和因果论恰相反，因果论是从原因推证结果，符号论是从结果推证原因。 第六节 各种议论的联络两种或多种议论联结起来，论证会更加可靠。 第七节 议论文的顺序文章原无一定的成法，议论文的顺序当然也不能说有一定。 以下所说的事项，不过是普通的说法： （一）命题的位置 议论文原是对于命题的证明，命题当然是议论文的根本。 在最普通的文章，应当先提出命题，使读者开首就了解全篇的主旨所在。 先列命题，能使文章明晰，却是有时也不应当先将命题列出：第一，命题容易引起反对的时候第二，命题太平凡的时候 （二）证明的顺序 通常因果论应当列在前面，符号论列在最后。 第八节 作驳论的注意议论文以推理为根据。议论原是假定有敌论存在，否则已用不到议论。从这一点说，议论文可以说是广义的驳论了。 一般的驳论： （一）寻求敌论的立脚点 （二）反驳的方法只须检查它违犯哪一种条件。最重要的还是对于这命题的驳击。 （三）应注意的条件第一，勿助长敌论的声势第二，勿曲解敌论第三，驳论的位置。最有力的驳论最好放在中部，后半篇可用强有力的方法发挥自己的主张。 以上所说的各项，并不是想取不正当的胜利，只是用来防不应当有的失败，千万不要误用。文章要动人，非有好人格、好学问做根据不可，仅从方法上着想总是末技。 第六章 小品文第一节 小品文的意义从外形的长短上说，二三百乃至千字以内的短文称为小品文。 小品文的内容性质全然自由，可以叙事，可以议论，可以忬情，可以写景，毫不受何等的限制。 小品文，我国古来早已有了，如东坡小品就很有名；普遍所谓的“随笔”，也可看做小品文的一种。 小品文虽然也有独立制作的，其实多散见于长文中。 第二节 小品文在文章练习上的价值练习小品文，对于作长文也很有帮助，就是可以增长关于作文所需要的各种能力，所以对于文章练习上，利益很多。 （一）可为作长文的准备 （二）能多作文有三多：多读，多作，多商量。小品文内容既自由，材料又随处可得，并且因字数很少，推敲，布局都比较容易，很便于多作，能多作，作文的能力就自然进度了。 （三）能养成观察力要作小品文，无论写情，写景，非注意到眼前事物的小部分，将它的特色生命来捕捉不可。细密而且锐敏的观察力，实在是文人最重要条件之一。 （四）能使文字简洁 （五）能养成作文的兴味 第三节 小品文练习的机会（一）日记大体可别为二种，一是只记述行事的，一是记述内面生活的。在普通人的日记中，两种时时相合，前者重事实方面，后者重心情方面。 作为练习文章计，应当注意这两个方面的的调和；一味抒述内心生活，虽嫌虚空，然帐薄式的事实的排列，也实在没有趣味。因此，最好的日记是于记述事实之中，可以表现心情的作法。 （二）书札 讲到趣味，作书札比作日记多，因为日记是独语，而书札却是对话了。 书札中能兼述生活情趣，就能不呆滞而饶兴味。 这里所应注意的，就是要真实无饰。若专袭套语，徒事修饰，是毫无用处的。只要能表现实生活，就可以使读者引起情趣；若徒把古人或今人的美辞丽句来套袭，就要成呆板讨厌的文字了。 第四节 小品文作法上的注意——着眼细处小品文是记述实生活的一部分的东西，以描写部分为目的。小品文必须注目于事物细处，就极微细极琐碎的部分发现材料。 小品文的材料，与其取有系统的、整个的，不如取偶发的、断片的。 从许多断片的部分的材料中，选出最可寄托情感的一点拿来描写，这是作小品文的秘诀。 第五节 小品文作法上的注意——印象的精细的部分的描写，胜于粗略的全体的叙述和说明。 描写是照了事象把它来从笔端现出意思，和绘画所用的意义相同。说明固然不是描写，叙述也不是描写。 简单点说：描写就是观察的表出，不会观察事物的人是断不能描写的。 从另一方面看，所谓描写的就是“印象的”的意思。描写是照了所观察的事象如实写出，就是要把印象写出。 我国旧式文字中往往以作者自己的态度，强迫读者同感。如叙述一悲事，结尾必用：“呜呼，岂不悲哉！”叙述一乐事，必要带“可谓乐事也已”之类。其实这是强迫读者的无理的态度。悲不悲，乐不乐，读者自会感受，何必谆谆然教诲人家呢？ 大师很幽默啊～ 描写！描写！部分的精细的分写，胜于全体的叙述和说明！再进一步说，要印象的描写！ 第六节 小品文作法上的注意——暗示的不要说明的和叙述的，要描写的，要印象的，暗示的；其实这许多话的根本完全相同。说明和叙述必无馀情，能描写，自然会成印象的，同时也自然是暗示的了。 用了部分去縶全体，才会有馀情。 暗示是小品文的生命，但所谓暗示可分两部分来看：一是笔法的暗示，一是材料的暗示。前者比较容易，后者实在很难。 第七节 小品文作法上的注意——中心所谓中心，就是统一的意思。小品文文字数不多，如果再散漫无统一，必致减少效用，没有可以逼人的能力。 没有中心，文字就要散漫无统一，散漫无统一的文字断不能动人。但所谓中心，不是一定限于事项的统一，事项虽不前后联络，只要情调心情上能统一时，仍不失为有中心的文字。 中心用事项来做，或是用情调来做，是不必限定的。 第八节 小品文作法上的注意——机智小品文如奇兵，平板的笔法断难制胜，非有机智不可。我们观察事物，有正面观察和侧面观察二种。正面观察每多平板，常不及侧面观察来得容易动人。因为正面的部分是大家都知道的，侧面的部分往往为人所不顾及的。能将人所忽略的部分从事观察，文字就容易奇警，而表现也容易成功。 侧面观察就是于事物的普通光景以外，再去找出常人心中所无而实际却有的光景来；这虽有赖于观察力的周到，但基本却在机智的活动。 第九节 实际做例和添削（一）第一步。观察第一要件在真实，观察力若尚未养成，所想象的也难免不合实际。 但是眼前的材料很多，人哪里观察起呢？这本不成问题，所以发生这疑问实由于着手就想创作名文的缘故。 文字的好坏本不在材料的性质，而在表现的技能。善烹调的无论用了怎样平常的原料，也能做出可口的肴馔来。世上森罗万象，一入能文者的笔端就都成了好文章了。 （二）由材料到成文字 写出原是容易，但要将自己所观察得的依样传给别人，使别人也起同样的心情，这却很难；并且不如此，文字就没了意义了。 第十节 分段与选题（一）文的分段。文字的分段和句逗性质一样，同是表示区划的。最小的区划是逗，其次是句，再其次是段。有时还有空一行另写，表示此段更大的区划的。 分段还是使文字易读，且使文字有序不紊。分段有长有短，原视人而不同，但大体也有一定的标准，就是要每段自成一段落。 换一着眼点，就把文字分段，这是普通的标准。 所要注意的就是标准只是相机而定的。 分段还有把分段特别提出的意思，能使分出的文字增加强度。 能适当分段也是文章技巧之一，但须入情合理，不可无谓妄饰。 （二）题的选择。好的文字都是作者先有某种要写的事物或思想情感，如实写出，然后再加题目的。特别地在小品文应该如此。 附录作文的基本态度要使文章能适合读者的心情，技巧的研究原是必要的，态度的注意却比技巧更加要紧。 文章的态度可以分六种来说。我们执笔为文的时候，可以发生六个问题：（1）为什么要作这文？ 要作这文的目的。（2）在这文中所要述的是什么？ 题义，就是文章的中心思想。（3）谁在作这文？ 作者的地位问题，也就是作者与读者的关系问题，再换句话说，就是要问以何种资格向人说话。（4）在什么地方作这文？ 作这文的所在地也有认清的必要、或在乡村、或在都会、或在集体、或在国外，因也地方不同，态度也自须有异。（5）在什么时候作这文？ 这是自己的时代观念，须得认清的。（6）怎样作这文？ 上面的一种态度都认清了，然后再想作文的方法。用普通文体呢，还是用诗歌休？简单好呢，还是详细好？直说呢，还是婉说？开端怎样说？结末怎样说？先说大旨，后说理由呢，还是先说事实，后加断定？怎样才能使我的本旨显明？怎样才能免掉别人的反驳？ 以上六种，我以为是作为时所必须认清的态度，虽然很平凡，却必须知道，把它连接起来，就只是下面的一句话：谁对了谁，为了什么，在什么地方，什么时候，用什么方法，说什么话。 用英语来说，就是 Why？What？Who？Where？When？How？六字可以称为“六 W”。 论记叙文中作者的地位并评现今小说界的文字 End","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"写作","slug":"写作","permalink":"https://liangyuanzheng.com/tags/%E5%86%99%E4%BD%9C/"}]},{"title":"压缩：提速提效","slug":"8-压缩：提速提效","date":"2024-08-22T04:27:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"8-压缩：提速提效.html","link":"","permalink":"https://liangyuanzheng.com/8-%E5%8E%8B%E7%BC%A9%EF%BC%9A%E6%8F%90%E9%80%9F%E6%8F%90%E6%95%88.html","excerpt":"","text":"压缩：提速提效业务场景在数据量稍大些的场景中，传输时间往往占耗时的大头。压缩算法在数据存储、数据传输和用户体验等方面都具有重要的作用，可以提高效率、节省资源和改善用户体验。 案例⓵ 压缩算法在 HTTP 协议中的应用压缩应我们身边。 Content-Encoding 是 HTTP 协议中的一个头部字段，用于指示服务器对响应内容进行了何种类型的编码压缩。它的作用是告知客户端如何解码和还原服务器返回的压缩内容。 Content-Encoding 的作用包括： 压缩传输：通过使用 Content-Encoding 头部字段，服务器可以对响应内容进行压缩，减小数据的大小，从而减少传输的数据量和网络带宽消耗。这可以提高网络传输的效率，加快数据的传输速度。 节省带宽：通过压缩响应内容，Content-Encoding 可以减少数据的大小，从而节省网络带宽。这对于网络流量较大的网站和应用程序来说，可以降低服务器和网络的负载，提高整体性能和响应速度。 客户端解压缩：客户端在收到带有 Content-Encoding 头部字段的响应时，可以根据指定的压缩算法对内容进行解压缩。这样客户端就能够还原压缩前的原始内容，以便正确处理和显示。 常见的 Content-Encoding 值包括：Gzip、Deflate、Br 等算法。 对于 REST API 的开发者来说，资源表示压缩是一项非常重要的技术，可以帮助我们提高 API 的性能，减少响应大小，提升用户体验。 ⓶ 压缩算法在构建部署项目的一次实践先说结论：压缩平均节省了 90% 的时间。 本节将以 《速度与压缩比如何兼得？压缩算法在构建部署中的优化》为例，简要说明压缩算法在项目实践中的效果。 文中用的是镜像的构建包数据； 方案对比测试中选择了 1GB 左右的构建包进行压缩测试，既能覆盖 99% 的场景，也可以看出压缩算法之间比较明显的提升； 几种压缩算法对比： 文中测试了这几种算法结果（多次运行选择结果的中位数），数据对比如下表格： Zstd 官方 Benchmark 数据对比 文中用 Zstd 对镜像的发布包做了测试，结论如下： 我们采用 Zstd 默认的参数进行了测试，压缩时间 8.471 s 仅为原来的 11.266%，提升了 88.733%。 解压时间 3.211 仅为原来的 29.83%，提升约为 70.169%。 同时压缩率也从 2.548 提升到了 2.621。 优劣分析总结： 在测试案例对比中，时间耗时的顺序为 Pzstd &lt; ISA-L &lt; Pigz &lt; LZ 4 &lt; Zstd &lt; Brotli &lt; Gzip （排名越靠前越好），其中压缩和解压缩的时间在整体的耗时上占比较大，因此备选策略为 Pzstd、ISA-L、Pigz。 详细的测试过程和方案对比可以参考原文： 《速度与压缩比如何兼得？压缩算法在构建部署中的优化》 小结谚云：没有最好，只有最适合 压缩算法的衡量指标包括：压缩比、压缩&#x2F;解压速度、CPU&#x2F;内存占用等。这些指标通常是相互关联的，不同的压缩算法在不同的数据类型和压缩设置下可能表现出不同的性能。选择合适的压缩算法应综合考虑这些指标，并根据具体的应用需求进行权衡。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"解耦：消息队列","slug":"9-解耦：消息队列","date":"2024-08-22T04:27:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"9-解耦：消息队列.html","link":"","permalink":"https://liangyuanzheng.com/9-%E8%A7%A3%E8%80%A6%EF%BC%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html","excerpt":"","text":"解耦：消息队列业务场景消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。 常用的消息队列实现有：Kafka、RabbitMQ、RocketMQ、Pulsar、ActiveMQ 等等。关于消息队列选型可参考：《【万字长文】消息队列（MQ）选型及常见问题看这一篇就够了》本节将主要介绍如何使用消息队列去解决业务上的具体问题。 案例⓵ 解耦系统以电商系 IT 架构为例。在传统的紧耦架构中，客户下单后，订单系统收到请求后，调用库存系统减库存。这种模式有如下缺点： 订单系统与库存系统强耦合，可能是服务内 RPC 调用； 遇到突发流量时，库存系统负载（查询、修改）。 引用 MQ 后的方案： 引入 MQ 后，订单系统和库存系统分别工作，解除了强耦合性。即便在下单时库存系统宕机了，也不影响正常下单（待库存系统恢复后，从 MQ 取出订单保证最终成功）。 电商网站中，新的用户注册时，需要将用户的信息保存到数据库中，同时还需要额外发送注册的邮件通知、以及短信注册码给用户。 ⓶ 异步通信电商网站中，新的用户注册时，需要将用户的信息保存到数据库中，同时还需要额外发送注册的邮件通知、以及短信注册码给用户。 传统的做法有两种：串行的方式、并行的方式。 串行的方式： 将注册信息写入数据库后，先发送邮件通知，再发送短信提醒。以上三个任务全部完成后，返回给客户端。 图：串行发送 并行的方式： 将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个过程完成后，返回给客户端。与串行的差别是并行的方式可以缩短处理时间。 图：并行发送 消息队列： 引入消息队列后，非关键路径（通知部分）就可以异步处理了，从而实现快速响应： 注册信息写入数据库成功后，再把发送注册邮件、注册短信的消息写入消息队列，返回给客户端； 然后，服务端订阅消息队列（保证最终成功），分别发送注册邮件、注册短信。 ⓷ 削峰填谷像双十一、手机预约抢购等对 IO 时延敏感的业务场景，当外部请求超过系统负载时，如果系统没有过载保护策略，很可能会被短时的峰值流量冲垮。 针对这种洪峰流量，引入消息队列，将非即时处理的业务逻辑进行异步化，处理成功后通知用户（邮件、短信等）。这种削弱峰值流量延缓处理的方式，相当于给系统做了一层缓冲。 图：削峰填谷 上图中，黄色的部分代表超出消息处理能力的部分。把黄色部分的消息平均到之后的空闲时间去处理，这样既可以保证系统负载处在一个稳定的水位，又可以尽可能地处理更多消息。通过配置流控规则，可以达到消息匀速处理的效果。 ⓸ 广播假如，客户购买商品后，子系统会有以下动作： 积分系统累积成长积分； 赠品系统给客户发赠品； 推荐系统推送商品周边； … 凡此种种，这些子系统之间没有依赖关系。引入 MQ 可以大大简化业务逻辑： 降低交易系统的复杂度，仅生产交易消息； 解除系统间依赖，生产一次数据，可被不同子系统同时消费，多次复用； 可以根据业务特性，延迟处理。 ⓹ 延时队列消息队列可以实现一些延时操作，如定时调度、超时处理等。 分布式定时调度： 在需要精细化调度的场景中，如每 2 分钟触发一次消息推送。传统基于数据库的定时调度方案在分布式场景下（特别是数据量大的时候），性能不高，实现复杂。基于消息队列（如 RocketMQ）可以封装出类似的定时触发器： 任务超时处理： 以购买火车票为例，我们在 12306 下单后暂未支付，订单是不会被取消的。而是等待一段时间后（如 30 min），系统才会关闭未支付的订单。可以使用消息队列实现超时任务检查： 基于定时消息的超时任务处理有如下优势： 精度高、开发门槛低：基于消息通知方式不存在定时阶梯间隔。可以轻松实现任意精度事件触发，无需业务去重。 高性能可扩展：传统的数据库扫描方式较为复杂，需要频繁调用接口扫描，容易产生性能瓶颈。消息队列具有高并发和水平扩展的能力。 其他： 延迟消息的使用场景很多，比如异常检测重试、订单超时取消等，例如： 服务请求异常，需要将异常请求放到单独的队列，隔 5 分钟后进行重试； 用户购买商品，但一直处于未支付状态，需要定期提醒用户支付，超时则关闭订单； 面试或者会议预约，在面试或者会议开始前半小时，发送通知再次提醒。 小结谚云：All problems in computer science can be solved by another level of indirection. 计算机科学中的所有问题都可以通过另一个中间层来解决。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"消息队列","slug":"消息队列","permalink":"https://liangyuanzheng.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"【万字长文】消息队列（MQ）选型及常见问题看这一篇就够了","slug":"202405241816-【万字长文】消息队列（MQ）选型及常见问题看这一篇就够了","date":"2024-08-20T08:05:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"202405241816-【万字长文】消息队列（MQ）选型及常见问题看这一篇就够了.html","link":"","permalink":"https://liangyuanzheng.com/202405241816-%E3%80%90%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89%E9%80%89%E5%9E%8B%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html","excerpt":"","text":"消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。本文系消息队列（MQ）选型和常见问题的精心整理。在这篇文章中，我们将详细介绍消息队列的概念、作用以及如何选择适合自己需求的消息队列系统。 1 概述消息队列是分布式系统中重要的中间件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。分布式系统可以借助消息队列的能力，轻松实现以下功能： 解耦：将一个流程的上下游拆解开，上游专注于生产消息，下游专注于处理消息； 广播：上游生产的消息可以轻松被多个下游服务处理； 缓冲：应对突发流量，消息队列扮演缓冲器的作用，保护下游服务，使其可以根据自身的实际消费能力处理消息； 异步：上游发送消息后可以马上返回，下游可以异步处理消息； 冗余：保留历史消息，处理失败或当出现异常时可以进行重试或者回溯，防止丢失； 2 架构简介2.1 Kafka2.1.1 系统框架 一个 Kafka 集群由多个 Broker 和一个 ZooKeeper 集群组成，Broker 作为 Kafka 节点的服务器。同一个消息主题 Topic 可以由多个分区 Partition 组成，分区物理存储在 Broker 上。负载均衡考虑，同一个 Topic 的多个分区存储在多个不同的 Broker 上，为了提高可靠性，每个分区在不同的 Broker 会存在副本。 ZookKeeper 是一个分布式开源的应用程序协调服务，可以实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。Kafka 里的 ZooKeeper 主要有一下几个作用： Broker 注册，当有 Broker 故障的时候能及时感知。 Topic 注册，维护 Topic 各分区的个副本所在的 Broker 节点，以及对应 leader&#x2F;follower 的角色。 Consumer 注册，维护消费者组的 offset 以及消费者与分区的对应关系，实现负载均衡。 2.1.2 基本术语Producer：消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息 key 值将消息写入指定分区。写入分区的数据越均匀 Kafka 的性能才能更好发挥。 Topic：Topic 是个抽象的虚拟概念，一个集群可以有多个 Topic，作为一类消息的标识。一个生产者将消息发送到 topic，消费者通过订阅 Topic 获取分区消息。 Partition：Partition 是个物理概念，一个 Topic 对应一个或多个 Partition。新消息会以追加的方式写入分区里，在同一个 Partition 里消息是有序的。Kafka 通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。 Replicas：一个 Partition 有多个 Replicas 副本。这些副本保存在 broker，每个 broker 存储着成百上千个不同主题和分区的副本，存储的内容分为两种：master 副本，每个 Partition 都有一个 master 副本，所有内容的写入和消费都会经过 master 副本；follower 副本不处理任何客户端的请求，只同步 master 的内容进行复制。如果 master 发生了异常，很快会有一个 follower 成为新的 master。 Consumer：消息读取者。消费者订阅主题，并按照一定顺序读取消息。Kafka 保证每个分区只能被一个消费者使用。 Offset：偏移量是一种元数据，是不断递增的整数。在消息写入时 Kafka 会把它添加到消息里。在分区内偏移量是唯一的。消费过程中，会将最后读取的偏移量存储在 Kafka 中，消费者关闭偏移量不会丢失，重启会继续从上次位置开始消费。 Broker：独立的 Kafka 服务器。一个 Topic 有 N 个 Partition，一个集群有 N 个 Broker，那么每个 Broker 都会存储一个这个 Topic 的 Partition。如果某 topic 有 N 个 partition，集群有(N+M)个 broker，那么其中有 N 个 broker 存储该 topic 的一个 partition，剩下的 M 个 broker 不存储该 topic 的 partition 数据。如果某 topic 有 N 个 partition，集群中 broker 数目少于 N 个，那么一个 broker 存储该 topic 的一个或多个 partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致 Kafka 集群数据不均衡。 2.2 Pulsar2.2.1 系统框架 Pulsar 有三个重要的组件，Broker、BookKeeper 和ZooKeeper，Broker 是无状态服务，客户端需要连接到 Broker 上进行消息的传递。BookKeeper 与 ZooKeeper 是有状态服务。BookKeeper 的节点叫 Bookie，负责存储消息和游标，ZooKeeper 存储 Broker 和 Bookie 的元数据。Pulsar 以这种架构，实现存储和计算分离，Broker 负责计算，Bookie 负责有状态存储。 Pulsar 的多层架构影响了存储数据的方式。Pulsar 将 Topic 分区划分为分片（Segment），然后将这些分片存储在 Apache BookKeeper 的存储节点上，以提高性能、可伸缩性和可用性。Pulsar 的分布式日志以分片为中心，借助扩展日志存储（通过 Apache BookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定 Topic 相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或缩扩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。 2.2.2 基本术语Property：代表租户，每个 property 都可以代表一个团队、一个功能、一个产品线。一个 property 可包含多个 namesapce，多租户是一种资源隔离手段，可以提高资源利用率； Namespace：Pulsar 的基本管理单元，在 namaspace 级别可设置权限、消息 TTL、Retention 策略等。一个 namaspace 里的所有 topic 都继承相同的设置。命名空间分为两种：本地命名空间，只在集群内可见、全局命名空间对多个集群可见集群命名空间； Producer：数据生产方，负责创建消息并将消息投递到 Pulsar 中； Consumer：数据消费方，连接到 Pulsar 接收消息并进行相应的处理； Broker：无状态 Proxy 服务，负责接收消息、传递消息、集群负载均衡等操作，它对 client 屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色。Broker 不会持久化保存元数据。可以扩容但不能缩容； BookKeeper：有状态，负责持久化存储消息。当集群扩容时，Pulsar 会在新增 BookKeeper 和 Segment（即 Bookeeper 的 Ledger），不需要像 kafka 一样在扩容时进行 Rebalance。扩容结果是 Fragments 跨多个 Bookies 以带状分布，同一个 Ledger 的 Fragments 分布在多个 Bookie 上，导致读取和写入会在多个 Bookies 之间跳跃； ZooKeeper：存储 Pulsar 、 BookKeeper 的元数据，集群配置等信息，负责集群间的协调、服务发现等； Topic：用作从 producer 到 consumer 传输消息。Pulsar 在 Topic 级别拥有一个 leader Broker，称之为拥有 Topic 的所有权，针对该 Topic 所有的 R&#x2F;W 都经过该 Broker 完成。Topic 的 Ledger 和 Fragment 之间映射关系等元数据存储在 Zookeeper 中，Pulsar Broker 需要实时跟踪这些关系进行读写流程； Ledger：即 Segment，Pulsar 底层数据以 Ledger 的形式存储在 BookKeeper 上。是 Pulsar 删除的最小单位； Fragment ：每个 Ledger 由若干 Fragment 组成。 2.3 RocketMQ2.3.1 系统框架RocketMQ 是阿里开源的消息中间件，它是一个开源的分布式消息传递和流式数据平台。总共有四大部分：NameServer，Broker，Producer，Consumer。 NameServer 主要用来管理 brokers 以及路由信息。broker 服务器启动时会注册到 NameServer 上，并且两者之间保持心跳监测机制，以此来保证 NameServer 知道 broker 的存活状态。而且，每一台 NameServer 都存有全部的 broker 集群信息和生产者&#x2F;消费者客户端的请求信息。 Broker 负责管理消息存储分发，主从数据同步，为消息建立索引，提供消息查询等能力。 2.3.2 基本术语Topic：一个 Topic 可以有 0 个、1 个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0 个、1 个、多个消费者订阅； Tag：消息二级类型，可以为用户提供额外的灵活度，一条消息可以没有 tag； Producer：消息生产者； Broker：存储消息，以 Topic 为纬度轻量级的队列；转发消息，单个 Broker 节点与所有的 NameServer 节点保持长连接及心跳，会定时将 Topic 信息注册到 NameServer； Consumer：消息消费者，负责接收并消费消息； MessageQueue：消息的物理管理单位，一个 Topic 可以有多个 Queue，Queue 的引入实现了水平扩展的能力； NameServer：负责对原数据的管理，包括 Topic 和路由信息，每个 NameServer 之间是没有通信的； Group：一个组可以订阅多个 Topic，ProducerGroup、ConsumerGroup 分别是一类生产者和一类消费者； Offset：通过 Offset 访问存储单元，RocketMQ 中所有消息都是持久化的，且存储单元定长。Offset 为 Java Long 类型，理论上 100 年内不会溢出，所以认为 Message Queue 是无限长的数据，Offset 是下标； Consumer：支持 PUSH 和 PULL 两种消费模式，支持集群消费和广播消费。 2.4 RabbitMQ2.4.1 系统框架 RabbitMQ 基于 AMQP 协议来实现，主要由 Exchange 和 Queue 两部分组成，然后通过 RoutingKey 关联起来，消息投递到 Exchange 然后通过 Queue 接收。 2.4.2 基本术语Broker：接收客户端链接实体，实现 AMQP 消息队列和路由功能； Virtual Host：是一个虚拟概念，权限控制的最小单位。一个 Virtual Host 里包含多个 Exchange 和 Queue； Exchange：接收消息生产者的消息并将消息转发到队列。发送消息时根据不同 ExchangeType 的决定路由规则，ExchangeType 常用的有：direct、fanout 和 topic 三种； Message Queue：消息队列，存储为被消费的消息； Message：由 Header 和 Body 组成，Header 是生产者添加的各种属性，包含 Message 是否持久化、哪个 MessageQueue 接收、优先级。Body 是具体的消息内容； Binding：Binding 连接起了 Exchange 和 Message Queue。在服务器运行时，会生成一张路由表，这张路由表上记录着 MessageQueue 的条件和 BindingKey 值。当 Exchange 收到消息后，会解析消息中的 Header 得到 BindingKey，并根据路由表和 ExchangeType 将消息发送到对应的 MessageQueue。最终的匹配模式是由 ExchangeType 决定； Connection：在 Broker 和客户端之间的 TCP 连接； Channel：信道。Broker 和客户端只有 tcp 连接是不能发送消息的，必须创建信道。AMQP 协议规定只有通过 Channel 才能执行 AMQP 命令。一个 Connection 可以包含多个 Channel。之所以需要建立 Channel，是因为每个 TCP 连接都是很宝贵的。如果每个客户端、每个线程都需要和 Broker 交互，都需要维护一个 TCP 连接的话是机器耗费资源的，一般建议共享 Connection。RabbitMQ 不建议客户端线程之前共享 Channel，至少保证同一 Channel 发送消息是串行的； Command：AMQP 命令，客户端通过 Command 来完成和 AMQP 服务器的交互。 2.5 NSQ2.5.1 系统框架NSQ 主要有 nsqlookup、nsqd 两部分组成： Nsqlookup 为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询 nsqlookupd 获取指定 Topic 所在的 nsqd 节点。nsqd 往 nsqlookup 上注册和广播自身 topic 和 channel 的信息。 nsqd 在服务端运行的守护进程，负责接收，排队，投递消息给客户端。 NSQ 由 3 个守护进程组成: nsqd 是接收、队列和传送消息到客户端的守护进程。 nsqlookupd 是管理的拓扑信息，并提供了最终一致发现服务的守护进程。客户端通过查询 nsqlookupd 获取指定 Topic 所在的 nsqd 节点。nsqd 往 nsqlookup 上注册和广播自身 topic 和 channel 的信息。 nsqadmin 是一个 Web UI 来实时监控集群(和执行各种管理任务)。 3 选型要点3.1 选型参考 消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序； 伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。 消息留存：消息消费成功后，是否还会继续保留在消息队列； 容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费成功的准确性； 消息可靠性：是否会存在丢消息的情况，比如有 A&#x2F;B 两个消息，最后只有 B 消息能消费，A 消息丢失； 消息时序：主要包括“消息存活时间”和“延迟消息”； 吞吐量：支持的最高并发数； 消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有 A&#x2F;B 两者规则的消息，消费者可以只订阅 A 消息，B 消息不会消费。 3.2 消息队列对比 维度 ActiveMQ RabbitMQ RocketMQ Kafka Pulsar 单机吞吐量 较低(万级) 一般（万级） 高（十万级） 高（十万级） 高（十万级） 开发语言 Java Erlang Java Java&#x2F;Scala Java 维护者 Apache Spring Apache（Alibaba） Apache（Confluent） Apache（StreamNative） Star 数量 2.3K 12K 21K 28.2K 14.1K Contributor 139 264 527 1189 661 社区活跃度 低 高 较高 高 高 消费模式 P2P、Pub-Sub direct、topic、Headers、fanout 基于 Topic 和 MessageTag 的的 Pub-Sub 基于 Topic 的 Pub-Sub 基于 Topic 的 Pub-Sub，支持独占（exclusive）、共享（shared）、灾备（failover）、key 共享（key_shared）4 种模式 持久化 支持（小） 支持（小） 支持（大） 支持（大） 支持（大） 顺序消息 不支持 不支持 支持 支持 支持 性能稳定性 好 好 一般 较差 一般 集群支持 主备模式 复制模式 主备模式 Leader-Slave 每台既是 master 也是 slave，集群可扩展性强 集群模式，broker 无状态，易迁移，支持跨数据中心 管理界面 一般 较好 一般 无 无 计算和存储分离 不支持 不支持 不支持 不支持 支持 AMQP 支持 支持 支持 支持 不完全支持 不完全支持 注：作为 LShift 和 CohesiveFT 于 2007 年成立的合资企业，RabbitMQ 于 2010 年 4 月被 VMware 旗下的 SpringSource 收购。 4 功能剖析4.1 消费推拉模式客户端消费者获取消息的方式，Kafka 和 RocketMQ 是通过长轮询 Pull 的方式拉取消息，RabbitMQ、Pulsar、NSQ 都是通过 Push 的方式。 pull 类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而 push 类型的消息队列，实时性更好，但需要有一套良好的流控策略当消费者消费能力不足时，减少 push 的消费数量，避免压垮消费端。 4.2 延迟队列消息延迟投递，当消息产生送达消息队列时，有些业务场景并不希望消费者立刻收到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种，基于消息的延迟和基于队列的延迟。基于消息的延迟指为每条消息设置不同的延迟时间，当队列有新消息进入的时候根据延迟时间排序，当然这样会对性能造成较大影响。另一种基于队列的延迟指的是设置不同延迟级别的队列，队列中每个消息的延迟时间都是相同的，这样免去了基于延迟时间排序对性能带来的损耗，通过一定的扫描策略即可投递超时的消息。 延迟消息的使用场景比如异常检测重试，订单超时取消等，例如： 服务请求异常，需要将异常请求放到单独的队列，隔 5 分钟后进行重试； 用户购买商品，但一直处于未支付状态，需要定期提醒用户支付，超时则关闭订单； 面试或者会议预约，在面试或者会议开始前半小时，发送通知再次提醒。 Kafka 不支持延迟消息。Pulsar 支持秒级的延迟消息，所有延迟投递的消息会被 Delayed Message Tracker 记录对应的 index，consumer 在消费时，会先去 Delayed Message Tracker 检查，是否有到期需要投递的消息，如果有到期的消息，则从 Tracker 中拿出对应的 index，找到对应的消息进行消费，如果没有到期的消息，则直接消费正常的消息。对于长时间的延迟消息，会被存储在磁盘中，当快到延迟间隔时才被加载到内存里。 RocketMQ 开源版本延迟消息临时存储在一个内部主题中，不支持任意时间精度，支持特定的 level，例如定时 5s，10s，1m 等。 RabbitMQ 需要安装一个 rabbitmq_delayed_message_exchange 插件。 NSQ 通过内存中的优先级队列来保存延迟消息，支持秒级精度，最多 2 个小时延迟。 4.3 死信队列 由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。 Kafka 没有死信队列，通过 Offset 的方式记录当前消费的偏移量。 Pulsar 有重试机制，当某些消息第一次被消费者消费后，没有得到正常的回应，则会进入重试 Topic 中，当重试达到一定次数后，停止重试，投递到死信 Topic 中。 RocketMQ 通过 DLQ 来记录所有消费失败的消息。 RabbitMQ 是利用类似于延迟队列的形式实现死信队列。 NSQ 没有死信队列。 4.4 优先级队列有一些业务场景下，我们需要优先处理一些消息，比如银行里面的金卡客户、银卡客户优先级高于普通客户，他们的业务需要优先处理。如下图： 优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。 Kafka、RocketMQ、Pulsar、NSQ 不支持优先级队列，可以通过不同的队列来实现消息优先级。 RabbitMQ 支持优先级消息。 4.5 消息回溯一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。 Kafka 支持消息回溯，可以根据时间戳或指定 Offset，重置 Consumer 的 Offset 使其可以重复消费。 Pulsar 支持按时间对消息进行回溯。 RocketMQ 支持按时间回溯，实现的原理跟 Kafka 一致。 RabbitMQ 不支持回溯，消息一旦标记确认就会被标记删除。 NSQ 一般消息是不可回溯的，但可以通过 nsq_to_file 工具，将消息写入到文件，然后从文件里重放消息。 4.6 消息持久化流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。消息堆积分内存式堆积和磁盘式堆积。一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。 Kafka 和 RocketMQ 直接将消息刷入磁盘文件中进行持久化，所有的消息都存储在磁盘中。只要磁盘容量够，可以做到无限消息堆积。 RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中。 Pulsar 消息是存储在 BookKeeper 存储集群上，也是磁盘文件。 NSQ 通过 nsq_to_file 工具，将消息写入到文件。 4.7 消息确认机制消息队列需要管理消费进度，确认消费者是否成功处理消息，使用 push 的方式的消息队列组件往往是对单条消息进行确认，对于未确认的消息，进行延迟重新投递或者进入死信队列。 Kafka通过 Offset 的方式确认消息。 1）发送方确认机制ack&#x3D;0，不管消息是否成功写入分区ack&#x3D;1，消息成功写入首领分区后，返回成功ack&#x3D;all，消息成功写入所有分区后，返回成功。 2）接收方确认机制自动或者手动提交分区偏移量，早期版本的 kafka 偏移量是提交给 Zookeeper 的，这样使得 zookeeper 的压力比较大，更新版本的 kafka 的偏移量是提交给 kafka 服务器的，不再依赖于 zookeeper 群组，集群的性能更加稳定。 RocketMQ与 Kafka 类似也会提交 Offset，区别在于消费者对于消费失败的消息，可以标记为消息消费失败，Broker 会重试投递，如果累计多次消费失败，会投递到死信队列。 RabbitMQ和 NSQ 类似，消费者确认单条消息，否则会重新放回队列中等待下次投递。 1）发送方确认机制，消息被投递到所有匹配的队列后，返回成功。如果消息和队列是可持久化的，那么在写入磁盘后，返回成功。支持批量确认和异步确认。 2）接收方确认机制，设置 autoAck 为 false，需要显式确认，设置 autoAck 为 true，自动确认。当 autoAck 为 false 的时候，rabbitmq 队列会分成两部分，一部分是等待投递给 consumer 的消息，一部分是已经投递但是没收到确认的消息。如果一直没有收到确认信号，并且 consumer 已经断开连接，rabbitmq 会安排这个消息重新进入队列，投递给原来的消费者或者下一个消费者。未确认的消息不会有过期时间，如果一直没有确认，并且没有断开连接，rabbitmq 会一直等待，rabbitmq 允许一条消息处理的时间可以很久很久。 Pulsar使用专门的 Cursor 管理。累积确认和 Kafka 效果一样；提供单条或选择性确认。 4.8 消息 TTL消息 TTL 表示一条消息的生存时间，如果消息发出来后，在 TTL 的时间内没有消费者进行消费，消息队列会将消息删除或者放入死信队列中。 Kafka 根据设置的保留期来删除消息。有可能消息没被消费，过期后被删除。不支持 TTL。 Pulsar 支持 TTL，如果消息未在配置的 TTL 时间段内被任何消费者使用，则消息将自动标记为已确认。消息保留期与消息 TTL 之间的区别在于：消息保留期作用于标记为已确认并设置为已删除的消息，而 TTL 作用于未 ack 的消息。上面的图例中说明了 Pulsar 中的 TTL。例如，如果订阅 B 没有活动消费者，则在配置的 TTL 时间段过后，消息 M10 将自动标记为已确认，即使没有消费者实际读取该消息。 RocketMQ 提及到消息 TTL 的资料比较少，不过看接口似乎是支持的。 RabbitMQ 有两种方式，一个是声明队列的时候在队列属性中设置，整个队列中的消息都有相同的有效期。还可以发送消息的时候给消息设置属性，可以位每条消息都设置不同的 TTL。 NSQ 似乎还没支持，有一个 Feature Request 的 Issue 处于 Open 状态。 4.9 多租户隔离多租户是指通过一个软件实例为多个租户提供服务的能力。租户是指对系统有着相同“视图”的一组用户。不支持多租户的系统里边，往往要为不同用户或者不同集群创建多个消息队列实例实现物理隔离，这样会带来较高的运维成本。作为一种企业级的消息系统，Pulsar 的多租户能力按照设计可满足下列需求： 确保严苛的 SLA 可顺利满足。 保证不同租户之间的隔离。 针对资源利用率强制实施配额。 提供每租户和系统级的安全性。 确保低成本运维以及尽可能简单的管理。 Pulsar 通过下列方式满足了上述需求： 通过为每个租户进行身份验证、授权和 ACL（访问控制列表）获得所需安全性。 为每个租户强制实施存储配额。 以策略的方式定义所有隔离机制，策略可在运行过程中更改，借此降低运维成本并简化管理工作。 4.10 消息顺序性消息顺序性是指保证消息有序。消息消费顺序跟生产的顺序保持一致。 Kafka 保证了分区内的消息有序。 Pulsar 支持两种消费模式，独占订阅的流模式只保证了消息的顺序性，共享订阅队列模型不保证有序性。 RocketMQ 需要用到锁来保证一个队列同时只有一个消费者线程进行消费，保证消息的有序性。 RabbitMQ 顺序性的条件比较苛刻，需要单线程发送、单线程消费，并且不采用延迟队列、优先级队列等高级功能。 NSQ 是利用了 golang 自身的 case&#x2F;select 实现的消息分发，本身不提供有序性保障，不能够把特性消息和消费者对应起来，无法实现消息的有序性。 4.11 消息查询在实际开发中，经常要查看 MQ 中消息的内容，比如通过某个 MessageKey&#x2F;ID，查询到 MQ 的具体消息。或者是对消息进行链路追踪，知道消息从哪里来，发送到哪里去，进而快速对问题进行排查定位。 Kafka 存储层是以分布式提交日志的形式实现，每次写操作都顺序追加到日志的末尾。读也是顺序读。不支持检索功能。 Pulsar 可以通过消息 ID，查询到具体某条消息的消息内容、消息参数和消息轨迹。 RocketMQ 支持按 Message Key、Unique Key、Message Id 对消息进行查询。 RabbitMQ 使用基于索引的存储系统。这些将数据保存在树结构中，以提供确认单个消息所需的快速访问。由于 RabbitMQ 的消息在确认后会被删除，因此只能查询未确认的消息。 NSQ 自身不支持消息持久化和消息检索，不过可以使用 nsq_to_http 等工具将消息写入可支持索引的存储里。 4.12 消费模式Kafka 有两种消费模式，最终都会保证一个分区只有 1 个消费者在消费： subscribe 方式：当主题分区数量变化或者 consumer 数量变化时，会进行 rebalance；注册 rebalance 监听器，可以手动管理 offset 不注册监听器，kafka 自动管理。 assign 方式：手动将 consumer 与 partition 进行对应，kafka 不会进行 rebanlance。 Pulsar 有以下四种消费模式，其中独占模式和灾备模式跟 Kafka 类似，为流模型，每个分区只有 1 个消费者消费，能保证消息有序性。共享模式和 Key 共享模式为队列模型，多个消费者能提高消费速度，但不能保证有序性。 Exclusive 独占模式（默认模式）：一个 Subscription 只能与一个 Consumer 关联，只有这个 Consumer 可以接收到 Topic 的全部消息，如果该 Consumer 出现故障了就会停止消费。 灾备模式（Failover）：当存在多个 consumer 时，将会按字典顺序排序，第一个 consumer 被初始化为唯一接受消息的消费者。当第一个 consumer 断开时，所有的消息（未被确认和后续进入的）将会被分发给队列中的下一个 consumer。 共享模式（Shared）：消息通过 round robin 轮询机制（也可以自定义）分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。 KEY 共享模式（Key_Shared）：当存在多个 consumer 时，将根据消息的 key 进行分发，key 相同的消息只会被分发到同一个消费者。 RocketMQ 有两种消费模式，BROADCASTING 广播模式，CLUSTERING 集群模式。 广播消费指的是：一条消息被多个 consumer 消费，即使这些 consumer 属于同一个 ConsumerGroup，消息也会被 ConsumerGroup 中的每个 Consumer 都消费一次，广播消费中 ConsumerGroup 概念可以认为在消息划分方面无意义。 集群消费模式：一个 ConsumerGroup 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 ConsumerGroup 有 3 个实例（可能是 3 个进程，或者 3 台机器），那么每个实例只消费其中部分，消费完的消息不能被其他实例消费。 RabbitMQ 和 NSQ 的消费比较类似，都是跟 Pulsar 共享模式类似的，队列的形式，增加一个消费者组里的消费者数量能提高消费速度。 4.13 消息可靠性消息丢失是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。比如当服务出现故障时，一些对于生产者来说已经生产成功的消息，是否会在高可用切换时丢失。同步刷盘是增强一个组件可靠性的有效方式，消息中间件也不例外，Kafka 和 RabbitMQ 都可以支持同步刷盘，但绝大多数情景下，一个组件的可靠性不应该由同步刷盘这种极其损耗性能的操作来保障，而是采用多副本的机制来保证。 Kafka 可以通过配置 request.required.acks 参数设置可靠级别，表示一条消息有多少个副本确认接收成功后，才被任务发送成功。 request.required.acks&#x3D;-1 (全量同步确认，强可靠性保证) request.required.acks&#x3D;1(leader 确认收到，默认) request.required.acks&#x3D;0 (不确认，但是吞吐量大) Pulsar 有跟 Kafka 类似的概念，叫 Ack Quorum Size(Qa)，Qa 是每次写请求发送完毕后需要回复确认的 Bookie 的个数，其数值越大则需要确认写成功的时间越长，其值上限是副本数 Qw。为了一致性，Qa 应该是：(Qw+1)&#x2F;2 或者更，即为了确保数据安全性，Qa 下限是 (Qw+1)&#x2F;2。 RocketMQ 与 Kafka 类似。 RabbitMQ 是主从架构，通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在 master 节点宕机异常之后可以提升 slave 作为新的 master 而继续提供服务来保障可用性。 NSQ 会通过 go-diskqueue 组件将消息落盘到本地文件中，通过 mem-queue-size 参数控制内存中队列大小，如果 mem-queue-size&#x3D;0 每条消息都会存储到磁盘里，不用担心节点重启引起的消息丢失。但由于是存储在本地磁盘中，如果节点离线，堆积在节点磁盘里的消息会丢失。 4.14 负载均衡Kafka：支持负载均衡。一个 broker 通常就是一台服务器节点。对于同一个 Topic 的不同分区，Kafka 会尽力将这些分区分布到不同的 Broker 服务器上，zookeeper 保存了 broker、主题和分区的元数据信息。分区首领会处理来自客户端的生产请求，kafka 分区首领会被分配到不同的 broker 服务器上，让不同的 broker 服务器共同分担任务。 每一个 broker 都缓存了元数据信息，客户端可以从任意一个 broker 获取元数据信息并缓存起来，根据元数据信息知道要往哪里发送请求。 kafka 的消费者组订阅同一个 topic，会尽可能地使得每一个消费者分配到相同数量的分区，分摊负载。 当消费者加入或者退出消费者组的时候，还会触发再均衡，为每一个消费者重新分配分区，分摊负载。 kafka 的负载均衡大部分是自动完成的，分区的创建也是 kafka 完成的，隐藏了很多细节，避免了繁琐的配置和人为疏忽造成的负载问题。 发送端由 topic 和 key 来决定消息发往哪个分区，如果 key 为 null，那么会使用轮询算法将消息均衡地发送到同一个 topic 的不同分区中。如果 key 不为 null，那么会根据 key 的 hashcode 取模计算出要发往的分区。 rabbitmq：对负载均衡的支持不好。消息被投递到哪个队列是由交换器和 key 决定的，交换器、路由键、队列都需要手动创建。 rabbitmq 客户端发送消息要和 broker 建立连接，需要事先知道 broker 上有哪些交换器，有哪些队列。通常要声明要发送的目标队列，如果没有目标队列，会在 broker 上创建一个队列，如果有，就什么都不处理，接着往这个队列发送消息。假设大部分繁重任务的队列都创建在同一个 broker 上，那么这个 broker 的负载就会过大。（可以在上线前预先创建队列，无需声明要发送的队列，但是发送时不会尝试创建队列，可能出现找不到队列的问题，rabbitmq 的备份交换器会把找不到队列的消息保存到一个专门的队列中，以便以后查询使用） 使用镜像队列机制建立 rabbitmq 集群可以解决这个问题，形成 master-slave 的架构，master 节点会均匀分布在不同的服务器上，让每一台服务器分摊负载。slave 节点只是负责转发，在 master 失效时会选择加入时间最长的 slave 成为 master。 当新节点加入镜像队列的时候，队列中的消息不会同步到新的 slave 中，除非调用同步命令，但是调用命令后，队列会阻塞，不能在生产环境中调用同步命令。 当 rabbitmq 队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。 这种方式非常适合扩展，而且是专门为并发程序设计的。 如果某些消费者的任务比较繁重，那么可以设置 basicQos 限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，rabbitmq 不再向这个消费者发送任何消息。 对于 rabbitmq 而言，客户端与集群建立的 TCP 连接不是与集群中所有的节点建立连接，而是挑选其中一个节点建立连接。 但是 rabbitmq 集群可以借助 HAProxy、LVS 技术，或者在客户端使用算法实现负载均衡，引入负载均衡之后，各个客户端的连接可以分摊到集群的各个节点之中。 客户端均衡算法： 轮询法。按顺序返回下一个服务器的连接地址。 加权轮询法。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载。 随机法。随机选取一个服务器的连接地址。 加权随机法。按照概率随机选取连接地址。 源地址哈希法。通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算。 最小连接数法。动态选择当前连接数最少的一台服务器的连接地址。 zeromq：去中心化，不支持负载均衡。本身只是一个多线程网络库。 rocketmq：支持负载均衡。一个 broker 通常是一个服务器节点，broker 分为 master 和 slave,master 和 slave 存储的数据一样，slave 从 master 同步数据。 nameserver 与每个集群成员保持心跳，保存着 Topic-Broker 路由信息，同一个 topic 的队列会分布在不同的服务器上。 发送消息通过轮询队列的方式发送，每个队列接收平均的消息量。发送消息指定 topic、tags、keys，无法指定投递到哪个队列（没有意义，集群消费和广播消费跟消息存放在哪个队列没有关系）。 tags 选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。目前只支 持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念。 keys 选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，设置后， 可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能 保证 key 唯一，例如订单号，商品 Id 等。 rocketmq 的负载均衡策略规定：Consumer 数量应该小于等于 Queue 数量，如果 Consumer 超过 Queue 数量，那么多余的 Consumer 将不能消费消息。这一点和 kafka 是一致的，rocketmq 会尽可能地为每一个 Consumer 分配相同数量的队列，分摊负载。 activemq：支持负载均衡。可以基于 zookeeper 实现负载均衡。 4.15 集群方式Kafka：天然的‘Leader-Slave’无状态集群，每台服务器既是 Master 也是 Slave。分区首领均匀地分布在不同的 kafka 服务器上，分区副本也均匀地分布在不同的 kafka 服务器上，所以每一台 kafka 服务器既含有分区首领，同时又含有分区副本，每一台 kafka 服务器是某一台 kafka 服务器的 Slave，同时也是某一台 kafka 服务器的 leader。 kafka 的集群依赖于 zookeeper，zookeeper 支持热扩展，所有的 broker、消费者、分区都可以动态加入移除，而无需关闭服务，与不依靠 zookeeper 集群的 mq 相比，这是最大的优势。 rabbitmq：支持简单集群，’复制’模式，对高级集群模式支持不好。 rabbitmq 的每一个节点，不管是单一节点系统或者是集群中的一部分，要么是内存节点，要么是磁盘节点，集群中至少要有一个是磁盘节点。 在 rabbitmq 集群中创建队列，集群只会在单个节点创建队列进程和完整的队列信息（元数据、状态、内容），而不是在所有节点上创建。 引入镜像队列，可以避免单点故障，确保服务的可用性，但是需要人为地为某些重要的队列配置镜像。 zeromq：去中心化，不支持集群。 rocketmq：常用 多对’Master-Slave’ 模式，开源版本需手动切换 Slave 变成 Master Name Server 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。 Broker 部署相对复杂，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId 为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。每个 Broker 与 Name Server 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 Name Server。 Producer 与 Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从 Name Server 取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态，可集群部署。 Consumer 与 Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从 Name Server 取 Topic 路由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳。Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。 客户端先找到 NameServer, 然后通过 NameServer 再找到 Broker。 一个 topic 有多个队列，这些队列会均匀地分布在不同的 broker 服务器上。rocketmq 队列的概念和 kafka 的分区概念是基本一致的，kafka 同一个 topic 的分区尽可能地分布在不同的 broker 上，分区副本也会分布在不同的 broker 上。 rocketmq 集群的 slave 会从 master 拉取数据备份，master 分布在不同的 broker 上。 activemq：支持简单集群模式，比如’主-备’，对高级集群模式支持不好。 5 性能Kafka 的公司 Confluent 在 2020 年 8 月发了一篇 Benchmarking Apache Kafka, Apache Pulsar, and RabbitMQ: Which is the Fastest?文章，并且提出了一个开源的 MQ Benchmark 框架 THE OPENMESSAGING BENCHMARK FRAMEWORK，在这个文档里，对比了 Kafka、Pulsar、RabbitMQ 的吞吐量、端到端延迟等性能数据。最后得出结论 Kafka 相对来说性能最好。 但接下来 StreamNative 在 2020 年 12 月指出了 Confluence 的基准测试的一些问题，并对 Pulsar 进行了参数调优之后重新执行了一遍结果，测试报告展示 Pulsar 能达到跟 Kafka 同样的吞吐量，在某些场景下，Pulsar 的延迟显著低于 Kafka。 而且在性能测试上，有很多客户端、服务端参数设置、机器性能配置等影响，比如消息可靠性级别，压缩算法等，很难做到“完全”控制变量公平的测试。而且 OpenMessaging Benchmark 的开源 Github 的 Readme 上也提到了。 不过有几个关注点： RabbitMQ 的延迟是微秒级的，其他组件的延迟都是毫秒级，RabbitMQ 应该是 MQ 组件里相对来说较低的。 Kafka 单实例在主题&#x2F;分区数比较多的情况下，性能会明显降低。 kafka 是一个分区一个文件，当 topic 过多，分区的总量也会增加，kafka 中存在过多的文件，当对消息刷盘时，就会出现文件竞争磁盘，出现性能的下降。 还有 Kafka 每个消费者加入或退出都会进行重平衡，当分区数比较多时重平衡可能耗时较久，在重平衡的阶段消费者是不能消费消息的。 而 Pulsar 由于存储与计算分离的架构，使得它可以支持百万级别的 Topic 数量。 Pulsar 和 Kafka 都被广泛用于各个企业，也各有优势，都能通过数量基本相同的硬件处理大流量。部分用户误以为 Pulsar 使用了很多组件，因此需要很多服务器来实现与 Kafka 相匹敌的性能。这种想法适用于一些特定硬件配置，但在多数资源配置相同的情况中，Pulsar 的优势更加明显，可以用相同的资源实现更好的性能。举例来说，Splunk 最近分享了他们选择 Pulsar 放弃 Kafka 的原因，其中提到“由于分层架构，Pulsar 帮助他们将成本降低了 30%-50%，延迟降低了 80%-98%，运营成本降低了 33%-50%”。Splunk 团队发现 Pulsar 可以更好地利用磁盘 IO，降低 CPU 利用率，同时更好地控制内存。 在分布式系统里，单机性能指标虽然也很重要，分布式系统整体的性能以及灵活扩缩容、高可用容灾等能力也会是评估的一个重要参考。MQ 中间件具体的性能指标，也需要我们自己根据实际的情况，根据实际购买的集群配置和客户端参数，进行压测调优来评估。 6 运维在使用过程中难免会出现各种异常情况，比如宕机、网络抖动、扩容等。消息队列具备异地容灾，高可用架构等能力，能避免一些计算节点、网络等基础设施不可用导致的故障。 6.1 高可用Kafka 通过分区多副本的方式解决高可用问题。 Pulsar 的计算集群 Broker 是无状态的，可以灵活扩缩容，存储节点 Bookie 上通过消息分区分片副本的方式，每个分片都有一个或多个副本，保证在某一个 Bookie 挂掉后，有其他分片可以提供服务。 RocketMQ 和 RabbitMQ 都是主从架构，当 master 挂掉后，由原来的从节点继续提供服务。备机提供消费服务，保证消息不丢，但不提供写服务。 NSQ 是类似分布式架构，不过由于消息存储是在节点本地磁盘上，如果一个节点离线，堆积在节点磁盘上的消息会丢失。 6.2 跨地域容灾Pulsar 原生支持跨地域容灾功能，在这个图中，每当 P1、P2 和 P3 的生产者分别向 Cluster-A、Cluster-B 和 Cluster-C 中的 T1 topic 发送消息时，这些消息很快在不同的集群中复制。一旦消息完成复制，消费者 C1 和 C2 会从各自的集群消费到这个消息。 在这个跨地域容灾的设计支撑下，其一，我们可以比较容易的将服务分散到多个机房；其二，可以应对机房级别的故障，即在一个机房不可用的情况下，服务可以转接到其它的机房来继续对外提供服务。 一句话概括，Pulsar 的跨地域复制，其实就是在一个本地集群中创建一个 Producer，把异地的集群作为这个 Producer 的发送地址，将本地集群的消息发送过去，并且在本地维护一个 Cusor 来保证消息可靠性和幂等性。 6.3 集群扩容当消息量突然上涨，消息队列集群到达瓶颈的时候，需要对集群进行扩容，扩容一般分为水平扩容和垂直扩容两种方式，水平扩容指的是往往集群中增加节点，垂直扩容指的是把集群中部分节点的配置调高，增加处理能力。 Kafka 集群由于主题分区是物理存储在 Broker 节点上的，新加入的集群的节点并没有存储分区分片，也就无法提供马上提供服务，因此需要把一些 Topic 的分区分配到新加入的节点里，这里会涉及到一个分区数据均衡的过程，将某些分区的数据复制到新节点上。这个过程跟分区当前堆积的数据量、Broker 性能有关，有可能会出现由于源 Broker 负载过高，堆积数据过大，导致数据均衡的时间变长。 Pulsar 的无限分布式日志以分片为中心，借助扩展日志存储（通过 Apache BookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定 topic 相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或缩扩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。 RocketMQ 新节点直接加入到集群中，在新的 broker 创建新 topic 并且分配队列，或者在已有 topic 基础上分配队列。与 Kafka 的区别是，Kafka 的分区是在不同的物理机器上，而 Rocketmq 是逻辑分区，用的队列形式，因此不存在出现数据不均衡的情况。 RabbitMQ 和 NSQ 类似，由于不涉及过多的消息持久化，直接往集群中增加节点。 6.4 使用成本Kafka&#x2F;Pulsar&#x2F;RocketMQ&#x2F;RabbitMQ 在腾讯云上都上线了标准产品，可以直接购买创建实例(产品选型)，能大大降低部署运维成本。而 NSQ 目前暂时还没有上线，需要自行部署。 CKafka 在腾讯云上是以实例的形式售卖，专业版最低配 1494 元&#x2F;月，500G SSD，40MB&#x2F;s，TDMQ Pulsar 是以类似无服务的方式按量计费，按调用次数&#x2F;消息大小&#x2F;存储大小等计费，调用次数 2.00 元&#x2F;百万次。在用量较少的情况下，比如一些小型快速上线的业务，TDMQ Pulsar 的成本会比 CKafka 低很多。 RocketMQ 和 RabbitMQ 都是最近推出的产品，目前仍在公测阶段，暂时还没有定价。 7 常见问题 &amp; 使用场景7.1 Kafka 日志收集：大量的日志消息先写入 kafka，数据服务通过消费 kafka 消息将数据落地； 7.2 RocketMQ 为金融互联网领域而生，对于可靠性要求很高的场景。 7.3 普通消息消息队列最基础的功能就是生产者发送消息、Broker 保存消息，消费者来消费消息，以此实现系统解耦、削峰填谷的作用。 普通消息是消息队列必备的消息类型，也是系统使用场景最多的一种消息。 7.4 顺序消息顺序消息是指生产者发送消息的顺序和消费者消费消息的顺序是一致的。比如在一个电商场景，同一个用户提交订单、订单支付、订单出库，这三个消息消费者需要按照顺序来进行消费。如下图： 顺序消息的实现并不容易，原因如下： 生产者集群中，有多个生产者发送消息，网络延迟不一样，很难保证发送到 Broker 的消息落盘顺序是一致的； 如果 Broker 有多个分区或队列，生产者发送的消息会进入多个分区，也无法保证顺序消费； 如果有多个消费者来异步消费同一个分区，很难保证消费顺序跟生产者发送顺序一致。 要保证消息有序，需要满足两个条件： 同一个生产者必须同步发送消息到同一个分区； 一个分区只能给同一个消费者消费。 如下图： 上面第二个条件是比较容易实现的，一个分区绑定一个消费者就可以，主要是第一个条件。 在主流消息队列的实现中，Kafka 和 Pulsar 的实现方式类似，生产者给消息赋值一个 key，对 key 做 Hash 运算来指定消息发送到哪一个分区。比如上面电商的例子，对同一个用户的一笔订单，提交订单、订单支付、订单出库这三个消息赋值同一个 key，就可以把这三条消息发送到同一个分区。 对于 RocketMQ，生产者在发送消息的时候，可以通过 MessageQueueSelector 指定把消息投递到那个 MessageQueue，如下图： 7.5 延时消息或者也叫定时消息，是指消息发送后不会立即被消费，而是指定一个时间，到时间后再消费。经典的场景比如电商购物时，30 分钟未支付订单，让订单自动失效。 7.5.1 RocketMQ 实现RocketMQ 定义了 18 个延时级别，每个延时级别对应一个延时时间。下面如果延迟级别是 3，则消息会延迟 10s 才会拉取。 RocketMQ 的延时消息如下图： 生产者把消费发送到 Broker 后，Broker 首先把消息保存到 SCHEDULE_TOPIC_XXXX 这个 Topic，然后调度任务会判断是否到期，如果到期，会把消息从 SCHEDULE_TOPIC_XXXX 取出投递到原始的 queue，这样消费者就可以消费到了。 RocketMQ 的延时消息只支持最大两个小时的延时，不过 RocketMQ5.0 基于时间轮算法实现了定时消息，解决了这个问题。 7.5.2 Pulsar 实现Pulsar 的实现如下图： Pulsar 的延时消息首先会写入一个 Delayed Message Tracker 的数据结构中，Delayed Message Tracker 根据延时时间构建 delayed index 优先级队列。消费者拉取消息时，首先去 Delayed Message Tracker 检查是否有到期的消息。如果有则直接拉取进行消费。 7.5.3 RabbitMQ 实现RabbitMQ 的实现方式有两种，一种是投递到普通队列都不消费，等消息过期后被投递到死信队列，消费者消费死信队列。如下图： 第二种方式是生产者发送消息时，先发送到本地 Mnesia 数据库，消息到期后定时器再将消息投递到 broker。 7.5.4 Kafka 实现Kafka 本身并没有延时队列，不过可以通过生产者拦截器来实现消息延时发送，也可以定义延时 Topic，利用类似 RocketMQ 的方案来实现延时消息。 7.6 事务消息事务消息是指生产消息和消费消息满足事务的特性。 RabbitMQ 和 Kafka 的事务消息都是只支持生产消息的事务特性，即一批消息要不全部发送成功，要不全部发送失败。 RabbitMQ 通过 Channel 来开启事务消息，代码如下： 12345678ConnectionFactory factory=new ConnectionFactory();connection=factory.newConnection();Channel channel=connection.createChannel();//开启事务channel.txSelect();channel.basicPublish(\"directTransactionExchange\",\"transactionRoutingKey\",null,message.getBytes(\"utf-8\"));//提交事务 或者 channel.txRollback()回滚事务channel.txCommit(); Kafka 可以给多个生产者设置同一个事务 ID ，从而把多个 Topic 、多个 Partition 放在一个事务中，实现原子性写入。 Pulsar 的事务消息对于事务语义的定义是：允许事件流应用将消费、处理、生产消息整个过程定义为一个原子操作。可见，Pulsar 的事务消息可以覆盖消息流整个过程。 RocketMQ 的事务消息是通过 half 消息来实现的。以电商购物场景来看，账户服务扣减账户金额后，发送消息给 Broker，库存服务来消费这条消息进行扣减库存。如下图: 可见，RocketMQ 只能保证生产者发送消息和本地事务的原子性，并不能保证消费消息的原子性。 7.7 轨迹消息轨迹消息主要用于跟踪消息的生命周期，当消息丢失时可以很方便地找出原因。 轨迹消息也跟普通消息一样，也需要存储和查询，也会占用消息队列的资源，所以选择轨迹消息要考虑下面几点： 消息生命周期的关键节点一定要记录； 不能影响正常消息的发送和消费性能； 不能影响 Broker 的消息存储性能； 要考虑消息查询维度和性能。 RabbitMQ Broker 实现了轨迹消息的功能，打开 Trace 开关，就可以把轨迹消息发送到 amq.rabbitmq.trace 这个 exchange，但是要考虑轨迹消息会不会给 Broker 造成 压力进而导致消息积压。RabbitMQ 的生产者和消费者都没有实现轨迹消息，需要开发者自己来实现。 RocketMQ 生产者、Broker 和消费者都实现了轨迹消息，不过默认是关闭的，需要手工开启。 使用轨迹消息，需要考虑记录哪些节点、存储介质、性能、查询方式等问题。 7.8 Kafka 是否会消息丢失？ 只对“已提交”的消息做有限度的持久化保证 已提交的消息：消息写入日志文件 有限度的持久化保证：N 个 broker 至少一个存活 生产者丢失数据 producer.send(msg) 异步发送消息，不保证数据到达 Kafka producer.send(msg, callback) 判断回调 消费者程序丢失数据 应该「先消费消息，后更新位移的顺序」 新问题：消息的重复处理 多线程异步处理消息，Consumer 不要开启自动提交位移，应用程序手动提交位移 7.9 Kafka 如何持久化？ 消息日志（Log）保存数据，磁盘追加写（Append-only） 避免缓慢的随机 I&#x2F;O 操作 高吞吐 定期删除消息（日志段） 7.10 Kafka 文件存储机制 每个 partition 相当于一个巨型文件 → 多个大小相等 segment 数据文件中 每个 partition 只需要顺序读写就行了，segment 文件生命周期由配置决定 segment file 组成： index file：索引文件 data file：数据文件 segment file 文件命名规则： 全局第一个 segment 是 0 后序每个加上全局 partition 的最大 offset 一对 segment file message 物理结构 7.11 Kafka 分区为什么分区？ Kafka 的消息组织方式：主题-分区-消息 一条消息，仅存在某一个分区中 提高伸缩性，不同分区可以放到不同机器，读写操作也是以分区粒度 分区策略？ 轮询 随机 按 key 保序，单分区有序 7.12 MQ 消息堆积问题处理消息堆积可能的原因：队列中消息不能被及时的消费，导致大量堆积在队列里面rocketMq Kafka RabbitMq 都会有这样的问题产生消息堆积的可以从 mq 的生产消费模型去考虑，从生产者到消息中间件、再到消费者，都会发生堆积消费者：消费者处理速度过慢，或者消费者故障、延迟，无法即使的处理消息，导致消息堆积生产者：生产者产生速度过快，消费者无法即使处理MQ 消息队列：Mq 服务器的性能不足，比如它所在的机器，cpu、内存、磁盘等超载，无法即使的处理消息，导致消息堆积其他：其他方面也会有这样的问题， 比如网络故障，连接问题，消息在传递过程中过慢，从而导致消息堆积业务方面，消息消费失败重试，不断的重试，没有设置重试次数，导致消息堆积！。 处理消息堆积问题：一、消费者：1、增加消费者的数量，提高消费的处理速度；（注意这个不通用，只适合 RabbitMq）需要注意不能一味的水平扩展消费者因为其他关键链路性能是否抗的住大量的水平扩展，比如 mysq、redis，详细见下方 rabbitmq 消息堆积解决方案2、或者提高消费者的处理能力，比如通过并发处理、异步处理提高消费者吞吐量。这个则要注意通过线程池、队列，把 mq 拉到程序的队列中，要承担对应的宕机导致消息丢失风险。 二、MQ 消息队列：增加 MQ 的服务器资源，cpu、内存、磁盘，提高 mq 处理能力也可以通过分区队列将消息分散到多个队列中，提高整体的处理能力。（这个则是 Kafka、Rocket 采用的） 控制队列容量，避免堆积过多，设置持久化策略。rabbitMQ 的懒加载队列，兼顾了持久化和堆积上限 三、监控告警（重要）设置监控系统，比如普罗米修斯，监控消息数量，消费者处理速度，队列状态等等，在堆积发生前，即使的告警，及时采取措施。 But上面的策略是通用的一些解决方案，不同的 MQ，生产消费模型是不一样的，导致需要针对不同 mq 的消息堆积解决方案不一样。 RabbitMq、Kafka、RocketMq 发生消息堆积，分别该如何去解决？ 这里先点一下，增加消费者数量，并不是通用的，只适合 RabbitMq 8 总结Kafka 与 Pulsar 都是腾讯云主打的消息队列中间件，都具有高性能，高可靠，支持多种场景。Kafka 推出的时间较早，各种场景比如日志、大数据处理等都有较成熟的解决方案。而 Pulsar 作为一个新秀，支持的功能比 CKafka 更丰富，而且跨地域容灾，多租户等功能，解决了很多 Kafka 设计缺陷和运维成本问题，整体稳定性更强。很多国内外大公司也有很多 Pulsar 的实践案例。因此，一些传统的日志、大数据处理等场景，对高吞吐量有要求的，对消息可靠性的要求没那么高的，可以选用 Kafka，有很多优秀的文档说明怎么参数调优提高性能。而一些对消息可靠性、容灾要求更好，或者有高分区、延迟队列等需求的场景，可以选用 Pulsar。 我们后台的技术栈是基于 Golang 的，在上文的对比中，还挑了一个基于 Golang 开发的消息队列 NSQ，如果有一些定制化需求或者需要二次开发的，可以选用 NSQ。也可以通过阅读 NSQ 的源码，学习一些优秀高性能消息队列中间件的实现方式，比如里边 diskqueue 组件，一个基于磁盘的消息队列，在某些场景下可能也可以进行二次利用。 9 参考文献 10 分钟搞懂！消息队列选型全方位对比 Apache RocketMQ Domain Model 分布式实时消息平台 NSQ 消息队列基本原理和选型对比 技术选型 | 常用消息中间件 17 个维度全方位对比 消息队列如何选择 消息队列基本原理和选型对比 消息队列 20 年：腾讯专家沉淀的 MQ 设计精要 Kafka 文件存储机制那些事 消息队列原理和选型：Kafka、RocketMQ、RabbitMQ 和 ActiveMQ","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"架构","slug":"架构","permalink":"https://liangyuanzheng.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"消息队列","slug":"消息队列","permalink":"https://liangyuanzheng.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"km","slug":"km","permalink":"https://liangyuanzheng.com/tags/km/"},{"name":"系统设计","slug":"系统设计","permalink":"https://liangyuanzheng.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"kafka","slug":"kafka","permalink":"https://liangyuanzheng.com/tags/kafka/"},{"name":"后台","slug":"后台","permalink":"https://liangyuanzheng.com/tags/%E5%90%8E%E5%8F%B0/"},{"name":"分布式系统","slug":"分布式系统","permalink":"https://liangyuanzheng.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"pulsar","slug":"pulsar","permalink":"https://liangyuanzheng.com/tags/pulsar/"}]},{"title":"安全思想：漏洞防护","slug":"7-安全思想：漏洞防护","date":"2024-08-20T03:49:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"7-安全思想：漏洞防护.html","link":"","permalink":"https://liangyuanzheng.com/7-%E5%AE%89%E5%85%A8%E6%80%9D%E6%83%B3%EF%BC%9A%E6%BC%8F%E6%B4%9E%E9%98%B2%E6%8A%A4.html","excerpt":"","text":"安全思想：漏洞防护业务场景安全思想是指在设计、开发和维护计算机系统和网络时，将安全性作为首要考虑的原则和理念。它强调在整个系统生命周期中，从设计阶段到实施和运行阶段，都要考虑安全性，并采取相应的措施来保护系统免受恶意攻击和数据泄露的威胁。 案例⓵ Go 安全编码实践指南采用安全编码实践，可以提高应用程序的安全性，减少潜在的安全风险，并为用户提供更可靠和安全的体验。 本节内容摘自 OWASP 的 《Go-安全编码实践指南》 其他： 《OWASP 安全编码规范 快速参考指南》 《十大关键 API 安全风险》 CSRF 防御手册 RE2 《OWASP 低代码十大安全风险》 《2021 OWASP TOP 10》 ⓶ 业界安全事件分析与借鉴 时间 事件（点击链接可查看详情） 原因分析 我们的参考应对 2023&#x2F;4&#x2F;3 三星引入 ChatGPT 后疑似泄露公司资料 三星接入 ChatGPT 后有员工在使用过程中上传了源码和会议记录业界普遍怀疑 ChatGPT 可能收集对话数据用于训练迭代，可能会在其他对话中漏出 不泄露公司敏感信息，以免触碰高压线 1、不把工作代码贴进 ChatGPT 对话中 2、对话过程中不输入公司敏感信息与资料，如密码密钥、业务数据、财务数据、用户个人数据、未公开算法等 2023&#x2F;1&#x2F;4 黑客出售 2 亿 Twitter 用户个人资料 推测为根据 2022 年漏洞泄露的数据做整理 2022 年漏洞原因：twitter接口会根据传入的邮箱或手机号返回对应的 twitterID 1、API 设计应避免泄露用户个人数据，特别是对不需要做身份校验的接口 2023&#x2F;2&#x2F;12 45 亿条快递数据遭泄露 可能为快递&#x2F;电商平台等多个泄露源拼接而成，过往主要泄露原因包括： 1、API 接口漏洞导致泄露 2、内鬼泄露 3、云仓平台被植入木马后泄露 1、API 接口不返回多余信息；敏感 API 接口做严谨鉴权 2、内部人员权限按需最小化授予，管理平台限制导出条数 2023&#x2F;3&#x2F;20 ChatGPT 部分用户可查看他人聊天记录 所使用的redis python 客户端连接池存在 bug，对部分特殊场景的请求会错误分配到他人的处理连接，相应的返回他人的数据 1、保持使用最新版或安全版本的第三方软件，对提示有漏洞的版本及时升级修复 2、优先从内部软件源下载第三方组件，其次从软件官网 2023&#x2F;1&#x2F;15 俄罗斯科技巨头 Yandex 内部源代码泄露 员工离职前恶意下载和泄露源代码（twitter 3 月份也有员工泄露源码事件） 1、源码中不写入密钥密码等敏感数据，改为存放至七彩石或 KMS，收到类似风险提醒时切实修改，不随意忽略 2、公司对源码恶意下载和泄露有监控和审计溯源能力，建议团队内做好宣导，以免违规违法 2023&#x2F;3&#x2F;3 拼多多 app 利用漏洞恶意竞争被 google paly 下架 拼多多 app 中综合利用 android 低版本漏洞和手机厂商 OEM 代码漏洞，达到： 1、隐蔽安装，无法卸载 2、攻击竞争对手 App 3、窃取用户隐私数据 4、逃避隐私合规监管 1、业务程序中不利用漏洞实现业务目的，不违规收集用户隐私数据 更多安全指引，请参考 《漏洞防护》 小结谚云：防患于未然 安全思想和漏洞防护是保护计算机系统和网络安全的重要方面。通过将安全性纳入系统设计和开发的早期阶段，并采取相应的漏洞防护措施，我们可以降低系统遭受攻击的风险，保护用户的数据和隐私，确保系统的正常运行。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"安全思想：漏洞防护","slug":"99-其他","date":"2024-08-20T03:49:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"99-其他.html","link":"","permalink":"https://liangyuanzheng.com/99-%E5%85%B6%E4%BB%96.html","excerpt":"","text":"其他 8. 压缩：节省了 90% 的时间 9. 解耦：消息队列 10. 复用：设计模式 0. 优化程序结构：写出更简洁的代码 11. 存储：数据库优化 [[预处理|预处理]] [[索引|索引]] 0. 查询：搜索引擎 0. 深分页问题 [[SQL优化|SQL优化]] 11. 存储：数据库优化 0. 避免大事务 [[没加索引|没加索引]] [[索引没生效|索引没生效]] # 性能优化技巧 [[优化程序结构|优化程序结构]] 0. 优化程序结构：写出更简洁的代码 99. 编码规范 [[锁|锁]] [[锁粒度避免过粗|锁粒度避免过粗]] [并行化](1 Project&#x2F;腾讯&#x2F;智影&#x2F;浅析服务端优化&#x2F;智影：浅析后端接口优化实战（20240331）&#x2F;RPC（远程调用）：并行化) [[分库分表|分库分表]] [其他问题](1 Project&#x2F;腾讯&#x2F;智影&#x2F;浅析服务端优化&#x2F;智影：浅析后端接口优化实战（20240331）&#x2F;其他问题) [[选择合适的存储系统|选择合适的存储系统]]","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"池化思想：资源复用","slug":"6-池化思想：资源复用","date":"2024-08-15T08:41:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"6-池化思想：资源复用.html","link":"","permalink":"https://liangyuanzheng.com/6-%E6%B1%A0%E5%8C%96%E6%80%9D%E6%83%B3%EF%BC%9A%E8%B5%84%E6%BA%90%E5%A4%8D%E7%94%A8.html","excerpt":"","text":"池化思想：资源复用业务场景连接池（Connection Pool）是创建和管理连接的缓冲池技术。 连接池的原理是通过预先创建一定数量的连接对象，并将其保存在池中。当需要使用连接时，从池中获取一个可用的连接对象，使用完毕后归还给池，而不是每次都创建和销毁连接对象。这样可以避免频繁地创建和销毁连接对象，提高系统性能和资源利用率。 常见的连接池有：数据库连接池（ go-redis 连接池、go-orm 连接池）、线程池（Go 协程池 ants）、HTTP 连接池等。 通常，连接池包含以下几个关键组件： 连接池管理器：负责创建、初始化和管理连接池。 连接对象池：保存连接对象的容器，提供获取和归还连接对象的方法。 连接对象：表示与资源（如数据库、线程、HTTP 服务器）的连接。 连接池的工作流程如下： 初始化连接池：创建一定数量的连接对象，并将其保存在连接对象池中。 获取连接：当需要使用连接时，从连接对象池中获取一个可用的连接对象。 使用连接：使用获取到的连接对象进行相应的操作，如执行数据库查询、执行线程任务、发送 HTTP 请求等。 归还连接：使用完毕后，将连接对象归还给连接对象池，使其可供其他请求使用。 销毁连接：当连接池不再需要时，可以销毁连接对象，释放资源。 案例⓵ go-redis 连接池总览下连接池的核心代码结构，go-redis 的连接池实现分为如下几个部分： 连接池初始化、管理连接 建立与关闭连接 获取与放回连接，核心实现 Get、Put 监控统计 &amp;&amp; 连接保活配置 图：go-redis连接池的基本流程 原理可参考：《Go-Redis 连接池（Pool）源码分析》 小结总的来说，连接池是一种有效管理和复用连接的技术，它可以提高性能、节省资源、控制连接数、提高可靠性，并简化应用程序的编程。在高并发的场景下，使用连接池是一种常见的优化手段。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"空间换时间思想：降低耗时","slug":"5-空间换时间思想：降低耗时","date":"2024-08-14T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"5-空间换时间思想：降低耗时.html","link":"","permalink":"https://liangyuanzheng.com/5-%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E6%80%9D%E6%83%B3%EF%BC%9A%E9%99%8D%E4%BD%8E%E8%80%97%E6%97%B6.html","excerpt":"","text":"空间换时间思想：降低耗时业务场景空间换时间思想是一种常见的优化策略，它通过增加额外的空间（内存、缓存等）来减少程序的执行时间。这种思想的基本原理是通过预先计算、缓存或索引等方式，将计算或数据存储在更快的存储介质中，以减少访问时间和计算时间。这样可以避免重复计算或频繁的磁盘访问，从而提高程序的执行效率。 案例缓存优化是性能优化中的一个重要环节，它可以显著提高系统的响应速度和吞吐量。常见的应用有： 分布式缓存：Redis、Memcached 本地缓存组件：bigcache 小结谚云：彼亦一是非，此亦一是非 使用缓存虽然可以提升服务端性能和用户体验，但是也会带来其他问题，如数据一致性问题。还有缓存雪崩、缓存穿透、缓存并发、缓存无底洞、缓存淘汰等问题。 Every coin has two sides。对于上述的缓存应用，可以根据自身的业务场景和系统架构进行选择和组合。以解决业务主要矛盾，不引入新问题为要。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"并行思想：提升处理效率","slug":"4-并行思想：提升处理效率","date":"2024-08-07T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"4-并行思想：提升处理效率.html","link":"","permalink":"https://liangyuanzheng.com/4-%E5%B9%B6%E8%A1%8C%E6%80%9D%E6%83%B3%EF%BC%9A%E6%8F%90%E5%8D%87%E5%A4%84%E7%90%86%E6%95%88%E7%8E%87.html","excerpt":"","text":"并行思想：提升处理效率业务场景并行思想是一种同时执行多个任务或操作的方法，以提高系统的处理能力和效率。在并行思想中，任务被分解为多个子任务，并且这些子任务可以同时执行，充分利用多核处理器或分布式系统的资源。 案例⓵ 并发合成字幕 &amp; 上传 cos智影极速版剪辑器生成视频时，我们会把字幕轨道先合成一个字幕文件并上传到 cos：因为生成 srt 字幕后还要上传，若串行执行的话，当字幕轨道比较多的时候（比如 10 个）最终的耗时可能就会比较长了。这时，并行处理就能极大地提升效率： 主要使用了 errgroup 这个包，伪代码： 1234567891011121314151617181920212223242526272829package subtitleimport (true\"context\"true\"golang.org/x/sync/errgroup\")// TracksAsSrt 轨道转字幕func TracksAsSrt(ctx context.Context, tracks []*Track) (err error) &#123;trueeg := errgroup.Group&#123;&#125;truefor i := range tracks &#123;truetruetrack := tracks[i]truetrueeg.Go(func() error &#123;truetruetrue// 生成当前字幕轨的字幕文件名truetruetruefilename := GetSrtFilename(track)truetruetrue// 把轨道转为字幕truetruetruesrt := ConvertTrackToSrt(track)truetruetrue// 把字幕上传到 costruetruetrueif _, err = tools.NewSrtCosHelper().Upload(ctx, filename, srt); err != nil &#123;truetruetruetruereturn errtruetruetrue&#125;truetruetruereturn niltruetrue&#125;)true&#125;truereturn eg.Wait()&#125; 性能对比： 简单起见，逻辑处理部分的耗时用 sleep 模拟。 file.go： 1234567891011121314151617181920212223// TracksAsSrtSingle 轨道转字幕（串行）func TracksAsSrtSingle(ctx context.Context, tracks Tracks) (err error) &#123;truefor i := range tracks &#123;truetruei = itruetrue// 模拟耗时truetruetime.Sleep(100 * time.Millisecond)true&#125;truereturn nil&#125;// TracksAsSrtBatch 轨道转字幕（并行）func TracksAsSrtBatch(ctx context.Context, tracks Tracks) (err error) &#123;trueeg := errgroup.Group&#123;&#125;truefor i := range tracks &#123;truetruei = itruetrueeg.Go(func() error &#123;truetrue // 模拟耗时truetruetruetime.Sleep(100 * time.Millisecond)truetruetruereturn niltruetrue&#125;)true&#125;truereturn eg.Wait()&#125; 压测结果符合预期：并行 10 个的话，性能提升 10 倍： 12345678cpu: VirtualApple @ 2.50GHzBenchmarkTracksAsSrtSingleBenchmarkTracksAsSrtSingle-10 1 1003969084 ns/op 2410792 B/op 19474 allocs/opcpu: VirtualApple @ 2.50GHzBenchmarkTracksAsSrtBatchBenchmarkTracksAsSrtBatch-10 10 100319896 ns/op 226600 B/op 2026 allocs/op 细心的读者已经发现，通过并行处理也能变相地实现批量。不一定非要被下游服务提供一个批量接口（2. 批量思想：解决 N+1 问题）。 小结谚云：人多力量大 在现代操作系统中，我们可以很方便地编写出多进程的程序。多进程间的通信是需要重点考虑的事项之一，这种通信方式叫作 IPC（Inter- Process Communication）。 在 Linux 操作系统中可以使用的 IPC 方法有很多种。从处理机制的角度看，它们可以分为： 并发这个概念由来已久，主要思想是使多个任务可以在同一个时间段内执行，以便能够更快地得到结果。 Go 最明显的优势在于拥有基于多线程的并发编程方式。协程有风险，使用须谨慎。协程不是越多越好，当可能出现大量 goroutine 时，可以考虑使用协程池对其管理。ants 是一个高性能且低损耗的 goroutine 池。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"异步思想：解决长耗时的问题","slug":"3-异步思想：解决长耗时的问题","date":"2024-08-06T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"3-异步思想：解决长耗时的问题.html","link":"","permalink":"https://liangyuanzheng.com/3-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%EF%BC%9A%E8%A7%A3%E5%86%B3%E9%95%BF%E8%80%97%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98.html","excerpt":"","text":"异步思想：解决长耗时问题异步思想是一种解决长耗时问题的方法，它通过将耗时的操作放在后台进行，不阻塞主线程或其他任务的执行，从而提高系统的响应性能和并发处理能力。 业务场景在处理一些复杂的业务场景时，对于部分操作考虑使用异步，可以大幅降低接口耗时。 比如，在做服务性能优化时，可以将如数据上报、流水日志等做异步处理，以降低接口时延。用户上传图片后的审核，音视频的合成等等。 案例⓵ 子过程改异步、协程以文本配音（TTS）为例，【合成音频】和【添加音效】这两个子过程耗耗时比较长： 我们可以把耗时长的部分封装到一个异步任务中，并生成一个任务 ID，后续可以查询处理进度和结果。音频生成部分改为异步任务是因为该子过程是文本配音的关键路径（主流程、耗时长），对非关键路径如【数据埋点】直接改为协程处理即可： ⓶ 异步在数据库、消息队列的应用异步处理在数据库中同样应用广泛，例如 Redis 的 bgsave，bgrewriteof 就是分别用来异步保存 RDB 跟 AOF 文件的命令，bgsave 执行后会立刻返回成功，主线程 fork 出一个线程用来将内存中数据生成快照保存到磁盘，而主线程继续执行客户端命令；Redis 删除 key 的方式有 del 跟 unlink 两种，对于 del 命令是同步删除，直接释放内存，当遇到大 key 时，删除操作会让 Redis 出现卡顿的问题，而 unlink 是异步删除的方式，执行后对于 key 只做不可达的标识，对于内存的回收由异步线程回收，不阻塞主线程。 MySQL 的主从同步支持异步复制、同步复制跟半同步复制。异步复制是指主库执行完提交的事务后立刻将结果返回给客户端，并不关心从库是否已经同步了数据；同步复制是指主库执行完提交的事务，所有的从库都执行了该事务才将结果返回给客户端；半同步复制指主库执行完后，至少一个从库接收并执行了事务才返回给客户端。有多种主要是因为异步复制客户端写入性能高，但是存在丢数据的风险，在数据一致性要求不高的场景下可以采用，同步方式写入性能差，适合在数据一致性要求高的场景使用。 此外，对 Kafka 的生产者跟消费者都可以采用异步的方式进行发送跟消费消息，但是采用异步的方式有可能会导致出现丢消息的问题。对于异步发送消息可以采用带有回调函数的方式，当发送失败后通过回调函数进行感知，后续进行消息补偿。 小结一些常见的异步编程方式有： 需要注意的是，异步并没有缩短整体的响应时间，反而可能有所增加。异步编程有优点也有缺点，可根据自身业务选型： 优点： 提高系统的响应性能：异步编程可以避免长耗时操作阻塞主线程或其他任务的执行，从而提高系统的响应速度和用户体验。通过将耗时操作放在后台进行，主线程可以继续执行其他任务，不必等待操作的完成。 提高并发处理能力：异步编程可以与其他任务并发执行，充分利用系统资源，提高系统的并发处理能力。通过将多个任务同时进行，可以减少总体的处理时间，提高系统的吞吐量。 节省资源消耗：异步编程可以减少不必要的资源消耗。通过将耗时操作放在后台进行，可以避免占用过多的 CPU 时间和内存资源，提高系统的资源利用率。 提高代码的可读性和维护性：异步编程可以使代码更加简洁和易于理解。通过使用异步&#x2F;等待或 Promise 等编程模式，可以以同步的方式编写异步代码，提高代码的可读性和维护性。 支持并行计算和分布式处理：异步编程可以支持并行计算和分布式处理。通过将任务分解为多个子任务，并使用多线程、分布式计算或 GPU 并行计算等技术，可以实现高效的并行计算和数据处理。 提高系统的可扩展性：异步编程可以提高系统的可扩展性。通过将任务分发给多个处理单元或节点进行并行处理，可以实现分布式的并发处理和负载均衡，提高系统的可扩展性和性能。 缺点： 复杂性增加：异步编程涉及到回调函数、Promise、异步&#x2F;等待等概念和技术，对于初学者来说可能会增加学习和理解的难度。 错误处理复杂：异步编程中的错误处理可能会更加复杂，需要处理回调函数中的错误、Promise 链中的异常等情况，增加了代码的复杂性。 可能引发竞态条件：在并发环境下，异步编程可能会引发竞态条件（Race Condition）和数据一致性的问题，需要额外的并发控制和数据同步机制来解决。 调试困难：由于异步编程中任务的执行顺序和时间不确定，调试异步代码可能会更加困难，需要使用适当的调试工具和技术。 可能导致回调地狱：在复杂的异步操作中，使用回调函数可能会导致回调地狱（Callback Hell），使代码难以理解和维护。这可以通过使用 Promise、异步&#x2F;等待等技术来缓解。 综上所述，异步编程具有许多优点，可以提高系统的性能和响应能力。然而，它也存在一些缺点，需要在设计和实现中注意解决相关的问题。合理地应用异步编程，可以最大程度地发挥其优点，减少其缺点的影响。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"批量思想：解决 N+1 问题","slug":"2-批量思想：解决-N-1-问题","date":"2024-08-06T08:25:00.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"2-批量思想：解决-N-1-问题.html","link":"","permalink":"https://liangyuanzheng.com/2-%E6%89%B9%E9%87%8F%E6%80%9D%E6%83%B3%EF%BC%9A%E8%A7%A3%E5%86%B3-N-1-%E9%97%AE%E9%A2%98.html","excerpt":"","text":"批量思想：解决 N+1 问题业务场景N+1 查询问题指的是当查询一个对象的列表数据的时候，会首先查询列表中的对象的 ID，然后循环生成单独的 SQL/RPC 去查询对象的详细数据。这会导致 SQL/RPC 查询过多问题。 在一个循环内多次执行 RPC 调用或者数据库操作。数据量小的时候问题不大，能跑起来。随着业务的发展，数据量越来越大，或者要查询的 id 越来越多（特别是未加限制的时候），耗时部题可想而知，长尾会越来越多。 案例⓵ 循环中的 RPC读取多条记录时在 for 循环中去分别读取单行。 1234for _, id := range ids &#123; record := GetDetail(id) // do something ...&#125; 解决方案：改批量（一次从存储中取出所有 id 的结果） 12records := GetDetails(ids)// do something ... 小结谚云：积羽沉舟，群轻折轴 上述场景是一个典型的 N+1 问题，不限于读取，写入亦然。它可能导致性能问题和增加数据库负载。 为了解决 N+1 问题，开发人员可以使用一些技术，如批量加载（batch loading)、批量更新（Bulk Updates），从而减少请求次数。通过优化数据库查询和加载策略，开发人员可以避免 N+1 问题，并提高应用程序的效率。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"防御性设计：验证","slug":"1-防御性设计：验证","date":"2024-08-06T07:04:00.000Z","updated":"2025-10-27T00:35:41.787Z","comments":true,"path":"1-防御性设计：验证.html","link":"","permalink":"https://liangyuanzheng.com/1-%E9%98%B2%E5%BE%A1%E6%80%A7%E8%AE%BE%E8%AE%A1%EF%BC%9A%E9%AA%8C%E8%AF%81.html","excerpt":"","text":"防御性设计：验证业务场景在日常开发中，尤其是在 web 应用开发中，我们经常需要对数据的合法性进行验证。为了实现这一目的，我们通常会对参数进行一些前置验证。这些验证规则可以包括必填项、范围、格式、正则表达式、安全性以及自定义规则等。 通常，为简化业务逻辑，我们会借助一些第三方工具来进行这些通用性的检测。 案例⓵ Protocol Buffer Validation如果是基于 pb 协议，可以启用 protoc-gen-validate (PGV) 自动化数据校验插件。配置规则如：强校验 title 字段长度在 1 ～ 100 个字符： 1string title = 1 [(validate.rules).string = &#123;min_len: 1, max_len: 100 &#125;]; 一般地，保存数据库之前，为防止溢出，可对其长度做前置检查。 《约束规则》支持的类型有 Numerics、Bools、Strings、Bytes、Enums、Messages、Repeated、Maps 等。 tRPC 服务时，请参考《tRPC Validation，让 RPC 框架自动做数据校验》 ⓶ Go Struct and Field validation对于非 pb 定义的结构，也有一些类似的组件实现自动化校验。如 Go Struct and Field validation ，基本用法如下： 12345678910// User contains user informationtype User struct &#123;trueFirstName string `validate:\"required\"`trueLastName string `validate:\"required\"`trueAge uint8 `validate:\"gte=0,lte=130\"`trueEmail string `validate:\"required,email\"`trueGender string `validate:\"oneof=male female prefer_not_to\"`trueFavouriteColor string `validate:\"iscolor\"` // alias for 'hexcolor|rgb|rgba|hsl|hsla'trueAddresses []*Address `validate:\"required,dive,required\"` // a person can have a home and cottage...&#125; 详细参考 《常用的验证》。如果预置的 valadator 不满足需求，也可以自定义 validator。 小结谚云：防御不到位，上线跑断腿 防御性设计是考虑使用者可能会错误使用的情况，从设计上避免错误使用，或是降低错误使用的机会。防御性设计可以让软件更安全、可靠，更方便地找到使用者的错误。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"浅析服务端优化-前言","slug":"0-前言","date":"2024-08-05T16:00:00.000Z","updated":"2025-10-27T00:35:41.787Z","comments":true,"path":"0-前言.html","link":"","permalink":"https://liangyuanzheng.com/0-%E5%89%8D%E8%A8%80.html","excerpt":"","text":"写在前面性能优化是软件项目开发过程中的一个永恒话题。 随着功能迭代，复杂度不断增加，同时伴随着流量、数据不断增长，接口性能可能会逐渐下降，尤其是在高并发场景，性能问题就更容易暴露出来。这时，我们也不能闲着。开始翻古书、找资料、访道友，不断提升，慢慢练成属于自己的七十二绝技。 本文主要总结了日常开发中一些通用的优化手段，以期对日后的开发有所裨益。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://liangyuanzheng.com/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://liangyuanzheng.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://liangyuanzheng.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"《三字经》章炳麟·清","slug":"20240727-《三字经》","date":"2024-08-02T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240727-《三字经》.html","link":"","permalink":"https://liangyuanzheng.com/20240727-%E3%80%8A%E4%B8%89%E5%AD%97%E7%BB%8F%E3%80%8B.html","excerpt":"","text":"《三字经》 章炳麟·清 人之初，性本善。性相近，习相远。苟不教，性乃迁。教之道，贵以专。昔孟母，择邻处。子不学，断机杼。窦燕山，有义方。教五子，名具扬。养不教，父之过。教不严，师之惰。子不学，非所宜。幼不学，老何为。玉不琢，不成器。人不学，不知义。为人子，方少时，亲师友，习礼仪。香九龄，能温席；孝于亲，所当执。融四岁，能让梨，弟于长，宜先知。首孝弟，次见闻，知某数，识某文。一而十，十而百。百而千，千而万。三才者，天地人。三光者，日月星。三纲者，君臣义，父子亲，夫妇顺。曰春夏，曰秋冬，此四时，运不穷。曰南北，曰西东，此四方，应乎中。曰水火，木金土，此五行，本乎数。曰仁义，礼智信，此五常，不容紊。稻粱菽，麦黍稷，此六谷，人所食。马牛羊，鸡犬豕（shǐ），此六畜，人所饲。曰喜怒，曰哀惧，爱恶欲，七情惧。匏土革，木金石，丝与竹，乃八音。高曾祖，父而身，身而子，子而孙。自子孙，至玄曾，乃九族，人之伦。父子恩，夫妇从，兄则友，弟则恭。长幼序，友与朋，君则敬，臣则忠。此十义，人所同。凡训蒙，须讲究。详训诂，明句读。为学者，必有初。小学终，至四书。《论语》者，二十篇。群弟子，记善言。《孟子》者，七篇止，讲道德，说仁义。作《中庸》，子思笔；中不偏，庸不易。作《大学》，乃曾子；自修齐，至平治。《孝经》通，四书熟，如六经，始可读。《诗》《书》《易》《礼》《春》《秋》，号六经，当讲求。有《连山》，有《归藏》，有《周易》，三《易》详。有典谟，有训诰，有誓命，《书》之奥。我周公，作《周礼》，著六官，存治体。大小戴，注《礼记》，述对言，礼乐备。曰《国风》，曰《雅》《颂》，号四诗，当讽咏。《诗》既亡，《春秋》作，寓褒贬，别善恶。三传者，有《公羊》，有《左氏》，有《穀（gǔ）梁》。经既明，方读子，撮（cuō）其要，记其事。五子者，有荀扬，文中子，及老庄。经子通，读诸史，考世系，知终始。自羲（xī）农，至黄帝，号三皇，居上世。唐有虞，号二帝，相揖逊，称盛世。夏有禹，商有汤，周文武，称三王。夏传子，家天下，四百载，迁夏社。汤伐夏，国号商，六百载，至纣亡。周武王，始诛纣。八百载，最长久。周辙东，王纲坠，逞干戈，尚游说。始春秋，终战国，五霸强，七雄出。赢秦氏，始兼并，传二世，楚汉争。高祖兴，汉业建，至孝平，王莽篡。光武兴，为东汉，四百年，终于献。魏蜀吴，争汉鼎，号三国，迄两晋。宋齐继，梁陈承，为南朝，都金陵。北元魏，分东西，宇文周，与高齐。迨（dài）至隋，一土宇，不再传，失统绪。唐高祖，起义师，除隋乱，创国基。二十传，三百载，梁灭之，国乃改。炎宋兴，受周禅，十八传，南北混。十七史，全在兹。载治乱，知兴衰。读史者，考实录，通古今，若亲目。口而诵，心而惟，朝于斯，夕于斯。昔仲尼，师项橐（tuó）。古圣贤，尚勤学。赵中令，读《鲁论》，彼既仕，学且勤。披蒲（pú）编，削竹简，彼无书，且知勉。头悬梁，锥刺骨，彼不教，自勤苦。如囊萤，如映雪，家虽贫，学不辍。如负薪，如挂角，身虽劳，犹苦卓（zhuó）。苏老泉，二十七，始发愤，读书籍。彼既老，犹悔迟，尔小生，宜早思。若梁灏，八十二，对大廷，魁（kuí）多士。彼既成，众称异，尔小生，宜立志。莹八岁，能咏诗。泌七岁，能赋棋。彼颖悟，人称奇，尔幼学，当效之。蔡文姬，能辨琴；谢道韫，能咏吟。彼女子，且聪敏，尔男子，当自警。唐刘晏，方七岁，举神童，作正字。彼虽幼，身已仕，尔幼学，勉而致。有为者，亦若是。犬守夜，鸡司晨。荀不学，曷（hé）为人。蚕吐丝，蜂酿蜜。人不学，不如物。幼而学，壮而行。上致君，下泽民。扬名声，显父母。光于前，裕于后。人遗子，金满籯（yíng）。我教子，唯一经。勤有功，戏无益，戒之哉，宜勉力！","categories":[{"name":"诗词歌赋","slug":"诗词歌赋","permalink":"https://liangyuanzheng.com/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"诗词","slug":"诗词","permalink":"https://liangyuanzheng.com/tags/%E8%AF%97%E8%AF%8D/"}]},{"title":"《大秦帝国》","slug":"《大秦帝国》","date":"2024-07-31T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"《大秦帝国》.html","link":"","permalink":"https://liangyuanzheng.com/%E3%80%8A%E5%A4%A7%E7%A7%A6%E5%B8%9D%E5%9B%BD%E3%80%8B.html","excerpt":"","text":"日期 备注 2022 忘记是从哪天开始看了的，大概是 2022 年吧。 2024-08-01 开始整理整理笔记。 兵谚云：”一将不良，窝死千军。” 孔夫子将人生划分了五重境界：”三十而立，四十而不惑，五十而知天命，六十而耳顺，七十从心所欲不愈矩。” 扁鹊行医有了六不治：骄横不论于理者不治，轻身重财者不治，酒食无度不听医谏者不治，放纵阴阳不能藏气者不治，羸弱不能服药者不治，信巫不信医者不治。这六不治中，“信巫不信医”这条最为要紧。 《素问》云，好哭者病肺，好歌者病脾，好妄言者病心，好呻吟者病肾，好怒吼者病肝。 大德恢恢，此心昭昭。 皎皎者易污，峣峣者易折。 箎（chí） 同”箎”，古代一种竹制管乐器。形状像笛子。 兕（sì） 古代犀牛一类的兽名。一说雌性犀牛。皮厚，可制甲。 訇（hōng） 拟声词。形容很大的声音。 【阿訇】波斯语音译。指伊斯兰主持教仪、讲授经典的人。 轺（yáo） 轺车，古代一种轻便的小车。 军车。 谝（piǎn） 欺骗；诈骗。 花言巧语。 夸耀；向别人显示。 袂（mèi） 衣袖。 耒（lěi） 古代农具，形状像木叉。 古代翻土农具耜上的曲柄。 耜（sì） 古代家具耒下端铲土的部分， 隰（xí） 地势低洼而潮湿的地方。 商鞅变法时期，为了稳定西部戎狄，秦国采取了”三十年不变西族”的国策，与戎狄维持了一段井水不犯河水的岁月。 啻（chì） （书）副词。只：仅。 大事赖独断而不赖众谋。 鳏（guān） 无妻或丧妻的男子。 畿（jī），国都附近的地区：京畿，畿辅。 洫（xù） 田间水道。 泛指河渠。 护城河。 罃（yīng） 古代盛灯油的壶。 国让利于民，民忠心于国。 岘（xiàn） 岘山，山名。在湖北。又名岘首山。 人之能，不仅在学，且在悟。悟之根本，不在少学，在难后重学。大难而有大悟，始得大成。 蓍（shī） 蓍草。多年生草本植物。茎直立，花白色。全草可入药，也可制香料。古人用它的茎占卦。也叫锯齿草、蚰蜒草。 燠（yù） 热；暖。 唾（tuò） 口液；唾沫。 吐唾沫表示鄙弃。 吐。 溘（kè） 忽然；突然。 喟（kuì） 叹息。 救苍生于万一，挽狂澜于既倒。 桔（jú）槔（gāo） 桔槔俗称“吊杆”“称杆”，古代汉族农用工具。是一种原始的汲水工具。商代在农业灌溉方面，开始采用桔槔。 涔（cén） 【涔涔】（雨、泪、血、汗等）不断流出或渗出。 魈（xiāo） 【山魈】猕猴的一种。四肢粗壮，蓝脸红鼻。 传说中山里的独脚鬼怪。 羸（léi） 瘦；弱。挽狂澜于既倒，救楚国于危亡，英雄气度 满面风尘烟火色 盲人骑瞎马，夜半临深池。 出于苦难，成于板荡 仁政井田不可复，孔孟毕生求之。六国旧制不可救，苏秦全力救之。事虽相异，其理同一。也孟为天下求一’仁’，苏秦为天下求一’公’也。 粜（tiào） 卖粮食（跟”籴”相对） 茬（chá） 庄稼收割后留在地里的茎和根。 指在同一块地里作物种植或生长的次数。 短而硬的胡须、头发。 泛指事物发生的次数。 书不如思贵，意不可言传。说到底，是教人多思深思，切莫草草立言。 人生有年 冄（rǎn） 同”冉”，【冉冉】柔弱下垂的样子。 副词。慢慢地。 名相起于州部，猛将发于卒伍？ 大道不和于俗，大功不谋于众。 春风料峭的三月。 这是《墨子》开宗明义第一篇，名曰《亲士》，说的是正才大道。老夫方才所念，大要三层：其一，为臣为子者，当以功业正道自立，而不能希图明君慈父垂怜自己，若是依靠垂怜赏赐而得高位，最终也将一无所得。其二，要成正道，便得寻觅依靠有锋芒的国士人才，虽然难以驾驭，然却是功业根基。其三最为要紧，说的是天地万物皆有瑕疵，并非总是昭昭荡荡，大水有阴沟，大火有烟瘴，王道有阴谋。身为冲要人物，既不能因诸般瑕疵而陷入宵小之道，唯以权术对国事；又不能如箭矢般笔直，磨刀石般平板。只有正道谋事，才能博大宏阔伸展自如，才能亲士成事。最后是一句警语：但为王者，其才能若不能施展于王城之外的治国大道，功业威望便不能覆盖邦国，立身立国便是空谈！ 义者，百事之始也，万利之本也，中智所不及也。 战国四大公子者，信陵君魏无忌（魏国），孟尝君田文（齐国）、平原君赵胜（赵国）、春申君黄歇（楚国）也。四人当年与苏秦、张仪斡旋于合纵连横，从此成风支这士，天下呼为”四大公子”。 立秋之日，最在的忌讳是雷、雨、风。中原三谚说的便是这三样禁忌。一云：”立秋一雷，晚禾折半。”二云：”雨打立秋，多涝不收。”三云：”秋日一风，田土干底。”年年岁岁立秋日，朝野臣民盼的自是个风和日丽。 强国之道无奇术，荒诞之谋不济邦。 记住了：”雪后冰凌道，只看草出雪，莫看土过冰。” 名家“二十一事”：其一，卵有毛。其二，鸡三足。其三，郢有天下。其四，犬可以为羊。其五，马有卵。其七，火不热。其八，山出口。其九，轮不碾地。其十，目不见。十二，龟长于蛇。十三，矩不方，规不可以为圆。十四，凿不围枘。十五，飞鸟之影未尝动也。十六，镞矢之疾，而有不行不止之时。十七，狗非犬。十八，黄马骊牛三。十九，白狗黑。二十，孤驹未尝有母。二十一，一尺之椎，日取其半，万世不竭。 路有诽谤木，朝有敢谏鼓。 积微，月不胜日，时不胜月，岁不胜时。凡人好敖慢小事，大事至，然后兴之务之。如是，则常不胜夫敦比于小事者矣！何也？小事之至也数，其悬日也博，其为积也大。大事之至也希，其悬日也浅，其为积也小。故善日者王，善时者霸，补漏者危，大荒者亡！故，王者敬日，霸者敬时，仅存之国危而后戚之。亡国至亡而后知亡，至死而后知死，亡国之祸败，不可胜悔也。霸者之善著也，可以时托也。王者之功名，不可胜日志也。财物货宝以大为重，政教功名者反是，能积微者速成。诗曰：“德如毛，民鲜能克举之。”此之谓也。——《荀子》 何为见识？发乎常人之不能见者，是谓见识。荀子的“积微速成”说，不是寻常的决事见识，而是一种方法之论，一种确立功业路径的法则之论。 这便是秦国朝会的不成文的规矩，当某种主张只剩一个人坚持的时候，坚持者即或依然不服，也不再做反复论争；战时论事，大臣们都明白”事终有断”这个道理，诸多各有说法的大道理若无休止地争下去，任何一件事也做不成。 后世史家对魏国灭亡的评论揣测很少，原因也在于魏国灭亡的必然性最确定，只有教训可以借鉴，没有秘密可资研究。《史记·魏世家》之后有四种评论，大约可说明这种简单明了。 长期地缓贤忘士，而最终导致亡国。 无论天意如何，失才便要亡国。越是竞争激烈的大争之世，这一结局的表现方式便越是酷烈。 墨家的人才理论有三个基本点：第一是”亲士急贤”。第二是”众贤厚国”。第三是”尚贤乃为政之本”理念。墨子的人才理论，实在具有千古不朽的意义。 帝国新官制的总体风貌，完全体现了李斯对始皇帝阐术的总纲：以郡县治为根基，以集权治为宗旨，以施政治民为侧重，以治权集中于中央为轴心。在此明白无误的总纲之下，帝国新官制从上到下建立了一个完整的施政体系。这一施政体系分为四级系统，层层辖制，从皇帝宫殿直到村畴乡野，一体纳入治道。其一，中央决策系统：皇帝系统。其二，中央政务系统：以丞相为轴心的三公九卿系统。三公是指：丞相、太尉、御史大夫。三公之下为九卿。九卿者，分别执掌九在领域之施政系统也。九卿在三公（主要在丞相）领导之下施政，以保不政出多门。九卿之中，五卿隶属皇帝系统，四卿隶属三公系统。三公这四卿为：廷尉（执法机构，设左监，右监，狱正三署，侧重受命于御史大夫府），治粟内史（以原大田令府扩大而设，掌经济民生诸事，隶属丞相系统），典客（以原行人署、属邦署合并扩大，掌邦交并边陲部族事务，隶属丞相府），少府（以原关市、邦司空等署合并扩大而设，掌国家赋税，设六丞，隶属丞相府）。其三，郡县施政系统：郡守县令为轴心的地方系统。其四，为乡官系统：最基层的三级民治——乡、亭、里。里，相当于后世的村。十里一亭，设亭长。十亭一乡，乡官，以三老为最尊。所谓三老，本指上寿（百二十岁）、中寿（百岁）、下寿（八十岁）三种老人。大致是八十岁上下的三位老人，执掌民风民俗教化。 见事贵见缺，说说甚缺憾？ 箫何不过有心，记下了听到见到的每一笔帐而已。你若还想细究，萧何可以给你讲几千几百个血泪故事。 使耕者有其田，民得以温饱也！ 飓风起于青萍之末。 古谚云：庙堂如丝，其出如纶。 儒家对待举发的“为大人隐，为亲友隐”的诸般教诲，竞相攀扯举发，一时人人无一事外。 《性恶篇》中反复论证的六则立论：一则，人性本恶，无可变更；二则，善者虚伪，不可相信；三则，利益争夺，人之天性；四则，人有恶欲，天经地义；五则，圣人小人，皆有恶欲；六则，圣贤礼义，积伪欺世，效法必败。 迅雷不及掩耳，飓风不及举步。 念兹在兹。 法治风暴的旋转轴心里，有一方法度无法制约的天地，这便是”成法立制，终决于人”的最高程式。 王翦的持重寡言，蒙恬的勃勃生气，五贲的简约直率，尉缭的精明思虑，郑国的就事论事，胡毋敬的略显迂阔……无论这些大臣们朝会之风如何，都有一个相同处，惊人的坚韧，惊人的固执己见，非反复论争而不能达到同一。 李斯此人以利为己为本，善变无情。 始皇帝为政，非但确实有亘古未闻的大器局，且精于聚天下之众力以成事，更有铁志雄心，善激发，善用人，善决断等等人难以企及的天赋秉性与才具聚于一身，所以谋大事无一不成。 善谋者未必成事，此之谓也。 青史悠悠 昔秦穆公人殉杀三良，罪黜百里奚，被天下呼为“缪”。秦昭王杀白起，楚平王杀伍奢，吴王夫差杀伍子胥，此四者，皆天下大失也！政谚云：用道治者不杀无罪，而罚不加于无辜。 蒙恬的意义，在于他是中国文明史上的一个突出标志。只有秦帝国的劳改大军，在长达千余年对匈奴作战中真正做到了摧枯拉朽，真正做到了秋风扫落叶，真正做到了苍鹰扑群雀。西汉盐铁会议之文献《盐铁论·伐功》篇云：”蒙公为秦击走匈奴，若鸷鸟追群雀。匈奴势慑，不敢南面而望十余年。” 华夏民族在强势生存传统中自古便有”兴亡大事不问卜”的理念，武王伐纣而姜太公踩啐占卜龟甲，乃典型例证也。 帝国创制，秦帝国之中央执法系统为五大机构：其一，延尉府职司勘审定罪，几类后世法院；其二，御史大夫职司举发监察弹劾等，几类后世检察院；其三，法官署职司宣法，几类后世司法局；其四，内史府职司京师治安捕盗并缉拿罪犯，几类后世公安机构；其五，宗正府执掌对皇族之执法权，是执法机构中最为特异的一个。 牝（pìn） 雌性的（跟“牡”相对）。 眚（shěng） 眼睛长白翳。 灾异。 过失。 粲（càn） 鲜亮的样子。 霜重雾浓寒风飕飕 商鞅有言，大事不赖众谋。 “项羽为人，剽悍猾贼！项羽尝攻襄城，襄城无遗类，皆坑之！诸所过之处，无不残灭！”剽者，抢动之强盗也；悍者，凶暴蛮横也；猾者，狡诈乱世也；贼者，虐害天下也，邪恶不走正道也。 始皇帝统一六国后，建造了十二座大型仓廪囤积天下粮草，并制定了专门法令——《仓律》实施治理，仓情分外整肃。这十二仓是：内史郡的霸上仓、内史郡的栎阳仓、内史郡的咸阳仓、三川郡的敖仓、砀郡的陈留仓、琅邪郡的琅邪仓、胶东郡的黄仓、临淄郡的腄仓、九原郡的北河仓、蜀郡的成都仓、南阳郡的宛仓、东郡的督道仓。十二仓中以敖仓规模最大，堪称秦帝国的国家粮食中心。 龃龉（jǔ yǔ） 上下牙齿对不齐，比喻意见不合，互相抵触。 缘木求鱼 以韩非《说难》，说君的轴心法则便是“非其人勿与语”——不是明君雄主，便不要与之谈论为政大道。 侔（móu） 等同。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"《增广贤文》","slug":"20240730-《增广贤文》","date":"2024-07-29T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240730-《增广贤文》.html","link":"","permalink":"https://liangyuanzheng.com/20240730-%E3%80%8A%E5%A2%9E%E5%B9%BF%E8%B4%A4%E6%96%87%E3%80%8B.html","excerpt":"","text":"日期 备注 2024-07-30 空闲时间手抄 2024-08-01 第一遍成。 《增广贤文》（上集）昔时贤文，诲汝谆谆。集韵增广，多见多闻。观今宜鉴古，无古不成今。知己知彼，将心比心。酒逢知己饮，诗向会人吟。相识满天下，知心能几人？相逢好似初相识，到老终无怨恨心。近水知鱼性，近山识鸟音。易涨易退山溪水，易反易复小人心。运去金成铁，时来铁似金。读书须用意，一字值千金。逢人且说三分话，未可全抛一片心。有意栽花花不发，无心插柳柳成荫。画龙画虎难画骨，知人知面不知心。钱财如粪土，仁义值千金。流水下滩非有意，白云出岫本无心。当时若不登高望，谁信东流海洋深？路遥知马力，日久见人心。两人一般心，无钱堪买金；一人一般心，有钱难买针。想见易得好，久住难为人。马行无力皆因瘦，人不风流只为贫。饶人不是痴汉，痴汉不会饶人。是亲不似亲，非亲却似亲。美不美，故乡水；亲不亲，故乡人。莺花犹怕春光老，岂可教人枉度春？相逢不饮空归去，洞口桃花也笑人。红粉佳人休使老，风流浪子莫教贫。在家不会迎宾客，出门方知少主人。黄金无假，阿魏无真。客来主不顾，自是无良宾。良宾方不顾，应恐是痴人。贫居闹市无人问，富在深山有远亲。谁人背后无人说，哪个人前不说人？有钱道真语，无钱语不真。不信但看筵中酒，杯杯先劝有钱人。闹里挣钱，静处安身。来如风雨，去似微尘。长江后浪推前浪，世上新人攒旧人。近水楼台先得月，向阳花木先逢春。古人不见今时月，今月曾经照古人。先到为君，后到为臣。莫道君行早，更有早行人。莫信直中直，须防仁不仁。山中有直树，世上无直人。自恨枝无叶，莫怨太阳偏。一切都是命，半点不由人。一年之计在于春，一日之计在于晨。一家之计在于和，一生之计在于勤。责人之心责己，恕己之心恕人。守口如瓶，防意如城。宁可人负我，切莫我负人。再三须慎意，第一莫欺心。虎身犹可近，人毒不堪亲。来说是非者，便是是非人。远水难救近火，远亲不如近邻。有酒有肉多兄弟，急难何曾见一人？人情似纸张张薄，世事如棋局局新。山中也有千年树，世上难逢百岁人。力微休负重，言轻莫劝人。无钱休入众，遭难莫寻亲。平生不做皱眉事，世上应无切齿人。士者国之宝，儒为席上珍。若要断酒法，醒眼看醉人。求人须求大丈夫，济人须济急时无。久住令人贱，频来新也疏。酒中不语真君子，财上分明大丈夫。出家如初，成佛有余。积金千两，不如明解经书。养子不教如养驴，养女不教如养猪。有田不耕仓廪虚，有书不读子孙愚。仓廪虚兮岁月乏，子孙愚兮礼仪疏。听君一席话，胜读十年书。人不通今古，马牛如襟裾。茫茫四海人无数，哪个男儿是丈夫？白酒酿成缘好客，黄金散尽为收书。救人一命，胜造七级浮屠。城门失火，殃及池鱼。庭前生瑞草，好事不如无。欲求生富贵，须下死工夫。百年成之不足，一旦环之有余。人心似铁，官法如炉。善化不足，恶化有余。水至清则无鱼，人太急则无智。知者减半，愚者全无。在家由父，出嫁从夫。痴人畏妇，贤女敬夫。是非终日有，不听自然无。竹篱芧舍风光好，道院僧房终不如。宁可正而不足，不可邪而有余。宁可信其有，不可信其无。命里有时终须有，命里无时莫强求。道院迎仙客，书堂隐相儒。庭栽栖凤竹，池养化龙鱼。结交须胜己，似我不如无。但看三五日，相见不如初。人情似水分高下，世事如云任卷舒。会说说都是，不会说无理。磨刀恨不利，刀利伤人指；求财恨不多，财多害自己。知足常足，终身不辱；知止常止，终身不耻。有福伤财，无福伤己。差之毫厘，失之千里。若登高必自卑，若涉远必自迩。三思而行，再思可矣。动口不如亲为，求人不如求己。小时是兄弟，长大各乡里。嫉财莫嫉食，怨生莫怨死。人见白头嗔，我见白头喜。多少水牛郞，不到白头死。墙有缝，壁有耳。好事不出门，坏事传千里。若要人不知，除非己莫为。为人不做亏心事，半夜敲门心不惊。贼是小人，智过君子。君子固穷，小人穷斯滥矣。富贵多忧，贫穷自在。不以我为德，反以我为仇。宁可直中取，不可曲中求。人无远虑，必有近忧。知我者谓我心忧，不知我者谓我何求？睛天不肯去，直待雨淋头。成事莫说，覆水难收。是非只为多开口，烦恼皆因强出头。忍得一时气，免得百日忧。近来学得乌龟法，得缩头时且缩头。惧法朝朝乐，欺公日日忧。人生一世，草长一春。黑发不知勤学早，转眼便是白羊翁。月过十五光明少，人到中年万事休。儿孙自有儿孙福，莫为儿孙做马牛。人生不满百，常怀千岁忧。今朝有酒今朝醉，明日愁来明日忧。路逢险处须回避，事到临头不自由。人贫不语，水平不流。一家养女百家求，一马不行百百忧。有花方酌酒，无月不登楼。三杯通大道，一醉解千愁。深山毕竟藏猛虎，大海终须纳细流。惜花须检点，爱月不梳头。大抵选她肌骨好，不搽红粉也风流。受恩深处宜先退，得意浓时反为仇。莫待是非来入耳，从前恩爱反为仇。休别有鱼处，莫恋浅滩头。去时终须去，再三留不住。忍一句，息一怒，饶不着，退一步。三十不豪，四十不富，五十将来寻死路。生不认魂，死不认尸。父母恩深终有别，夫妻义重也分离。人生似鸟同林宿，大难来时各自飞。人善被人欺，马善被人骑。人无横财不富，马无夜草不肥。人恶人怕天不怕，人善人欺天不欺。善恶到头终有报，只盼早到与来迟。黄河尚有澄清日，岂能人无得运时？得宠思辱，居安思危。念念有如临敌日，心心常似过桥时。英雄行险道，富贵似花枝。分公司莫道春光好，只怕秋来有冷时。送君千里，终有一别。但将冷眼观螃蟹，看它横行到几时！见事莫说，问事不知。闲事莫管，无事早归。假缎染就真红色，也被旁人说是非。善事可做，恶事莫为。许人一物，千金不移。龙生龙子，虎生虎儿。龙游浅水遭虾戏，虎落平原被犬欺。一举首登龙虎榜，十年身到凤凰池。十年寒窗无人问，一举成名天下知。酒债寻常处处有，人生七十古来稀！养儿防老，积谷防饥。鸡豚狗彘之畜，无失其时，数口之家，可以无饥矣。常将有日思无日，莫待无时当有时。树欲静而风不止，子欲养而亲不待。时来风送滕王阁，运去雷轰荐福碑。入门休问荣枯事，且看容颜便得知。官清司吏瘦，神灵庙主肥。息却雷霆之怒，罢却虎豹之威。威。饶人算知本，输人算知机。好言难得，恶语易施。一言既出，驷马难追。择其善者而从之，其不善者而改之。少壮不努力，老大徒伤悲。人有善愿，天必佑之。莫欺卯时酒，昏昏醉到酉。莫骂酉时妻，一夜受孤凄。种麻得麻，种豆得豆。天眼恢恢，疏而不漏。做官莫向前，作客莫向后。宁添一斗，莫添一口。螳螂捕蝉，岂知黄雀在后？不求金玉重重贵，但求儿孙个个贤。一日夫妻，百世姻缘。百世修来同船渡，千世修来共枕眠。杀人一万，自损三千。枯木逢春犹再发，人无两度再少年。未晚先投宿，鸡鸣早看天。将相场中堪走马，公侯肚内好撑船。富人思来年，穷人想眼前。世上若要人情好，赊去物品莫取钱。生死有命，富贵在天。击石原有火，不击乃无烟。人学始知道，不学亦徒然。莫笑他人老，终须还到老。但能守本分，终身无烦恼。善有善报，恶有恶报，不是不报，时候未到。人而无信，不须礼之。一人道好，千人传之。若要凡事好，须先问三老。君子爱财，取之有道。贞妇爱色，纳之以礼。年年防饥，夜夜防盗。学者是好，不学不好。学者如禾如稻，不学如草如蒿。遇饮酒时须防醉，得高歌处且高歌。因风吹火，用力不多。不因渔夫引，怎能见波涛？无求到处人情好，不饮任他酒价高。知事少时烦恼少，识人多处是非多。进山不怕虎伤人，只怕人情两面刀。强中更有强中手，恶人须用恶人磨。会使不在家富豪，风流不用衣着佳。光阴似箭，日月如梭。天时不如地利，地利不好人和。黄金未为贵，安乐值钱多。世上万般皆下品，思量惟有读书高。世间好语书谈尽，天下名山僧占多。为善最乐，作恶难逃。好人相逢，恶人回避。羊有跪乳之恩，鸦有反哺之情。你急他不急，人闲心不闲。隐恶扬善，执其两端。妻贤夫祸少，子孝父心宽。已覆之水，收之实难。人生知足常乐，人老偷闲且闲。处处绿杨堪系马，家家有路通长安。见者易，学者难。厌静还思喧，嫌喧又忆山。自从心安后，无处不安然。莫将容易得，便作等闲看。用心计较般般错，退后思量事事宽。道路各别，养家一般。由俭入奢易，由奢入俭难。知音说与知音听，不是知音莫与谈。点石化为金，人心犹未足。信了赌，卖了屋。他人观花，不涉你目。他人碌碌，不涉你足。谁人不爱子孙贤，谁人不爱千钟粟。莫把真心空计较，五行不是这题目。书到用时方恨少，事非经过不知难。行事存德，莫问前程。河狭水紧，人急智生。明知山有虎，偏向虎山行。路不行不到，事不为不成。无钱方断酒，临老才读经。点塔七层，不如暗处一灯。万事劝人休瞒眛，举头三尺有神明。但存方寸地，留与子孙耕。灭却心头火，剔起佛前灯。惺惺多不足，蒙蒙作公卿。众星朗朗，不如孤月独明。兄弟相害，不如自生。合理可作，小利不争。牡丹花好空入目，枣花虽小结实多。欺老莫欺小，欺人心不明。勤奋耕锄收地利，他时饱䁔谢苍天。得忍且忍，得耐且耐，不忍不耐，小事成灾。相论逞英豪，家计渐渐退。贤妇令夫贵，恶妇令夫败。一人有庆，兆民厨赖。人老心未老，人穷计莫穷。人无千日好，花无百日红。黄蜂一口针，橘子两边分。世间通恨事，最毒淫妇心。杀人可恶，情理不容。乍富不知新受用，乍贫难改旧家风。座上客常满，杯中酒不空。屋漏又遭连夜雨，行船偏遇打头风。笋因落箨方成竹，鱼为奔波始化龙。记得少年骑竹马，转眼又是白羊翁。礼义生于富贵，盗贼出于贫穷。天上众星皆拱北，世间无水不朝东。士为知己者死，女为悦己者容。色即是空，空即是色。君子安贫，达人知命。良药苦口利于病，忠言逆耳利于行。顺天者昌，逆天者亡。有缘千里来相会，无缘对面不相逢。有福者昌，无福者亡。人为财死，鸟为食亡。夫妻相和好，琴瑟与笙簧。红粉易妆娇态女，无钱难作好儿郞。有子之人贫不久，无儿无女富不长。善必寿老，恶必早亡。爽口食多偏作病，快心事过恐遭殃。富贵定言要依分，贫穷不必枉思量。画水无风空作浪，绣花虽好不生香。贪他一斗米，失却半年粮。争他一脚豚，反失一只羊。龙归晚洞云犹湿，麝过春山草木香。人生只会量人短，何不回头把自量？见善如不及，见恶如探汤。人穷志短，马瘦毛长。自家心里急，他人未知忙。贫无达士将金赠，病有高人说药方。秋来满山多秀色，春来无处不花香。凡人不可貌相，海水不可斗量。清清之水，为土所防。济济之士，为酒所伤。蒿草之下，或有兰香。芧茨之屋，或有公王。无限朱门生饿殍，几多白屋出公卿。酒里乾坤大，壶中日月长。拂石坐来春衫冷，踏花归去马蹄香。万事前身定，浮生空自忙。叫月子规喉舌冷，宿花蝴蝶梦魂香。一言不中，千言不用。一人传虚，百人传实。万金良药，不如无疾。世事如明镜，前程似暗漆。君子怀刑，小人怀惠。良田万倾，日食一升。大厦千间，日眠八尺。千经万典，孝义为先。天上人间，方便第一。一字入公门，九牛拔不出。衙门八字开，有理无钱别进来。欲求天下事，须用世间财。富从升合起，贫因不算来。近河不得枉使水，近山不得枉烧柴。家中无才子，官从何处来？慈不掌兵，义不掌财。一夫当关，万夫莫开。万事不由人计较，一生都是命安排。白云本是本是无心物，却被清风引出来。慢行急行，逆取顺取。命中只有如许财，丝毫不可有闪失。人间私语，天闻若雷。暗室亏心，神目如电。一毫之恶，劝人莫作。一毫之善，与人方便。亏人是祸，饶人是福，天眼恢恢，报应甚速。圣贤言语，神钦鬼伏。人各有心，心各有见。口说不如身逢，耳闻不如目见。见人富贵生欢喜，莫把心头似火烧。养兵千日，用在一时。国清才子贵，家富小儿娇。利刀割肉伤可愈，恶语伤人恨不消。公道世间唯白发，贵人头上不曾饶。有才堪出众，无衣懒出门。为官须作相，及第必争先。苗从地发，树向枝分。宅里燃火，烟气成云。以直抱怨，知恩报恩。红颜今日虽欺我，白发他时不放君。借问酒家何处有，牧童遥指杏花村。父子和而家不退，兄弟和而家不分。一片云间不相识，三千里外却逢君。官有正条，民有私约。争得猫儿，失却牛脚。愚者千虑，必有一得，智者千虑，必有一失。始吾于人也，听其言而信其行。今吾于人也，听其言而观其行。哪个梳头无乱发，情人眼里出西施。珠沉渊而川媚，玉韫石而山辉。夕阳无限好，只恐不多时。久旱逢甘霖，他乡遇故知；洞房花烛夜，金榜题名时。惜花春起早，爱月夜眠迟。掬水月在手，弄花香满衣。桃红李白蔷薇紫，问着东君总不知。国乱思良将，家贫思良妻。池塘积水防秋旱，田地深耕足养家。教子教孙须教义，栽桑栽柘少栽花。休念故乡生处好，受恩深处便为家。要深不怕树摇动，树正不愁月影斜。奉劝君子，各宜守己。只此呈示，万无一失。 《增广贤文》（下集）前人俗语，言浅理深。补遗增广，集成书文。世上无难事，只怕不专心。成人不自在，自在不成人；金凭火炼方知色，与人交财便知心。乞丐无粮，懒惰而成。勤俭为无价之宝，节粮乃人妙之门。省事俭用，免得求人。量大祸不在，机深祸亦深。善为至宝深深用，心作良田世世耕。群居防口，独坐防心。体无病为富贵，身平安莫怨贫。败家子弟挥金如土，贫家子弟积土成金。富贵非关天地，福祸不是鬼神。安分贫一时，本分终不贫。不拜父母拜干亲，弟兄不和结外人。人过留名，雁过留声。择子莫择父，择亲莫择邻。爱妻之心是主，爱子之心是亲。事从根起，藕叶连心。祸与福同门，利与害同城。清酒红人脸，财帛动人心！宁可荤口念佛，不可素口骂人。有钱能说话，无钱话不灵。岂能尽如人意？但求不愧于心。不说自己井绳短，反说他人箍井深。恩爱多生病，无钱便觉贫。只学斟酒意，莫学下棋心。孝莫假意，转眼便为人父母。善休望报，回头只看汝儿孙！口开神气散，舌出是非生！弹琴费指甲，说话费精神。 千贯买田，万贯结邻。人言未必犹尽，听话只听三分。隔壁岂无耳，窗外岂无人？财可养生须注意，事不关己不劳心。酒不护贤，色不护病；财不护亲，气不护命！一日不可无常业，安闲便易起邪心！炎凉世态，富贵更甚于贫贱；嫉妒人心，骨肉更甚于外人！瓜熟蒂落，水到渠成。人情送匹马，买卖不饶针！过头饭好吃，过头话难听！事多累了自己，田多养了众人。怕事忍事不生事自然无事；平心静心不欺心何等放心！天子至尊不过于理，在理良心天下通行。好话不在多说，有理不在高声！一朝权在手，便把令来行。甘草味甜人可食，巧言妄语不可听。当场不论，过后枉然。贫莫与富斗，富莫与官争！官清难逃猾吏手，衙门少有念佛人！家有千口，主事一人。父子竭力山成玉，弟兄同心土变金。当事者迷，旁观者清。怪人不知理，知理不怪人。未富先富终不富，未贫先贫终不贫。少当少取，少输当赢！饱暖思淫欲，饥寒起盗心！蚊虫遭扇打，只因嘴伤人！布衣得暖真为福，千金平安即是春。家贫出孝子，国乱显忠臣！宁做太平犬，莫做离乱人！人有几等，官有几品。理不卫亲，法不为民。自重者然后人重，人轻者便是自轻。自身不谨，扰乱四邻。快意事过非快意，自古败名因败事。伤身事莫做，伤心话莫说。小人肥口，君子肥身。地不生无名之辈，天不生无路之人。一苗露水一苗草，一朝天子一朝臣。读未见书如逢良友，见已读书如逢故人。福满须防有祸，凶多料必无争。不怕三十而死，只怕死后无名。但知江湖者，都是薄命人。不怕方中打死人，只知方中无好人。说长说短，宁说人长莫说短；施恩施怨，宁施人恩莫施怨。育林养虎，虎大伤人。冤家抱头死，事要解交人。卷帘归乳燕，开扇出苍蝇。爱鼠常留饭，怜蛾灯罩纱。人命在天，物命在人。奸不通父母，贼不通地邻。盗贼多出赌博，人命常出奸情。治国信谗必杀忠臣，治家信馋必疏其亲。治国不用佞臣，治家不用佞妇。好臣一国之宝，好妇一家之珍。稳的不滚，滚的不稳。儿不嫌母丑，狗不嫌家贫。君子千钱不计较，小人一钱恼人心。人前显贵，闹里夺争。要知江湖深，一个不做声。知止自当出妄想，安贫须是禁奢心。初入行业，三年事成；初吃馒头，三年口生。家无生活计，坐吃如山崩。家有良田万顷，不如薄艺在身；艺多不养家，食多嚼不赢。命中只有八合米，走遍天下不满升。使心用心，反害自身。国家无空地，世上无闲人。妙药难医怨逆病，混财不富穷命人。耽误一年春，十年补不清；人能处处能，草能处处生。会打三班鼓，也要几个人。人不走不亲，水不打不浑。三贫三富不到老，十年兴败多少人！买货买得真，折本折得轻；不怕问到，只怕倒问。人强不如货强，价高不如口便。会买买怕人，会卖卖怕人。只只船上有梢公，天子足下有贫亲。既知莫望，不如莫问。在一行，练一行；穷莫失志，富莫癫狂。天欲令其灭亡，必先令其疯狂。梢长人胆大，梢短人心慌。隔行莫贪利，久炼必成钢。瓶花虽好艳，相看不耐长。早起三光，迟起三慌。未来休指望，过去莫思量；时来遇好友，病去遇良方。布得春风有夏雨，哈得秋风大家凉。晴带雨伞，饱带干粮。满壶全不响，半壶响叮当。久利之事莫为，众争之地莫往。老医迷旧疾，朽药误良方；该在水中死，不在岸止亡。舍财不如少取，施药不如传方。倒了城墙丑了县官，打了梅香丑了姑娘。燕子不进门，耗子不钻空仓。苍蝇不叮无缝的蛋，谣言不找谨慎的人。一人舍死，万人难当。人争一口气，佛争一柱香。门为小人而设，锁乃君子之防。舌咬只为揉，齿落皆因眶。硬弩弦先断，钢刀刃自伤。贼名难受，龟名难当。好事他人未见讲，错处他偏说得长。男子无志纯铁无钢，女子无志烂草无瓤。生男欲得成龙犹恐成獐，生女欲得到凤犹恐成虎。养男莫听狂言，养女莫叫离母。男子失教必愚顽，女子失教定粗鲁。生男莫教弓与弩，生女莫教歌与舞。学成弓弩沙场灾，学成歌舞为人妾。财交者密，财尽者疏。婚姻论财，夫妻之道。色娇者亲，色衰者疏。少实胜虚，七不如拙。百战百胜不如无争，万言万中不如一默。有钱不置怨逆产，冤家宜解不宜结。近朱者赤，近墨者黑。一个山头一只虎，恶龙难斗地头蛇。出门看天色，进门看脸色。商贾买卖如施舍，买卖公平如积德。天生一人，地生一穴。家无三年之积不成其家，国无九年之积不成其国。男子有德便是才，女子无才便是德。有钱难买子孙贤，女儿不请上门客。男大当婚女大当嫁，不婚不嫁惹出笑话。谦虚美德，过谦即诈。自己跌倒自己爬，望人扶持都是假。人不知己过，牛不知力大。一家饱暖千家怨，一物不见赖千家。当面论人惹恨最大，是与不是随他说吧！谁人做得千年主，转眼流传八百家。满载芝麻都漏了，还在水里捞油花！皇帝坐北京，以理统天下。五百年前共一家，不同祖宗也同华！学堂大如官厅，人情大过王法。找钱犹如针挑土，用钱犹如水推沙！害人之心不可有，防人之心不可无！不愁无路，就怕不做。须向根头寻活计，莫向体面下功夫！祸从口出，病从口入。药补不如肉补，肉补不如养补。思虑之害甚于酒色，日日劳力上床呼疾。人怕不是福，人欺不是辱。能言不是真君子，善处方为大丈夫！为人莫犯法，犯法身无主。姊妹同肝胆，弟兄同骨肉。慈母多误子，悍妇必欺夫！君子千里同舟，小人隔墙易宿。文钱逼死英雄汉，财不归身恰以无。妻子如衣服，弟兄似手足。衣服补易新，手足断难续。盗贼怨失主，不孝怨父母。一时劝人以口，百世劝人以书。我不如人我无其福，人不如我我常知足！捡金不忘失金人，三两黄铜四两福。因祸得福，求赌必输。一言而让他人之祸，一忿而折平生之福。天有不测风云，人有旦夕祸福。不淫当斋，淡饱当肉。缓步当车，无祸当福。男无良友不知己之有过，女无明镜不知面这精粗。事非亲做，不知难处。十年易读举子，百年难淘江湖！积钱不如积德，闲坐不如看书。思量挑担苦，空手做做是福。时来易借银千两，运去难赊酒半壶。天晴打过雨落铺，少时享过老来福。与人方便自己方便，一家打墙两家好看。当面留一线，过后好相见。入门掠虎易，开口告人难。手指要往内撇，家丑不可外传。浪子出于祖无德，孝子出于前人贤。货离乡贵，人离乡贱。树挪死，人挪活。在家千日好，出门处处难。三员长者当官员，几个明人当知县？明人自断，愚人官断。人怕三见面，树怕一墨线。村夫硬似铁，光棍软如棉。不是撑船手，怎敢拿篙杆！天下礼仪无穷，一人知识有限。一人不得二人计，宋江难结万人缘。家有三亩田，不离衙门前，乡间无强汉，衙门就饿饭。人人依礼仪，天下不设官。衙门钱，眼睛钱；田禾钱，千万年。读书必读，不可做官。为人莫当官，当官皆一般。换了你我去，恐比他还贪。官吏清廉如修行，书差方便如行善。靠山吃山，种田吃田。吃尽美味还是盐，穿尽绫罗还是棉。一夫不耕，全家饿饭，一女不织，全家受寒。金银到手非容易，用时方知来时难。先讲断，后不乱，免得藕断丝不断。听人劝，得一半。不怕慢，只怕站。逢快莫赶，逢贱莫懒。谋事在人，成事在天！长路人挑担，短路人赚钱。宁卖现二，莫卖赊三。赚钱往前算，折本往后算。小小生意赚大钱，七十二行出状元。自己无运至，却怨世界难。胆大不如胆小，心宽甚如屋宽。妻贤何愁家不富，子孙何须受祖田。是儿不死，是财不散。财来生我易，我去生财难。十月滩头坐，一日下九滩。结交一人难上难，得罪一人一时间。借债经商，卖田还债；赊钱起屋，卖屋还钱。修起庙来鬼都老，拾得秤来姜卖完。不嫖莫转，不赌莫看。节食以去病，少食以延年。豆腐多了是包水，梢公多了打烂船。无口过易，无眼过难。无身过易，无心过难。不会凫水怨河宽，不会犁田怨枷担。他马莫骑，他弓莫挽。要知心腹事，但听口中言。宁在人前全不会，莫在人前会不全。是非亲见，切莫乱谈。打人莫打脸，骂人莫骂短。好言一句三冬暖，话不投机六月寒。人上十口难盘，帐上万元难还。放债如施，收债如讨。告状讨钱，海底摸盐。衙门深似海，弊病大如天。银钱莫欺骗，牛马不好变。好汉莫被人识破，看破不值半文钱。狗咬对头人，雷打三世冤。不卖香烧无剩钱，井水不打不满边。事宽则园，太久则偏。高人求低易，低人求高难。有钱就是男子汉，无钱就是汉子难。人上一百，手艺齐全。难者不会，会者不难。生就木头造就船，砍的没得车的圆。心不得满，事不得全。鸟飞不尽，话说不完。人无喜色，休开店，事不遂心莫怨天。选婿莫选田园，选女莫选嫁奁。红颜女子多薄命，福人出在丑人边。人将礼义为先，树将花果为园。临危许行善，过后心又变。天意违可以人回，命早定可以心挽。强盗口内出赦书，君子口中无戏言。贵人语少，贫子话多。快里须斟酌，耽误莫迟春。读过古华佗，不如见症多。东屋示补西屋破，前帐未还后又拖。今年又说明年富，待到明年差不多。志不同己，不必强合。莫道坐中安乐少，须知世上苦情多。本少利微强如坐，屋檐水也滴得多。勤俭持家富，谦恭受益多。细处不断粗处断，黄梅不落青梅落。见钱起意便是贼，顺手牵羊乃为盗。要做快活人，切莫寻烦恼。要做长寿人，莫做短命事。要做有后人，莫做无后事。不经一事，不长一智。宁可无钱使，不可无行止。栽树要栽松柏，结交要结君子。秀才不出门，能知天下事。钱多不经用，儿多不耐死。弟兄争财家不穷不止，妻妾争风夫不死不休。男人有志，女人有势。夫人死百将临门，将军死一卒不至。天旱误甲子，人穷误口齿。百岁无多日，光阴能几时？父母养其身，自己立其志。待有余而济人，终无济人之日；待有闲而读书，终无读书之时。此书传后世，句句必精读，其中礼和义，奉劝告世人。勤奋读，苦发奋，走遍天涯如游刃。","categories":[{"name":"诗词歌赋","slug":"诗词歌赋","permalink":"https://liangyuanzheng.com/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"古文","slug":"古文","permalink":"https://liangyuanzheng.com/tags/%E5%8F%A4%E6%96%87/"}]},{"title":"热爱生活","slug":"20240727-热爱生活","date":"2024-07-26T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240727-热爱生活.html","link":"","permalink":"https://liangyuanzheng.com/20240727-%E7%83%AD%E7%88%B1%E7%94%9F%E6%B4%BB.html","excerpt":"","text":"生活中只有一种英雄主义，那就是在认清生活真相之后依然热爱生活。 ——罗曼罗兰","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"《荀子》强国","slug":"20240727-《荀子》强国","date":"2024-07-26T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240727-《荀子》强国.html","link":"","permalink":"https://liangyuanzheng.com/20240727-%E3%80%8A%E8%8D%80%E5%AD%90%E3%80%8B%E5%BC%BA%E5%9B%BD.html","excerpt":"","text":"积微，月不胜日，时不胜月，岁不胜时。凡人好敖慢小事，大事至，然后兴之务之。如是，则常不胜夫敦比于小事者矣！是何也？则小事之至也数，其县日也博，其为积也大。大事之至也希，其县日也浅，其为积也小。故，善日者王，善时者霸，补漏者危，大荒者亡！故，王者敬日，霸者敬时，仅存之国，危而后戚之。亡国，至亡而后知亡，至死而后知死。亡国之祸败，不可胜悔也。霸者之善箸也，可以时托也。王者之功名，不可胜日志也。财物货宝以大为重，政教功名者反是，能积微者速成。诗曰：“德如毛，民鲜克举之。”此之谓也。 注释《荀子》 “积微”","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"}]},{"title":"显学","slug":"20240725-显学","date":"2024-07-24T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240725-显学.html","link":"","permalink":"https://liangyuanzheng.com/20240725-%E6%98%BE%E5%AD%A6.html","excerpt":"","text":"显学，是指一时在社会上处于热点的、显赫一时的学科、学说、学派。《显学》称：”世之显学，儒墨也。儒之所至，孔丘也；墨之所至，墨翟也。”这是指韩非子所处时代的情况。在不同时代有不同的显学。 显学更接近于科学物理研究，被称为实践学派。儒家学派、黄老学派、墨家学说与杨朱学派组成了中国较早的显学学说学术。 显学与稳学相对。孔子——儒学，墨翟——墨学，儒学与墨学并称“显学”。 显学强调存在就是现实，对于显学研究的成就根源于对发展变化和谐治理制度的理解。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"《资治通鉴》","slug":"《资治通鉴》","date":"2024-07-22T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"《资治通鉴》.html","link":"","permalink":"https://liangyuanzheng.com/%E3%80%8A%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4%E3%80%8B.html","excerpt":"","text":"史记编年史，年经事纬的巨著。 序博而得其要，简而周于事 卷第一惎（jì），毒也，音其冀翻。 天子之职莫大于礼，礼莫大于分，分莫大于名。 文王序易，以乾、坤为首。孔子系之曰：“天尊地卑，乾坤定矣。卑高以陈，贵贱位矣。”天地君亲师，古人（特别是统治阶级）太注重名分了。可能因为它是维护正统稳定，国家长治久安的一种手段。孔子是很看重名的，名不正则民无措手足。（见论语。） 夫事未有不生于微而成于著，圣人之虑远， 故能谨其微而治之。众人之识近，故必待其著而后救之；治其微则用力寡而功多，救其著则竭力而不能及也。 易曰：“履霜坚冰至，” 履霜坚冰，汉语成语，拼音：lǚ shuāng jiān bīng，释义：踩着霜，就想到结冰的日子就要到来；比喻看到事物的苗头，就对它的发展有所警戒。出自《易·坤》。 书曰：“一日二日万几，” 一日万几，汉语成语，拼音是 yī rì wàn jǐ，意思是帝王每天处理政事极为繁忙。出自《尚书·皋陶漠》。 下陵上替 下陵上替，汉语成语，拼音是 xià líng shàng tì，意思是在下者凌驾于上，在上者废弛无所作为，即上下失序，纲纪废坠。出自《左传·昭公十八年》。 至于季氏之于鲁， 田常之于齐，白公之于楚，智伯之于晋，其势皆足以逐君而自为，然而卒不敢者， 岂其力不足而心不忍哉，乃畏奸名犯分而天下共诛之也。 将欲败之，必姑辅之。 将欲取之，必姑与之。将欲取之，必先予之。 [!PDF|red] 资治通鉴（胡三省注）, p.11 智伯又求蔡、皋狼之地于赵襄子 附录在看《资治通鉴》时，发现用于解释的小字部分有“治，直之翻”之类的字眼，请问这个“翻”是什么意思呀？即 反切。古时的注音方法。唐以前人们祇称某某反，唐代人们忌称“反”而改称“切”，也有叫“翻”的，後人合称反切。反切，套成现代术语，基本方法是取前一字的声母和後一字的韵母与声调，二者相拼，就得到了一个新的读音。但知道了这些祇能解决一部分反切的拼读，而不是全部。楼主所举就有一些无法顺利拼读。还有一些专门知识要铺垫纔能全部解决。 还有“扶问翻”，“他综翻”，“户计翻”，“直之翻”，还有“直吏翻”等好多的。你都能理解了。 参考文献 资治通鉴（胡三省注）%20.pdf 20240405 资治通鉴 谥法","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://liangyuanzheng.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"历史","slug":"历史","permalink":"https://liangyuanzheng.com/tags/%E5%8E%86%E5%8F%B2/"},{"name":"资治通鉴","slug":"资治通鉴","permalink":"https://liangyuanzheng.com/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"}]},{"title":"资治通鉴 谥号","slug":"谥号","date":"2024-07-22T16:00:00.000Z","updated":"2025-10-27T00:35:41.797Z","comments":true,"path":"谥号.html","link":"","permalink":"https://liangyuanzheng.com/%E8%B0%A5%E5%8F%B7.html","excerpt":"","text":"谥号，依其生平功过与品德修养另起的称号，以名寓评，是为谥号。 帝王的谥号一般是由礼官议定，再经继位帝王认可后予以宣布，臣下的谥号则由进行赐予。如诸葛武侯（诸葛亮）、韩文公（韩愈）、曾文正（曾国藩）、岳武穆（岳飞）等。 谥法由来传统说法：《逸周书·谥法解》对立谥制度的起源的解释，将其假托于周初周公旦和太公望所制谥，用以如实反映逝者的生前事迹与功劳。后世谥号之制定遂以谥法为纲。 当代研究：郭沫若：《逸周书》是战国时代的伪书，起于战国之时。王国维：谥法之兴分别订于不同时期，起于宗周共懿诸王以后。 文、武谥号：一个朝代的第一、第二国君的谥号经常使用文、武。 种类 上谥：表扬类的谥号。传统以文、武两字为最高荣誉。 谥号 含义 举例 武 开创局面、辟疆拓土等伟业 文 经纬天地的才能，或“道德博厚、勤学好问”的品德。 壮 生前战功彪炳的武将 中谥：多为同情类的谥号。 谥号 含义 举例 愍 在国遭忧、在国逢难 愽昌愍侯夏侯渊、晋愍帝司马邺 怀 慈仁短折 蜀汉怀帝刘禅 下谥：即批评类的谥号。 谥号 含义 举例 炀 好内远礼 隋炀帝 厉 暴慢无亲或不吉利 荒 好乐怠政、外内从乱 鲁荒王朱檀 幽 壅遏遏不通 晋幽公 灵 乱而不损 汉灵帝 私谥：私下议定的谥号。 同一个谥号，其种类也会变化的。比如，“惠”本为美谥，汉惠帝用过以后，就转为平谥了。再如“昭”字，战国之前多为恶谥，用于中衰之主，或不得其终者。如楚昭王（失国）。但自战国以后，谥“昭”者多为令主，逐由恶谥转为美谥了。但自南北朝以后，又转为平谥了，用于悼谥寿命不长或不得其终者，如南梁昭明太子（短寿），唐朝以后的皇帝谥号便不再用“昭”字。 谥法规则先秦时的谥号通常用一个字，也有三个字的。秦穆公、晋文公；三个字的如魏文惠王。 秦始皇废除谥法。 防止因谥号的定夺形成“子议父，臣议君”的局面。 汉代恢复谥法，这一时期的谥法制度也日趋严密。 唐宋时期为谥法的发展时期，谥法一方面成为封建帝王尊大谥以满足其虚荣以后工具，同时也成为驾驭群臣的褒贬手段。 武则天开的头。追谥唐高宗“天皇大帝”。自己称帝后，更是开创了皇帝生前叠加谀词上尊号溢美的先例。 宋代皇帝谥号比唐时更加谥美。 明朝时期，字数就变多了。达17 字或 21 字，甚至有固定的格式。文臣谥号之极为“文贞”。如魏徵、杨士奇及康熙帝师陈迁敬。宋代避讳改用“文正”。 谥号举例汤：除残去虐曰汤。然谥法起于周；盖殷人先有此号，周人遂引以为谥法。 威烈王：猛以刚果曰威；有功安民曰烈。 韩康子、魏桓子：温柔好乐曰康；辟土服远曰桓。 智宣子：圣善周闻曰宣。 赵简子：一德不懈曰简。 智襄子：有劳定国曰襄。 代成君：安民立政曰成。 献子：知质有圣曰献。 烈侯：有功安民曰烈，秉德尊业曰烈。 文侯：学勤好问曰文；慈惠安民曰文。 景侯：克定祸乱曰武；布义行刚曰景。 燕愍公：使民悲伤曰闵；小心畏忌曰僖。愍，读与闵同。 显王：十一家谥法：行见中外曰显；受禄于天曰显；百辟惟刑曰显。周公盖未有此谥，而周之末世谥 显王曰显，意谓后世传写周公諡法者遗之。 昭侯：昭德有劳曰昭；圣闻周达曰昭。 慎靓王：此复谥也。敏以敬曰慎；柔德安众曰靖。liàng 释义 1.漂亮；好看。jìng 释义 1.妆饰；打扮。2.美丽；艳丽。 昭襄王：昭德有劳日昭；辟地有德曰襄。以沈约谧法言之，则昭襄复谥也。 孝惠皇帝：应劭曰：礼谥法：柔质慈民曰惠。师古曰：孝子善 述人之志，故汉家之谥，自惠帝以下皆称孝也。 安王：好和不争曰安。 参考文献 谥号 - 维基百科，自由的百科全书 泰山封禅_百度百科","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"DOING","slug":"doing","permalink":"https://liangyuanzheng.com/tags/doing/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"资治通鉴","slug":"资治通鉴","permalink":"https://liangyuanzheng.com/tags/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"}]},{"title":"青岛旅行行程攻略","slug":"202408-青岛旅行行程攻略","date":"2024-07-20T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"202408-青岛旅行行程攻略.html","link":"","permalink":"https://liangyuanzheng.com/202408-%E9%9D%92%E5%B2%9B%E6%97%85%E8%A1%8C%E8%A1%8C%E7%A8%8B%E6%94%BB%E7%95%A5.html","excerpt":"","text":"小红书攻略青岛攻略第一次来的宝子必看 青岛这片蔚蓝色的海岸线，漫画般的建筑群，翠绿色的松柏树，以及各种通往大海的转角和街道，让我仿佛置身于海滨城市的梦境中如果你要来青岛，一定要带着娃逛完这些地方再离开两天游玩线路：第一天：桟㮇一銀色港一天主教堂一信号山公园一网红墙—小鱼山一鲁迅公园一琴屿路—小青岛公园第二天：八大关一五四广场一奥帆中心一情人坝一燕儿岛一小麦岛公园一雕塑园一石老人ー另外，如果有时间，还可以去崂山玩一玩青岛必游玩景点① 小麦岛两边造型奇特的树和翠绿的草地，简直就是现实版宫崎骏的动漫世界② 第二海水浴场造型独特的天然洞穴，在退潮之后从内往外拍照，超出片③ 小鱼山两分钟登顶，将青岛城市和海岸的风景尽收眼底④ 八大关道路两旁郁郁葱葱的树林，走在其中非常治愈⑤ 石老人海水浴场等到退潮以后，可以去拍隐藏洞穴，人少好出片⑥ 龙江路充满童话的道路，标志性“青岛”打卡墙也在这里⑦ 琴屿路小飞奔同款 S 海边路，坐在咖啡馆看着海景好惬意⑧ 雕塑园翠松柏的尽头是海，坐在堤坝上拍照好像误入了油画中一般旅行小贴士： 住宿：选择青岛站附近的酒店，出行游玩都很便捷 天气：提前查看天气，晴天真的超出片 防晒：海边游玩记得涂好防晒 青岛 3⃣️ 天 2⃣️ 夜旅游｜旅行行程攻略 青岛Day1:栈桥——天 zhu 教堂——安娜别墅——大鲍岛——宫崎骏漫画街——大学路网红墙——琴屿岛Da2:青岛中山公园——di 一海水浴一八大观——di 二海水浴——电视塔——青岛啤酒博物馆——台东步行街Da3:石老人海水浴——崂山——小麦岛 @走走薯 @生活薯 ✅bi 打卡景点栈桥-看来自西伯利亚的海鸥大学路与龙江路：这条路上有很多好看的门店，还有彩绘墙和红墙转角。圣弥厄尔主教座堂天 zhu 堂：天 zhu 教堂建筑独特周边有很多值得逛吃的地方。琴屿路：这里有一个非常漂亮的 S 弯，还可以看到很美的礁石小麦岛：这里有一个梦幻机位，海的神奇需要用心感受。 🦞 关于海鲜：听劝去吃了椒盐皮皮虾和螃蟹拌面都很美味，海肠捞饭超赞，海胆蒸蛋好吃很鲜美，搭配水蜜桃果啤超爽，晚饭早点去会排队 📍 爱来客海鲜大排档（顺兴路总店） 。🏨 关于酒店：龙江路附近，或者栈桥景区附近吃喝玩乐都方便👗 关于穿搭：早晚需要带好外套晴天中午时间可以穿连衣裙🚗 关于出行：zui 好直接到青岛站距离打卡点都比较近青岛没有非机动车道出行主要就是打车地铁步行步行时这里的上下坡道路比较多一定要储存好体力 青岛 CityWalk 旅游，三天两夜打卡经典路线 青岛 3 天 2 夜旅游，主打不绕路旅游行程安排第 1️⃣ 天：栈桥 → 天主教堂 → 信号山公园 → 总督楼旧址博物馆 → 老舍故居 → 网红墙 → 水彩博物馆 → 海军博物馆 → 琴屿路 → 鲁迅公园 → 酒店（五四广场附近）⚠️ 注意：全程基本步行、景点间隔不到一公里比较方便✅ 栈桥：运气好的话会遇见海鸥，4 月底就飞走啦！✅ 圣弥厄尔大教堂：天主教堂，哥特式建筑✅ 网红墙：就是一个网红打卡地✅ 信号山公园：：信号山有很多地方都挺好拍的✅ 琴屿路：有棵树的位置是青岛的顶流机位 第 2️⃣ 天：五四广场 → 情人坝 → 燕儿岛 → 奥帆中心 → 小麦岛 → 极地海洋公园 → 雕塑园 → 石老人海水浴场 → 酒店（五四广场附近）✅ 情人坝：离奥帆中心很近，有座标志性灯塔✅ 小麦岛: 绝美, 适合看日落✅ 燕儿岛山公园: 网红洞拍照很出片✅ 奥帆中心：可以坐船，如果从路边本地人那儿买票，一定要砍价！🏠 晚上还是住五四广场：夜景很美 第 3️⃣ 天：第三海水浴场 → 太平角公园 → 八大关风景区 → 第二海水浴场 → 青岛啤酒博物馆 → 返程回家 ✈️✅ 第一海水浴场有网红树✅ 第二海水浴场一定要去！有《悲伤逆流成河》同款机位还有网红洞✅ 八大关：红瓦绿树，碧海蓝天，百国风格建筑群，可以在外面拍拍照，不用买票进去♥️ 住宿：建议五四广场，交通便利，离景点不算太远，也可以住在青岛站附近。♥️ 美食：tui 荐一家我连吃三顿的宝藏餐厅，吃什么都不踩雷的海鲜大排档香辣虾、海肠捞饭、椒盐皮皮虾，蒜蓉生蚝都是必点特别好吃，但是晚上要早点去，不然要排很长的队 📍：爱来客海鲜大排档～～～ 青岛旅行攻略，送给 4-6 月来青岛旅游的出来玩不能太拘谨 青岛旅行攻略，送给 4-6 月来青岛旅游的出来玩不能太拘谨写给 4-6 月来青岛旅游的实用攻略，这份攻略送给你们，不要错过这份攻略喔~青岛交通指南① 飞机:青岛胶东国际机场，距青岛市中心 39 公里 ② 机场大巴:3 航站楼一层 4 号门外设置有乘车点③ 地铁:地铁 8 号线就在机场航站楼下，可转乘直达市区④ 打车:全程大约 50 分钟左右(比较贵，不划算)⑤ 火车站:青岛北站(高铁站)、青岛站住宿建议老城区:青岛站附近，地铁四 3 号线经过，交通便利，距离各个景点都很近五四广场、奥帆广场:附近商场很多，而且地铁 2 号线经过，去哪都比较方便，购物、住宿、交通都方便台东步行街:小吃商业街，各种小摊美食，不过人很多，偶尔会堵车海边:海边基本都是 10 年以上的老小区了，所以设施可能会比较陈旧，另外越靠近海是越潮湿的，但是风景还是很美的就近原则:青岛的旅游景点很多，有时候来回跑会比较累、而且耽误时间，可以在去之前做好游玩计划，然后找一个离自己第二天游玩比较近的地方住宿。在游玩时可以随时随不同景点更换住宿地点，但这有一个缺点就是不能有太多行李，所有行李要随时携带。青岛必打卡景点栈桥交通:2&#x2F;5&#x2F;801 路公交栈桥站天主教堂交通:地铁 3 号线到青岛站八大关交通:地铁 3 号线太平角公园站五四广场交通:地铁 2 号线五四广场站信号山公园交通:225、228 路公交青医附院站中山公园交通:地铁 3 号线中山公园青岛五天四晚经典线路Day1: 各地到达青岛 → 青岛啤酒街 aDay2: 栈桥 → 海上观光 → 青岛天主教圣弥厄尔大教堂 → 最美转角(大学路)→ 八大关风景区 → 五四广场 → 奥帆中心Day3: 青岛 → 威海 → 华夏城风景区 → 木鱼石博物馆 → 幸福门 → 环海公路Day4: 威海 → 蓬莱文成酒堡(西虹市首富)拍摄地 Day5:崂山 → 赶海拾贝 → 青岛 → 返程青岛美食必吃1、青岛海鲜:别去大饭店，自己在海鲜市场买，去附近的馆子出点加工费，一般连锁的大差不差，不会被坑2、青岛啤酒:当地人说原浆啤酒好喝，建议买之前记得问清楚价格 刚从青岛回来无语了 暑假计划去青岛的姐妹只需 1300 左右码住！！！💗 青岛一定要打卡的景点☀️ 银鱼巷：有很多装饰很有特色小店☀️ 网红墙：网红打卡地☀️ 小鱼山公园：风景比信号山更加开阔☀️ 鲁迅公园：随手就能拍到松柏蓝天大海☀️ 琴屿路：有棵树的位置是青岛顶流☀️ 第一海水浴场：去拍网红打卡的爱心树☀️ 石老人海水浴场：看日出绝美☀️ 小麦岛公园：适合看日落☀️ 第三海水浴场：晚上看灯光秀角度最佳🥘 青岛必打卡美食📍 众品老方子锅贴（大虾锅贴和墨鱼锅贴素三鲜都好吃很不错，特色甜沫和腊八蒜搭配起来好吃！！）📍 爱来客海鲜烧烤大排档（椒盐皮皮虾和 🦀 螃蟹拌面桌桌必备，海肠捞饭美味，海胆蒸蛋是真的肥，盲点每一道海鲜都不踩雷，好吃到人气很旺需要排队！！）📍 月光传奇（红豆车轮饼，饭后的小甜点！！） 青岛三天两夜！！！ 含泪整理的青岛三天两夜游玩路线，看了好多大家发的攻略，我们是住在小村庄地铁站附近，所以就按照这个起点花费一上午时间整理的路线，希望到时候不踩雷！！！等我玩回来再来修改！！！听劝！！！大家有去过的指点避雷！！！ 终于有人把青岛攻略说明白啦","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"旅游","slug":"旅游","permalink":"https://liangyuanzheng.com/tags/%E6%97%85%E6%B8%B8/"}]},{"title":"古文观止","slug":"古文观止","date":"2024-07-19T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"古文观止.html","link":"","permalink":"https://liangyuanzheng.com/%E5%8F%A4%E6%96%87%E8%A7%82%E6%AD%A2.html","excerpt":"","text":"1 古文观止1.1 《后出师表》——诸葛亮夫难平者，事也。昔先帝败军于楚，当此时，曹操拊手，谓天下已定。然后先帝东连吴、越，西取巴蜀，举兵北征，夏侯授首，此操之失计，而汉事将成也。然后吴更违盟，关羽毁败，秭归蹉跌，曹丕称帝。凡事如是，难可逆料。臣鞠躬尽力，死而后已。至于成败利钝，非臣之明所能逆睹也。","categories":[{"name":"诗词歌赋","slug":"诗词歌赋","permalink":"https://liangyuanzheng.com/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"古文","slug":"古文","permalink":"https://liangyuanzheng.com/tags/%E5%8F%A4%E6%96%87/"}]},{"title":"《SRE Google 运维解密》第 25 章 数据处理流水线","slug":"第-25-章-数据处理流水线","date":"2024-07-19T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"第-25-章-数据处理流水线.html","link":"","permalink":"https://liangyuanzheng.com/%E7%AC%AC-25-%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF.html","excerpt":"","text":"本章关注数据处理流水线在实际应用中面临的复杂问题。讨论了周期性运行的数据流水线与持续运行永不停止的数据处理流水线面临的共同问题，也讨论了它们的不同点。本章提出了一个崭新的、更可靠的、更易扩展的领头人、追随者模式（即 Master&#x2F;Slave 模式），可以用来替代处理海量数据的周期性流水线模型。 周期性流水线模式的挑战周期性的数据流水线模型是非常脆弱易坏的。初期调试后，整个流水线的性能可能很稳定。随着数据量的自然增长会对整个系统造成压力，导致各种各样的问题出现。这种问题包括任务运行超时、资源耗尽，某些分块处理卡住导致整体运维压力上升等。 工作分发不均分布式环境中周期性数据流水线的缺点对于每天运行一次的流水线来说，几个小时的启动延迟是可以接受的。但是随着执行频率增高，每次执行之间的最小间隔很快会与平均启动延迟持平，这就使得周期性数据流水线的执行延迟有了一个下限。超过这个阈值继续减少任务的执行间隔周期只会造成更多的问题而不能让任务执行得更快。 监控周期性流水线的问题 惊群效应 摩尔负载模式 Google WorkflowMaster&#x2F;Slave 分布式系统设计模式。 Workflow 中的执行阶段我们可以通过将工作进程进一步划分为更小的任务组，而将流水线的”深度“随意增加。每个任务组负责处理该执行阶段的数据，可以对某一小块数据进行任意操作。 工作进程处理前序阶段产生的工作单元，同时生产出新的输出单元。输出可以终止整个执行，也可以作为其他处理阶段的输入。 正确性保障 配置文件 租约 唯一文件名 服务器令牌 保障业务的持续性大数据处理流水线需要在各种失败条件下持续运行，包括光纤被切、天气状况、连锁性供电故障等。 Workflow 通过持续性运行的流水线完美地解决了这个难题。 分布式锁 小结周期性的数据流水线是很有价值的。但是如果一个数据处理问题本身是持续性的，或者会自然增长成为持续性的，那么就不要采用周期性的设计方式，而是采用一种类似 Workflow 的设计特点的系统。 我们发现带有强一致性的持续数据处理系统，就像 Workflow 这样，在分布式集群环境中工作性能和扩展性都非常好。这样一个系统能够周期性地提供可以依赖的结果，并且是一个非常可靠且稳定的可运维系统。 参考文献 https://sites.cs.ucsb.edu/~rich/publications/shao-hcw.pdf “Master&#x2F;Slave Computing on the Grid” https://en.wikipedia.org/wiki/System_prevalence “流式系统设计”","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"生涯彩虹图","slug":"20240718-生涯彩虹图","date":"2024-07-17T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240718-生涯彩虹图.html","link":"","permalink":"https://liangyuanzheng.com/20240718-%E7%94%9F%E6%B6%AF%E5%BD%A9%E8%99%B9%E5%9B%BE.html","excerpt":"","text":"生涯彩虹图生涯彩虹图是舒伯（Donald E.Super）为了综合阐述生涯发展阶段与角色彼此间的相互影响，创造性地描绘出一个多重角色生涯发展的综合图形。 根据萨柏的看法，一个人一生中扮演的许许多多角色就像彩虹同时具有许多色带。萨柏将显著角色的概念引入了生涯彩虹图。他认为角色除与年龄及社会期望有关外，与个人所涉入的时间及情绪程度都有关联，因此每一阶段都有显著角色。 图：生涯彩虹规划图使用实例（萨柏） 每个人都扮演着多种不同的角色，他们交互影响交织出个人独特的生涯类型。在人生的每一阶段要有不同的自我目标和社会期望。 各种角色之间是相互作用的，一个角色的成功，特别是早期的角色如果发展得比较好，将会为其他角色捏你良好的关系基础。但是，在一个角色上投入过多的精力，而没有平衡协调各角色的关系，则会导致其他角色的失败。在每一个阶段对每一个角色投入程度可以用颜色来表示，颜色面积越多表示该角色投入的程度越多，空白越多表示该角色投入的程度越少。 作用主要是对自身未来的各阶段进行调配，做出各种角色的计划和安排，使人成为自己生涯设计师。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"方法论","slug":"方法论","permalink":"https://liangyuanzheng.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"}]},{"title":"勤则百弊皆除","slug":"20240703-勤则百弊皆除","date":"2024-07-02T16:00:00.000Z","updated":"2025-10-27T00:35:41.794Z","comments":true,"path":"20240703-勤则百弊皆除.html","link":"","permalink":"https://liangyuanzheng.com/20240703-%E5%8B%A4%E5%88%99%E7%99%BE%E5%BC%8A%E7%9A%86%E9%99%A4.html","excerpt":"","text":"曾国藩 人生之败，非傲即惰，二者必居其一，然勤则百弊皆除。勤分六种：一、身勤：路虽远，行则必至；事虽难，做则必成。二、眼勤：遇一人，必详细观察；看一文，必反复审阅。三、手勤：易丢之物，随手拾之；易忘之事，随笔记之。四、口勤：他人之长，多夸多赞；自己之短，多学多问。五、心勤：精诚所至，金石为开，苦思所至，诸事皆通。六、脑勤：谋定而后动，知止而有得。万事皆有法，道正世则通。全勤才叫真正的勤。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"}]},{"title":"什么是字幕、有哪些格式？","slug":"什么是字幕、有哪些格式？","date":"2024-03-06T16:00:00.000Z","updated":"2025-10-27T00:35:41.795Z","comments":true,"path":"什么是字幕、有哪些格式？.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E5%B9%95%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%BC%E5%BC%8F%EF%BC%9F.html","excerpt":"","text":"最近做的工作和字幕生成有关，顺手整理了一些字幕相关的资料。本文简单介绍了字幕的基本知识和一些常见的字幕格式，一来备忘，二来共同学习。 1 什么是字幕1.1 定义字幕是指以文字形式显示电视、电影、舞台作品中的对话等非影像内容，也泛指影视作品后期加工的文字。 在电影银幕或电视机荧光屏下方出现的解说文字以及种种文字，如影片的片名、演职员表、唱词、对白、说明词以有人物介绍、地名和年代等都称为字幕。它是为了让原本无法了解音轨内容的观众看懂影片内容，包括为听障人士以及不懂影片源语的人士提供便利。这些字幕按照影片放映时出现的先后顺序而分为片头字幕、片间字幕和片尾字幕。一般情况下，片头、片尾字幕叠印在画面上，而对白、歌词等字幕一般出现在屏幕下方，戏剧等舞台伤口则显示于舞台两侧或上方。 字幕的作用主要是将语音内容以文字方式显示，以帮助听力较弱的观众理解节目内容。 另外，对于不同语言的观众，只有通过字幕才能了解影片内容。而在中国，不同地区语言的发音差别很大，不能正确理解普通话的人很多。但是文字写法的差异并不大，看到普通话的文字后人们大都都能理解。所以，近年来华语圈的影视作品中，对应普通话（或方言）的字幕大多被附加在节目中。 1.2 字幕的历史早在电视电影诞生之初，字幕就已随之出现。最早的字幕形式可以追溯至无声时代的字幕卡（intertitles）。字幕卡的最早应用是在 1903 年 Edwin S. Porter 导演的电影《汤姆叔叔的小屋》中，字幕伴随人类科技的发展，其历史已逾百年。 世界上第一部加字幕的有声电影是美国影片《爵士乐歌星》（The Jazz Singer），这部电影 1927 年 10 月 6 日在美国上映，1929 年 11 月 26 日在法国巴黎上映时首次引入了字幕这个概念，可以算得上字幕历史上的标志性事件。后来随着艺术形式的发展，又出现了唱词字幕（surtitles），在美国被称为 supertitles，它出现在舞台歌剧中，1983 年加拿大歌剧 Elektra 中出现的唱词字幕。 2 字幕的种类字幕的类型可以根据不同的标准进行分类： 根据应用方式 硬字幕：直接嵌入在视频画面中，与画面融为一体，兼容度最高，但不可编辑或修改。 软字幕：通过工具将外挂字幕与视频画面压制打包到一起，表面上是一个视频文件，但也可以分离出来编辑或修改。 外挂字幕：单独将字幕制作成一个文件，在播放时同时播放，可以随时编辑修改。 根据文件格式 图形格式字幕：由 idx 和 sub 文件组成，有时也能看到 ifo 文件，但这个现在已经不怎么用了。 根据表达内容 对话字幕：包括人物的对话、独白、旁白，以及歌词字幕，大多数位于荧幕的中下方位置。 信息字幕：与视频内容息息相关，但大多数时候与人声不关联，比如注解、说明性、过渡性字幕，片名、人名条、主创团队、主创成员、合作伙伴、片尾演职人员名等。 特效字幕：用于活跃气氛、突出品牌形象以及市场宣传，常见的包括台标、水印、角标、水印广告或花字配字等。 根据控制形式 静态字幕：位置固定，不随视频内容变化而变化。 游动字幕：位置随视频内容变化而变化。 滚动字幕：位置固定，但内容会滚动更新。 3 字幕格式字幕可分为片名标识等说明性字幕，及对白等帮助理解内容的语言字幕。对于视频制作时出现的片名、说明性字幕，一般在影视后期制作时叠加到了视频画面中，没有什么格式可言。这是所说的格式，是指现在网络上流传的影视对白字幕。目前比较流行的字幕格式，分为图形格式和文本格式两类。 3.1 图形格式字幕由 idx 和 sub 文件组成，有时也能看到 ifo 文件，不过这个现在已经不怎么用的上了。idx 相当于索引文件，里面包括了字幕出现的时间码和字幕显示属性等，sub 文件就是存放字幕本身了，注意是图片格式的，所以比较大，动辄 10M 以上了。idx+sub 可以存放很多语言的字幕，提供了在播放的时候的选择。 3.2 文本格式字幕比较流行的文本字幕有 srt、ssa、smi、ass 格式，因为是文本格式，所以就比较小了，一般大不过百来 K。 SRT 格式，SRT 三大核心构成部分： ① 轴编号 ② 开始和结束时间码 ③ 字幕文本 1234500:02:52,184 --&gt; 00:02:53,617慢慢来 这表示：第 45 个字幕，显示时间从该影片开始的第 2 分 52.184 秒到第 2 分 53.617 秒，内容为：慢慢来。格式规范请参阅下图，不符合本规范的字幕文件，可能无法被字幕软件或视频播放器识别。 SSA、ASS 格式SSA（Sub Station Alpha）是为了解决 SRT 过于简单的字幕功能而开发的高级字幕格式其扩展名为.SSA。采用 SSA V4 脚本语言，能实现丰富的字幕功能，除了能设定不同字幕数据的大小和位置外，更能实现动态文字和水印等复杂的功能。ASS（Advanced SubStation Alpha）其实是更高级的 SSA 版本，采用 SSA V4+脚本语言编写。 ASS 格式ASS 相对 SRT 来讲，最大的特点是可以定义样式风格（字幕字体、颜色、位置、大小、特效等），因此相对来讲，它新增了： ① 脚本信息（script info）文件 ② V4+Styles 风格文件 ③ Events（它包括了 SRT 中的时间轴和字幕文字） SMI 格式SMI（Sami），其扩展名为.smi，是 Windows Media Player 专用字幕文件格式，如果在播放的文件目录中有格式正确且与歌曲同名的 SMI 文件，那么 WMP 都会识别。SMI 和 SRT 一样都是文本字幕格式，可以用记事本或者 E-Lyric 打开进行编辑。 vtt 格式VTT 文件是一个文本文件，其中包含使用 Web 视频文本轨道 (WebVTT) 格式显示定时文本轨道（例如字幕或字幕）的信息。定时文本轨道包括诸如字幕或字幕之类的信息。 VTT 文件的目的是将文本覆盖添加到.格式有点类似于 SRT 文件。基于 WebVTT 的文本文件使用 UTF-8 编码。 VTT 文件包含诸如字幕、描述、标题、描述、章节和元数据等信息。作为纯文本文件，可以使用 Microsoft Notepad、Apple TextEdit 和 Notepad++ 等文本编辑器打开 VTT 文件。 123456789WEBVTTKind: captionsLanguage: en00:09.000 --&gt; 00:11.000&lt;v Roger Bingham&gt;We are in New York City00:11.000 --&gt; 00:13.000&lt;v Roger Bingham&gt;We are in New York City 4 参考文献 字幕（百度百科） 字幕文件有哪些格式? 视频文字稿 视频文件格式 WebVTT（维基百科）","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"协议","slug":"协议","permalink":"https://liangyuanzheng.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"字幕","slug":"字幕","permalink":"https://liangyuanzheng.com/tags/%E5%AD%97%E5%B9%95/"},{"name":"km","slug":"km","permalink":"https://liangyuanzheng.com/tags/km/"},{"name":"公众号","slug":"公众号","permalink":"https://liangyuanzheng.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"已发布","slug":"已发布","permalink":"https://liangyuanzheng.com/tags/%E5%B7%B2%E5%8F%91%E5%B8%83/"}]},{"title":"AI 应用","slug":"AI-应用","date":"2023-03-05T10:23:20.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"AI-应用.html","link":"","permalink":"https://liangyuanzheng.com/AI-%E5%BA%94%E7%94%A8.html","excerpt":"","text":"图灵测试1950 年，图灵发表一篇名为《计算机器与智能》的论文，被誉为人工智能科学的开山之作。文中提出了图灵测试。 机器能思考么？ 换言之，男人 –&gt; 机器，询问者判断错误的概率会不会发生变化？ 图灵测试的目的：提供一个评估“机器能否思维”的方法。 70 年后，仿佛它来了？ChatGPT目前最接近“六边形”战士的聊天机器人。 ChatGPT（Chat Generative Pre-Trained Transformer）是由 OpenAI 开发的人工智能聊天机器人程序，其基于 GPT-3.5 大模型，能够完成相对复杂的语言处理任务，包括人机对话、自动文本生成、自动摘要、编写代码等，在 2022 年 11 月推出，上线两个月后用户数量即达到 1 亿规模，在全球范围内掀起又一轮 AI 热潮。 令人惊艳的能力帮你安慰女友 写电影故事 有逻辑地回答文史问题 协助程序员工作 哲学思考，我们如何过好这一生？ 为什么这么牛？ 有上下文记忆能力：多轮对话衔接地很好，很难看出是机器生成的； 有学习纠错能力：在它回答错误之后，如果你纠正了它，第二次就不会再答错； 有思维推理能力：具备一些常识知识，能做复杂一些的算数题； 数据 维度 初代 GPT GPT-2 GPT-3 时间 2018 年 6 月 2019 年 2 月 2020 年 5 月 参数量 1.17 亿 15.4 亿 1750 亿 预训练数据量 5GB 40GB 45TB 训练方式 Pre-training + Fine-tuning Pre-training Pre-training 序列长度 512 1024 2048 # of Decoder Layers 12 48 96 Size of Hidden Layers 768 1600 12288 原理先问 ChatGPT——你是谁？ 它是这样解释的： GPT 是基于Transformer架构的预训练语言模型，可以生成自然语言文本。Transformer是基于自注意力机制的深度学习模型架构，它在自然语言处理领域中得到了广泛的应用，如机器翻译、文本分类和生成模型等。 GPT 是基于Transformer模型的改进版本，主要是针对生成任务进行了优化，通过预训练学习自然语言的语义和语法规律，进而生成高质量的文本。 因此，GPT 可以看作是Transformer模型在生成任务上的一个应用扩展。 Transformer Transformer：用于自然语言处理（NLP）的神经网络架构。 Transformer 架构使用了注意力机制，能够处理长序列的依赖关系。 这让它具有以下明显优点： ❶ 并行计算：由于自注意力机制的引入，Transformer 可以实现并行计算，加快训练速度。 ❷ 长序列处理：相比传统的循环神经网络和卷积神经网络，Transformer 可以处理更长的序列，这是由于自注意力机制可以学习到全局的序列信息。 ❸ 模块化结构：Transformer 由编码器和解码器两部分组成，每部分都包含了多层相同的模块，这种模块化结构使得 Transformer 更易于扩展和调整。 Transformer 在各种任务中的表现,也将不断得到改善和优化，发展日新月益。 自2017 年推出之后， Transformer 已经形成了自己的家族体系。 2017 年，Google 发表《Attention is all you need》，完全使用 Attention 机制的 Transformer 模型开始主导 NLP 领域。 基于 GPT 架构，ChatGPT就隐藏在GPT-3的后面。 RLHF 技术根据 OpenAI 的介绍，ChatGPT 是在 2022 年初训练完成的 GPT-3.5 系列模型的基础上调优而来。ChatGPT 使用了与另一款 GPT-3.5 系列的模型 InstructGPT 相近的方法——基于人类反馈的强化学习（Reifocement Learning from Human Feedback，RLHF）。团队收集了 AI 与人类对话的数据，既包括人类自己的也包括 AI 的， AI 训练师可以参照建模建议写出自己的答案。 对于强化学习奖励模型，OpenAI 记录了 AI 训练师和聊天机器人之间的对话。然后，该团队随机选择了一个人工智能利用不同自动补全功能生成的回复，并让训练师对其进行评分。在进行微调时，OpenAI 使用了近端策略优化（proximal policy optimization），这个过程会反复进行多次。 第一步，使用有监督学习方式，基于 GPT3.5 微调训练一个初始模型，训练数据约为 2w~3w 量级（此处为推测量级，我们根据兄弟模型 InstructGPT 的训练数据量级估算）。由标注师分别扮演用户和聊天机器人，产生人工精标的多轮对话数据。值得注意的是，在人类扮演聊天机器人时，会得到机器生成的一些建议来帮助人类撰写自己的回复，以此提高撰写标注效率。 以上精标的训练数据虽然数据量不大，但质量和多样性非常高，且来自真实世界数据，这是很关键的一点。 第二步，收集相同上文下，根据回复质量进行排序的数据：即随机抽取一大批 Prompt，使用第一阶段微调模型，产生多个不同回答：,,…，之后标注人员对 k 个结果排序，形成组训练数据对。之后使用 pairwise loss 来训练奖励模型，可以预测出标注者更喜欢哪个输出。**”从比较中”学习可以给出相对精确的奖励值**。 这一步使得 ChatGPT 从命令驱动转向了意图驱动。 第三步，使用 PPO 强化学习策略来微调第一阶段的模型。这里的核心思想是随机抽取新的 Prompt，用第二阶段的 Reward Model 给产生的回答打分。这个分数即回答的整体 reward，进而将此 reward 回传，由此产生的策略梯度可以更新 PPO 模型参数。整个过程迭代数次直到模型收敛。 强化学习算法可以简单理解为通过调整模型参数，使模型得到最大的奖励（reward），最大奖励意味着此时的回复最符合人工的选择取向。而对于 PPO，我们知道它是 2017 年 OpenAI 提出的一种新型的强化学习策略优化的算法即可。它提出了新的目标函数，可以在多个训练步骤实现小批量的更新，其实现简单、易于理解、性能稳定、能同时处理离散&#x2F;连续动作空间问题、利于大规模训练。 以上三个步骤即 ChatGPT 的训练过程，合称为文献中提到的RLHF 技术。 AI+应用软件结合AI+工具类软件：文字、图片、音频、视频、3D 模型 文字类： Notion AI Office（微软计划将 ChatGPT 接入） 式说（第四范式） Notion AI 能基于简单指令生成丰富的文字内容。Notion AI 是用于 Notion 产品的人工智能工具，通过集成机器学习和 NLP 技术，帮助用户提高文字创作的效率和体验。在 AI 大规模语言模型赋能下，用户只需要罗列出基本需求，产品即可自动生成丰富的文字内容，文字内容的类型覆盖会议议程、销售邮件、新闻发布稿等多种场景。Notion AI 还拥有总结、改错、翻译、续写、头脑风暴等功能；后续 Notion AI 还将会成为 Notion 知识库的接口，用户只需要输入搜索要求，Notion AI 即会自动呈现相关信息。我们预期 Notion AI 的自动文本生成、文本摘要、文本编辑等功能或将大大优化用户的创作流程和使用体验，帮助 Notion 的产品力实现跃升。 图片类 Stable Diffusion、Midjourney（Stability AI） DALL-E（OpenAI） Imagen（谷歌） 天工巧绘（昆仑万维） 万兴爱画（万兴科技） DALL·E DALL·E 由 OpenAI 率先推出，并于 2021 年通过 Azure OpenAI 服务开始将其技术商业化，2022 年 4 月发布升级版 DALL·E 2。凭借 OpenAI 在 2021 年发布的基于 GPT-3 的图像文本匹配模型 CLIP，DALL·E 2 具备了联系文本和视觉图像的能力；又通过基于 Diffusion 的图像生成模型 GLIDE，DALL·E 2 能够按照文本生成逼真的图像，分辨率提升了 4 倍，准确率更高，并且业务更广，具备三种功能：1）根据文本提示生成图像，2）以给定图像生成新图像，3）以文本编辑图像元素。 音频类 AudioLM、MusicLM（谷歌） VALL-E（微软） Dance Diffusion（Stability AI） Jukebox（Open AI） 讯飞配音 百度语音合成 腾讯智影 MusicLM：这是一种从文本描述中生成高保真音乐的模型，例如用户可以输入“平静的小提琴旋律伴随失真的吉他即兴演奏”。MusicLM 将条件音乐生成过程转换为层次化的 Seq-to-Seq 建模任务，并能够保持 24 kHz 的频率生成一段几分钟的音乐，无论是文本描述还是音频质量都优于之前的模型。此外，MusicLM 还能够基于文本的描述转变原来的旋律、根据图片画作和文字描述生成对应的音乐伴奏。 视频类 Designs.ai Make-A-Video（Meta） Lumen5 Imagen Video、Phenaki（谷歌） GEN-1（Runway） 万兴播爆（万兴） VidPress（百度） 商汤智影 Make-A-Video 能够基于文本生成视频。Make-A-Video 是 2022 年 7 月 Meta 发布的文本生成图像模型 Make-A-Scene 的进一步升级。通过向 Make-A-Video 输入文本即可生成数秒的视频，支持不同的视频风格。除了文本生成视频，Make-A-Video 还能够实现输入单个或两个图像来创建运动，即图像生成视频。 图表：通过向 Make-A-Video 输入文本生成的视频 3D 模型 Creo Autodesk Fusion360 Solid Edge Solidworks AI+搜索引擎：借助自然语言处理将传统的搜索点击转变为互动问答形式，并生成个性化结果 微软：NewBing 搜索引擎 Google：？ 百度：文心一言 机遇与挑战业务篇产品结构 商业逻辑 技术革命我们将 AGI 看作一个新的技术革命，可能对传统产业格局带来冲击。类比云计算时代，Salesforce 等新兴 SaaS 厂商把握“上云”新趋势，异军突起“超车”SAP 等老牌软件厂商；而 Oracle、微软等传统厂商的云转型成效也直接影响其市场影响力演变趋势。事实上，目前已有一批 AIGC 相关独角兽正快速发展，在未来的 AI 融合应用时代，我们认为原生于 AI 的新兴厂商的出现及传统厂商 AI 转型效果都可能给现有的竞争格局带来改变。 个人篇专业思辩 无法理解人类语言和文化； 不能展现人性，感到人的温暖； 其实 chatgpt 的回答就是一套结构化的语言，什么是结构化语言：情况就是这么个情况，具体什么情况还得看情况。 注意 ChatGPT 火的原因，是事件火还是技术本身； 长尾问题回答的不好； …… 以下摘录自《阿兰·图灵：计算机器与智能》 来自神学的反对意见（１）来自神学的反对意见。思维是人的不朽灵魂的一种功能。上帝赋予每一个男人和女人以一颗不朽的灵魂，但从未将它赋予任何其他的动物或机器。因此，动物或者机器不能思维。 尽管我不能接受这种看法，但我试图用神学的语言来回答这个问题。如果将动物和人划为一个类别，我认为这个观点更有说服力；因为，在我看来，生物与非生物之间的差别远远要比人和其他动物之间的差别大得多。如果这种正统的观点出现在其他宗教社会里，它的主观武断性就更加明显了。伊斯兰教认为妇女没有灵魂，基督教对此有何感想？但是，现在暂不管这一点，让我们回到问题的焦点上来。在我看来，上面所引的论点对上帝威力的万能性有很大的限制。上帝对有些事情也是无能为力，比如，无疑他不能让１等于２；但是，我们难道不应该相信，要是上帝觉得合适，他完全可以赋予一头大象以灵魂吗？我们可以希望，上帝可以通过自己的威力造成变种，由于变种，大象有了一个较发达的大脑，可以用来满足灵魂的需求。同一形式的论点也可以用来解释机器。只是看上去也许有点不一样，因为“轻信”就不那么容易了。但这其实只能说明，我们认为上帝不太可能觉得这些环境适合于授予灵魂。关于环境问题我们将在本文的其余部分进行讨论。在企图制造这样的机器时，我们不应该无礼地篡夺上帝创造灵魂的权力，就像不应该剥夺我们生儿育女的权力那样；在两种情况下，我们其实都是上帝意志的工具，为他所创造的灵魂提供住所。 然而，这仅仅是猜想而已。不管能用神学的论据来证明什么，我仍不以为然。过去已经证明这样的论据是漏洞百出的。在伽利略的时代，就有人提出，“太阳一动不动地悬着……整天都不慌不忙，不想落下”（《约书亚书》，10。13）以及“他为大地奠定基础，叫它永远不动摇”（《诗篇》，105。5)这些经文正好用来驳斥哥白尼的理论。从我们今天的知识来看，就觉得提出这种论据是徒劳的。过去没有这样的知识，情况便大不一样了。 所谓”鸵鸟政策”式的异议（２）所谓”鸵鸟政策”式的异议。”机器思维后果太令人恐惧了。但愿机器永远不会有思维。” 这种观点不如上面的说法那样直言不讳。但它对我们许多人都有影响。我们都倾向于认为人类的某个微妙的方面比其他生物要优越。要是能证明人一定是高一等的，那再好不过了，因为那样的话，他高居一切之上的地位就不会有危险了。神学的论点那样流行，很明显是与这种情绪密切有关。这种看法在知识分子中会更普遍，因为他们比其他人更尊重思维能力，因此也就对人类思维能力的优越性更加深信不疑。 我认为这个论点不怎么重要，不值得一驳。安慰一下也许更合乎情理；这种安慰也许能在灵魂轮回说中找到。 来自数学的异议（３）来自数学的异议。在数学逻辑里有一些结论，可以用来证明离散状态的机器的能力有一定限度。这些结论中最著名的是哥德尔定理，此定理声称，在任何一个足够有力的逻辑系统里，都能形成陈述，而所作陈述在本系统范围之内既不能被证明是对的，也不能被证明是错的，除非这个系统本身就不一致。丘奇、克利恩、罗瑟和图林等人也有别的在某些方面同哥德尔定理很相似的结论。图林的结论更容易考虑，因为它直接涉及机器，而其他人的结论相对来说是间接的：比方说，如要使用哥德尔定理，我们还需要某些附加手段，通过机器来描述逻辑系统，而要描述机器还需要再通过逻辑系统。这个结论涉及一种机器，它实质上是一台万能的数字计算机。即使是这样一台机器，它对有些事情也是无能为力的。如果计算机被设计成能在模似游戏中回答问题的话，那么对有些问题它是无法给予正确答复的，而对另一些问题，不管你给它多长时间，它也答不上来。当然，尽管这台机器回答不了许多问题，但另一台机器却能给予满意的解答。我们现在只假定，对这些问题只要回答“是”或者“不是”就行了，不会出现像“你认为毕加索怎么样？”这类的问题。我们知道机器必定无法回答的问题是下述这类问题：”这台机器有以下特点……这台机器会不会对任何问题作出‘是’的回答？”这里省略的是对某台标准形式机器的的描述……如果所描述的机器与那台被提问的机器具有某些相对简单的联系，那么，我们就能知道，答案不是错了，就是压根儿没有答案。这就是数学的结论，此结论认定机器能力有限，而人类智能则没有这种局限性。 如果想对这个论点作一简要的答复，我们就能指出，尽管它已经证明任何一台特定的机器都是能力有限的，但它并没有任何证据说，人类智能就没有这种局限性。但我认为这个论点不能就这么轻易了结。每当其中一台机器遇到一个合适的问题，并作出我们明知是错的回答时，我们无疑会产生一种优越感。这种优越感难道不会是错觉吗？这种感觉无疑是真实的，但我觉得这并没有多大意义。我们自己平时也经常对问题作出错误的回答，因此，就没有权利因机器犯了错误而沾沾自喜；当然，我们对付一台机器当然易如反掌，但我们无法同时对付所有的机器而且不出差错。一句话，有可能人比一台特定的机器聪明，但也有可能别的机器更聪明，如此等等。 我认为，那些持数学异议的人大多数愿意接受模似游戏作为讨论的基点。而持前两种反对意见的人不大会对什么标准问题感兴趣。 来自意识的论点（４）来自意识的论点。这个论点在斐逊教授 1949 年的李斯德演说中阐述得很明确，我摘引了其中的一段话：“若要我们承认机器与大脑是一样的，除非机器能够因为感受了思想与感情，而不是符号的偶然涂抹写出十四行诗或协奏曲来。也就是说，它不仅写了，而且也应知道自己确实这样做了。任何机器都感觉不到（不只是属于简易发明之类的人工信号）成功的喜悦，也不会因困难而沮丧，因受奉承而沾沾自喜，因犯错误而闷闷不乐，因见异性而神魂颠倒，也不会因欲望得不到满足而暴跳如雷或一蹶不振。” 这个论点看上去否定了我们测试的有效性。按照这种观点的最极端形式，你若要肯定一台机器是否能思维，唯一的途径就是成为那台机器并且去感受自己的思维活动。这样的话，他就能够向众人描述他自己的感觉，当然，没有人会知道这些话是不是实话。同样，依照这个观点，要想知道某人是否在思维，唯一的途径就是成为那个特定的人。这实际是唯我论的观点。这也许是符合逻辑的，但若真是这样，那思想交流就太困难了。Ａ会说，“Ａ在想，而Ｂ不在想”。而Ｂ会说，“Ｂ在想，而Ａ不在想。”我们犯不着为这个观点争执不休，我们不如客客气气地认为大家都在想。 我肯定斐逊教授不愿意采纳这样一个极端的唯我论的观点。他倒有可能愿意把这个模似游戏当作一个测试。模拟游戏（省略了游戏者Ｂ）在实际中经常采用”口试”形式，来鉴定某人的真的理解了，还仅仅是“鹦鹉学舌”，让我们看一看这种“口试”的情形： 提问者：你的十四行诗的第一行是这样的，“我欲比君为夏日，如何？”要是将“夏日”改成“春日”，是不是也可以，或许会更好？ 证人：这样一改便不合韵了。 提问者：改为“冬日”怎么样？这样也会合韵。 证人：是没问题。但是有谁愿意将自己比作冬日呢？ 提问者：你认为匹克威克先生会使你联想起圣诞节吗？ 证人：在一定程度上，会的。 提问者：但是圣诞节是在冬天，我认为匹克威克先生对这个比喻不会在意。 证人：我在想你也许在开玩笑。冬日的意思是指某一个典型的冬日，而不像圣诞节那样特殊的一天。 这里不再赘引。如果那台写十四行诗的机器在这场“口试”中能够这样对答，杰斐教授会作何感想呢？我不知道他是不是会认为，机器只是在“机械地通过发信号”而作出这些答复；但是，如果这些答复如上面所引那样令人满意，前后一致，我认为他不会再把机器当作“一个属于简易发明之类的人工信号”。所谓“属于简易发明的人工信号”指的是一架机器的一些设计功能，可以用来播放一个人念十四行诗的录音，只要拨动键钮，你随时都可以听到这段录音。 综上所述，我认为大部分支持来自意识的异议的人都可以经过劝说而放弃原来的主张，不致于陷入唯我论的困境。这些人因此也就有可能愿意接受我们的测试。 我并不想给大家留下这样一个印象，即我认为意识并没有什么神秘之处。比方说。要想确定意识在人体中的位置，就是一个谜。但是，如果我们没有解决这些谜，还是能够回答这个与本文有关的问题的。 来自种种能力限制的论证（５）来自种种能力限制的论证。这些论证一般是这样一种说法：“我担保，你可以使机器干任何你刚才提到的事情，可你永远也不能使一台机器有Ｘ类的行为。”这类行为包括许多特征。我在这里援引一例： 要和蔼、机灵、美丽、友好……富于首创精神、富于幽默感、善于明辨是非、会犯错误……会坠入情网，喜欢草莓和奶油……能使别人钟情于它，通达世故……措词得当，长于反思……像人一样行为多姿多彩，富于创新…… 说这些话一般都用不着证明。我认为这些话都是以科学归纳的原则为基础的。一个人在他一生中看到过成百上千台机器。他由所见所闻得出一些普遍的结论。它们形态丑陋，应用范围狭窄，只要范围略有变动，它们就束手无策。此外，它们的行为方式也非常单一，等等，等等。他很自然地认为，这就是机器大体上的必备特征。大部分机器的能力限制与机器储存量太小有关（我在设想，储存量这个概念可以通过某种方式进行扩充，它不仅仅包括离散状态的机器，也包括其他机器。因为目前讨论还不需要讲究数学的准确性，所以定义准确问题并不要紧）。数年前，由于数字计算机在社会上还鲜为人知，要是你光说其特征而不提其构造，那么，你们就会以为你在信口开河。我想这也是因为人们使用了科学归纳原则的结果。当然，人们在使用这个原则时，大都是无意识的。一个小孩一朝被火烫，十年怕烛台，我认为他这就是在使用科学归纳（当然，我也可以用许多别的方式来解释这一现象）。人类的行为和习惯看上去不适合运用科学归纳。如果你想获得可信赖的结果，你就要对时空的大部分进行研究。要不然的话，我们会（就像许多说英语的儿童那样）以为世界上所有的人都讲英语，再去学法语真是傻透了。 然而，关于我们刚才提到的许多能力限制，还要特别说几句，说机器没有能力享受草莓和奶油，这种说法会使读者觉得有点轻率。我们有可能使机器喜欢这些美味，但任何强迫这样做的企图都是愚蠢的。值得重视的是，这种能力限制对解释其他能力限制也有影响。比如，难以使人与机器之间形成那种像白人与白人之间，或是黑人与黑人之间的友好情感。 认为“机器不会出差错”这种想法有点令人费解。我们不禁要反问：“它们出了错就更糟了吗？”让我们站在同情的立场上，看看这究竟是什么意思。我想我们可以用模拟游戏来解释这种说法，有人声称，在游戏中提问者可以向被试问几道算术题来分辨是哪个机器，哪个是人，因为机器在回答算术题时总是丝毫不差。这种说法未免太轻率了。（带模拟游戏程序的）机器并没有准备给算术题以正确的答案。它会故意算错，以蒙骗提问者。机器在做算术题时，由于对要出现什么样的错误作出了不妥当的决定，因而显示了机械的故障。我们对这种观点作这样的理解，其实也不太富有同情心。但是，我们对这个问题限于篇幅不可能进一步讨论。在我看来，这个观点的根源在于混淆了两个不同性质的错误。这两个错误我们称之为“功能错误”和“结论错误”。功能错误是由某些机械或电器故障引起的，这些故障导致机器不能够按照指令工作。在进行哲学讨论时，我们很容易忽视发生这种错误的可能性；这样的话，我们实际上是在谈论“抽象的机器”。而这些抽象的机器与其说是实在的物体倒不如说是数学的虚构。从定义上讲，我们完全可以这么说：“机器从不出差错。”当某一意思与来自机器的输出信号联在一起时，就会产生结论的错误。比方说，机器能够自动打出数学方程或英语句子。当机器打出一个错误的命题时，我们就认为这台机器犯了结论错误。很明显，找不到丝毫理由说，机器从不犯这类错误。一台机器有可能别的什么也不能做，只会连续打出“0 ＝ 1”。举这样一个例子也许太过分了，我们可以换一个例子：机器会想办法通过科学归纳来得出结论。这种办法有时无疑会导致错误的结果。 有人说，机器不能成为它自己思维的主体。如果我们能证明机器的某些思维是有某些主题的话，我们就能驳回这种说法。尽管如此，“机器活动的主题”确实有点意义，至少对于研究它的人来说是这样的。比如，如果一台机器试图解 X^2^-40X-11 ＝ 0 这个方程式，我们不禁会认为，这时，这个方式本身就是机器主题的一部分。从这种意义上说，机器无疑能够成为它自己的主题。这对编排它自己的程序，对预测因本身结构变化带来的后果都会有所帮助。机器能够通过观察自己行为的结果，修改自己的程序，以便更有效地达到某种目的。这并不是乌托邦式的空想，而是不久的将来可能办到的事。 有人批评说，机器的行为比较单一。这也就是说，机器不能够有很大的存储能力。直到最近，达到 1000 字节的存储量都很罕见。 我们现在这里考虑一些反对意见实际上是都是来自意识的那个异议的改头换面。通常，如果我们坚持认为，一台机器有能力做完其中的一件事，并对机器所能采用的方法进行描述。那么，不会给别人多深印象。人们会认为机器所使用的方法（不管是什么方法，总是机械性的）实在太低级了。请参见前面所引斐逊演讲中括号内的话。 洛夫莱斯夫人的异议（６）洛夫莱斯夫人（译注：爱达，第一个程序员）的异议。 洛夫莱斯夫人的回忆录中曾对巴比奇的分析引擎作过详尽的记述。她这样写道：“分析引擎没有任何意图要想创作什么东西。它能做我们知道该怎样去指挥它做的任何事。”（重点为她所知）哈特里引用了这段话，并补充道：“这并不是说，就不可能制造能‘独立思考’的电子设备，（用生物学的话说）在这种设备里，我们能够引起可以用来作为‘学习’基础的条件反射。从最近的一些发展情况 看，这种设想从原则上说是不是有可能，已经引起人们的极大兴趣和关注。但是，当时制造的那些机器并不具备这些特点。” 在这点上我完全同意哈特里的看法，我们会注意到，他并没有断言当时的机器还不具备这个特点，他倒是指出了，洛夫莱斯夫人所能获得的证明还不足以使她相信这些机器已具备了这个特点。从某种意义上讲，这些机器已具备了这个特点，这是极有可能的，因为，我们可以设想某些离散机器有这个特点。分析机实际上是一台万能数字计算机。因而，如果它的存储能力和速度达到一定水准，我们就能通过适当的程序使它模仿我们讨论的机器。也许伯爵夫人或巴贝奇都没有想到这一点。无论怎么说，他们不必能提什么要求，便提什么要求。 洛夫莱斯夫人的异议还有另外一种说法，即机器“永远也不能创新”。这种说法可以用一句谚语“世上无新事”抵挡一阵。谁能保证，他的“独创性成就”就不是接受教育的结果，就不是因循著名的普遍原则的结果？这种异议还有另一个稍稍好一点的说法，即机器永远也不能“使我们惊奇”。这种说法有点直截了当，我能够针锋相对地加以反驳。机器经常令我吃惊。这主要是由于我对机器能做什么估算甚少，更确切地说是由于即使我做了估算，也匆匆忙忙，马马虎虎。我也许这样对自己说：“我认为此处的电压应与彼处相同；不管怎么样，就当是一样吧。”我自然经常出错，结果我大吃一惊，因为一俟实验完成，这些假设早被忘得一干二净了。我对自己的这些错误开诚布公，但在我证实了所惊讶的事时，人们也不会认为我在信口开河。 我的回答并不会使批评者就此缄口沉默，他也许会这样做，所谓大吃一惊都是因为我自己富于想象力的心理活动，与机器本身毫不相干。这样，我们重又回到来自意识的那个论证上去，而背离了吃惊不吃惊的话题。我们不得不认为这种论证方式是封闭式的，但是，也许值得一提的是，要将某物认作会使人惊奇的，则需要许多“富于想象力的心理活动”，不管这件令人吃惊的事件是由一个人、一本书、一台机器还是任何别的东西引起的。 我认为，那种认为机器不会令人吃惊的观点是由这样一个为哲学家和数学家特别容易犯的错误引起的。它是这样一个假设，即心灵一接受了某个事实，由此事实所引起的一切后果都会同时涌入心灵。在许多情况下，这种假设十分有用，但是，人们会情不自禁地忘了这是个错误的假设。如果照这样做的话，其必然结果就是认为，仅仅从数据和普遍原则得出结论会毫无效力可言。 结语：ChatGPT 通过图灵测试了么？ 或许，答案本身已经不重要了…… 参考文献 人工智能见证了人类所有的自虐 ChatGPT 深度解析：GPT 家族进化史 ChatGPT-地表最强 AI 模型！要消灭人类？ 中金 | AI 十年展望（六）：ChatGPT 兴起，创成式 AI 能否重塑工具软件底层逻辑？ Transformer——ChatGPT 幕后的真正大佬 详解 Transformer （Attention Is All You Need） InstructGPT 计算机器与智能","categories":[{"name":"AI","slug":"ai","permalink":"https://liangyuanzheng.com/categories/ai/"}],"tags":[{"name":"ChatGPT","slug":"chatgpt","permalink":"https://liangyuanzheng.com/tags/chatgpt/"},{"name":"图灵测试","slug":"图灵测试","permalink":"https://liangyuanzheng.com/tags/%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95/"}]},{"title":"《活着》摘录","slug":"活着","date":"2023-03-02T16:00:00.000Z","updated":"2025-10-27T00:35:41.796Z","comments":true,"path":"活着.html","link":"","permalink":"https://liangyuanzheng.com/%E6%B4%BB%E7%9D%80.html","excerpt":"","text":"《活着》摘录1、没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切。 2、以笑的方式哭，在死亡的伴随下活着。 3、人是为活着本身而活着，而不是为了活着之外的任何事物所活着。 4、人类无法忍受太多的真实。 5、做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。 6、生的终止不过一场死亡，死的意义不过在于重生或永眠。死亡不是失去生命，而是走出时间。 7、一个人命再大，要是自己想死，那就怎么也活不了。 8、少年去游荡，中年想掘藏，老年做和尚。 9、人啊，活着时受了再多的苦，到了快死的时候也会想个法子来宽慰自己。 10、我沉湎于想象之中，又被现实紧紧控制，我明确感受着自我的分裂。 11、内心让他真实地了解自己，一旦了解了自己也就了解了世界。 12、检验一个人的标准，就是看他把时间放在了哪儿。别自欺欺人；当生命走到尽头，只有时间不会撒谎。 13、只要一家人天天在一起，也就不在乎什么福分了。 14、人老了也是人，是人就得干净些。 15、鸡养大了变成鹅，鹅养大了变成羊，羊大了又变成牛。 16、人死像熟透的梨，离树而落，梨者，离也。 17、活着是自己去感受活着的幸福和辛苦，无聊和平庸；幸存，不过是旁人的评价罢了。 18、女人都是一个心眼，她认准的事谁也不能让她变。 19、人要是累得整天没力气，就不会去乱想了。 20、人都是一样的，手伸进别人口袋里掏钱时那个眉开眼笑，轮到自己给钱了一个个都跟哭丧一样。 21、生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的看法。 22、外人看来是悲剧，可当事人只拿它当一段人生。 23、生命中其实是没有幸福或者不幸的，生命只是活着，静静地活着，有一丝孤零零的意味。 24、生活是属于每个人自己的感受，不属于任何别人的看法。 25、被命运碾压过，才懂时间的慈悲。 26、我们会来到这个世界，是不得不来；我们最终会离开这个世界，是不得不离开。 27、做人还是平常点好，争这个争那个，争来争去赔了自己的命。 28、生活和幸存就是一枚分币的两面，它们之间轻微的分界在于方向的不同。 29、人的友爱和同情往往只是作为情绪来到，而相反的事实则是伸手便可触及。 30、活着就是为了活着本身，而不是活着之外的的任何事物。 1、你千万别糊涂，死人都还想活过来，你一个大活人可不能去死。 2、人是为了活着本身而活着，而不是为了活着之外的任何事物而活着。 3、这钢铁能造三颗炮弹，全部打到台湾去，一颗打在蒋介石床上，一颗打在蒋介石吃饭的桌上，一颗打在蒋介石家的羊棚里。 4、抬担架的都猫着腰，跑到我们近前找一块空地，喊一、二、三，喊到三时将担架一翻，倒垃圾似的将伤号扔到地上就不管了。 5、他们对自己的经历缺乏热情，仿佛是道听途说般地只记得零星几点，即便是这零星几点也都是自身之外的记忆，用一、两句话表达了他们所认为的一切。 6、我知道他不会和我拼命了，可他说的话就像是一把钝刀子在割我的脖子，脑袋掉不下来，倒是疼得死去活来。 7、女人啊，性子上来了什么事都干，什么话都说。 8、老子就是啃你家祖坟里的烂骨头，也不会向你要饭。 9、可是我再也没遇到一个像福贵这样令我难忘的人了，对自己的经历如此清楚，又能如此精彩地讲述自己是如何衰老的。这样的老人在乡间实在是难以遇上，也许是困苦的生活损坏了他们的记忆，面对往事他们通常显得木讷，常常以不知所措的微笑搪塞过去。 10、一个人命再大，要是自己想死，那就怎么也活不了。 11、从前，我们徐家的老祖宗不过是养了一只鸡，鸡养大后变成了鹅，鹅养大了变成了羊，再把羊养大，羊就变成了牛。我们徐家就是这样发起来的。 12、家珍是你的女人，不是别人的，谁也抢不走。 13、只要一家人天天在一起，也就不在乎什么福分了。 14、喂，你知道老良在哪里？死啦妈的，他还欠我一个银元呢 15、老子就是啃你家祖坟里的烂骨头，也不会向你要饭。 16、俗话说是笨鸟先飞，我还得笨鸟多飞。 17、可是我再也没遇到一个像福贵这样令我难忘的人了，对自己的经历如此清楚，又能如此精彩地讲述自己。他是那种能够看到自己过去模样的人，他可以准确地看到自己年轻时走路的姿态，甚至可以看到自己是如何衰老的。这样的老人在乡间实在难以遇上，也许是困苦的生活损坏了他们的记忆，面对往事他们通常显得木讷，常常以不知所措的微笑搪塞过去。他们对自己的经历缺乏热情，仿佛是道听途说般地只记得零星几点，即便是这零星几点也都是自身之外的记忆，用一、两句话表达了他们所认为的一切。 18、我知道他不会和我拼命了，可他说的话就像是一把钝刀子在割我的脖子，脑袋掉不下来，倒是疼得死去活来。 19、你的命是爹娘给的，你不要命了也得先去问问他们。 20、人啊，活着时受了再多的苦，到了快死的时候也会想个法子来宽慰自己。 21、福贵就完全不一样了，他喜欢回想过去，喜欢讲述自己，似乎这样一来，他就可以一次一次地重度此生了。 22、做人还是平常点好，争这个争那个，争来争去赔了自己的命。像我这样，说起来是越混越没出息，可寿命长，我认识的人一个挨着一个死去，我还活着。 23、女人都是一个心眼，她认准的事谁也不能让她变。 24、那时候最多的就是子弹了，往哪里躺都硌得身体疼。 25、人只要活得高兴，穷也不怕。 26、那件绸衣我往身上一穿就赶紧脱了下来，那个难受啊，滑溜溜的像是穿上了鼻涕做的衣服。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"随笔","slug":"随笔","permalink":"https://liangyuanzheng.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://liangyuanzheng.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"缓存淘汰策略","slug":"缓存淘汰策略","date":"2023-02-18T09:10:57.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"缓存淘汰策略.html","link":"","permalink":"https://liangyuanzheng.com/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html","excerpt":"","text":"LRU 与 LFU 缓存策略及其实现。 应用层缓存 鉴于磁盘和内存读写的差异性，DB 中低频写、高频读的数据适合放入内存中，直接供应用层读写。在项目中读取用户资料时就使用到了 LRU，而非放到 Redis 中。 缓存的 2 个基本实现12Set(key string, value interface) // 写数据Get(key string) interface&#123;&#125; // 读数据 缓存的 2 个特征 命中率：即命中数 &#x2F; 请求数，比值越高即表明缓存使用率越高，缓存更有效。 淘汰策略：内存空间是有限的，当缓存数据占满内存后，若要缓存新数据，则必须淘汰一部分旧数据。对于旧 的概念，不同淘汰策略有不同原则。 下边介绍两种常用的淘汰算法：LRU 与 LFU LRU缩写：Least Recently Used（ 最近 最久 使用），时间维度 原则：若数据在最近一段时间内都未使用（读取或更新），则以后使用几率也很低，应被淘汰。 数据结构 使用链表：由于缓存读写删都是高频操作，考虑使用写删都为 O(1) 的链表，而非写删都为 O(N) 的数组。 使用双链表：选用删除操作为 O(1) 的双链表而非删除为 O(N) 的单链表。 维护额外哈希表：链表查找必须遍历 O(N) 读取，可在缓存中维护 map[key]*Node 的哈希表来实现 O(1) 的链表查找。 直接使用链表节点存储缓存的 K-V 数据，链表从 head 到 tail 使用频率逐步降低。新访问数据不断追加到 head 前边，旧数据不断从 tail 剔除。LRU 使用链表顺序性保证了热数据在 head，冷数据在 tail。 双链表节点存储 K-V 数据： 12345678910type Node struct &#123;truekey string // 淘汰 tail 时需在维护的哈希表中删除，不是冗余存储trueval interface&#123;&#125;trueprev, next *Node // 双向指针&#125;type List struct &#123;truehead, tail *Nodetruesize int // 缓存空间大小&#125; 从上图可知，双链表需实现缓存节点新增 Prepend，剔除 Remove 操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func (l *List) Prepend(node *Node) *Node &#123;trueif l.head == nil &#123;truetruel.head = nodetruetruel.tail = nodetrue&#125; else &#123;truetruenode.prev = niltruetruenode.next = l.headtruetruel.head.prev = nodetruetruel.head = nodetrue&#125;truel.size++truereturn node&#125;func (l *List) Remove(node *Node) *Node &#123;trueif node == nil &#123;truetruereturn niltrue&#125;trueprev, next := node.prev, node.nexttrueif prev == nil &#123;truetruel.head = next // 删除头结点true&#125; else &#123;truetrueprev.next = nexttrue&#125;trueif next == nil &#123;truetruel.tail = prev // 删除尾结点true&#125; else &#123;truetruenext.prev = prevtrue&#125;truel.size--truenode.prev, node.next = nil, niltruereturn node&#125;// 封装数据已存在缓存的后续操作func (l *List) MoveToHead(node *Node) *Node &#123;trueif node == nil &#123;truetruereturn niltrue&#125;truen := l.Remove(node)truereturn l.Prepend(n)&#125;func (l *List) Tail() *Node &#123;truereturn l.tail&#125;func (l *List) Size() int &#123;truereturn l.size&#125; LRU 操作细节Set(k, v) 数据已缓存，则更新值，挪到 head 前 数据未缓存 缓存空间未满：直接挪到 head 前 缓存空间已满：移除 tail 并将新数据挪到 head 前 Get(k) 命中：节点挪到 head 前，并返回 value 未命中：返回 -1 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940type LRUCache struct &#123;truecapacity int // 缓存空间大小trueitems map[string]*Nodetruelist *List&#125;func NewLRUCache(capacity int) *LRUCache &#123;truereturn &amp;LRUCache&#123;truetruecapacity: capacity,truetrueitems: make(map[string]*Node),truetruelist: new(List),true&#125;&#125;func (c *LRUCache) Set(k string, v interface&#123;&#125;) &#123;true// 命中trueif node, ok := c.items[k]; ok &#123;truetruenode.val = v // 命中后更新值truetruec.items[k] = c.list.MoveToHead(node) //truetruereturntrue&#125;true// 未命中truenode := &amp;Node&#123;key: k, val: v&#125; // 完整的 nodetrueif c.capacity == c.list.size &#123;truetruetail := c.list.Tail()truetruedelete(c.items, tail.key) // k-v 数据存储与 node 中truetruec.list.Remove(tail)true&#125;truec.items[k] = c.list.Prepend(node) // 更新地址&#125;func (c *LRUCache) Get(k string) interface&#123;&#125; &#123;truenode, ok := c.items[k]trueif ok &#123;truetruec.items[k] = c.list.MoveToHead(node)truetruereturn node.valtrue&#125;truereturn -1&#125; 测试12345678910111213func TestLRU(t *testing.T) &#123;truec := NewLRUCache(2)truec.Set(K1, 1)truec.Set(K2, 2)truec.Set(K1, 100)truefmt.Println(c.Get(K1)) // 100truec.Set(K3, 3)truefmt.Println(c.Get(K2)) // -1truec.Set(K4, 4)truefmt.Println(c.Get(K1)) // -1truefmt.Println(c.Get(K3)) // 3truefmt.Println(c.Get(K4)) // 4&#125; LFU缩写：Least Frequently Used（最近 最少 使用），频率维度。 原则：若数据在最近一段时间内使用次数少，则以后使用几率也很低，应被淘汰。 对比 LRU，若缓存空间为 3 个数据量： 1234567Set(\"2\", 2)Set(\"1\", 1)Get(1)Get(2)Set(\"3\", 3)Set(\"4\", 4) // LRU 将淘汰 1，缓存链表为 4-&gt;3-&gt;2true // LFU 将淘汰 3，未超出容量的时段内 1 和 2 都被使用了两次，3 仅使用一次 数据结构依旧使用双向链表实现高效写删操作，但 LFU 淘汰原则是 使用次数，数据节点在链表中的位置与之无关。可按使用次数划分 频率梯队，数据节点使用一次就挪到高频梯队。此外维护 minFreq 表示最低梯队，维护 2 个哈希表： map[freq]*List 各频率及其链表 map[key]*Node 实现数据节点的 O(1) 读 双链表存储缓存数据： 1234567891011type Node struct &#123;truekey stringtrueval interface&#123;&#125;truefreq int // 将节点从旧梯队移除时使用，非冗余存储trueprev, next *Node&#125;type List struct &#123;truehead, tail *Nodetruesize int&#125; LFU 操作细节Set(k, v) 数据已缓存，则更新值，挪到下一梯队 数据未缓存 缓存空间未满：直接挪到第 1 梯队 缓存空间已满：移除 minFreq 梯队的 tail 节点，并将新数据挪到第 1 梯队 Get(k) 命中：节点挪到下一梯队，并返回 value 未命中：返回 -1 如上的 5 种 case，都要维护好对 minFreq 和 2 个哈希表的读写。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566type LFUCache struct &#123;truecapacity inttrueminFreq int // 最低频率trueitems map[string]*Nodetruefreqs map[int]*List // 不同频率梯队&#125;func NewLFUCache(capacity int) *LFUCache &#123;truereturn &amp;LFUCache&#123;truetruecapacity: capacity,truetrueminFreq: 0,truetrueitems: make(map[string]*Node),truetruefreqs: make(map[int]*List),true&#125;&#125;func (c *LFUCache) Get(k string) interface&#123;&#125; &#123;truenode, ok := c.items[k]trueif !ok &#123;truetruereturn -1true&#125;true// 移到 +1 梯队中truec.freqs[node.freq].Remove(node)truenode.freq++trueif _, ok := c.freqs[node.freq]; !ok &#123;truetruec.freqs[node.freq] = NewList()true&#125;truenewNode := c.freqs[node.freq].Prepend(node)truec.items[k] = newNode // 新地址更新到 maptrueif c.freqs[c.minFreq].Size() == 0 &#123;truetruec.minFreq++ // Get 的正好是当前值true&#125;truereturn newNode.val&#125;func (c *LFUCache) Set(k string, v interface&#123;&#125;) &#123;trueif c.capacity &lt;= 0 &#123;truetruereturntrue&#125;true// 命中，需要更新频率trueif val := c.Get(k); val != -1 &#123;truetruec.items[k].val = v // 直接更新值即可truetruereturntrue&#125;truenode := &amp;Node&#123;key: k, val: v, freq: 1&#125;true// 未命中true// 缓存已满trueif c.capacity == len(c.items) &#123;truetrueold := c.freqs[c.minFreq].Tail() // 最低最旧truetruec.freqs[c.minFreq].Remove(old)truetruedelete(c.items, old.key)true&#125;true// 缓存未满，放入第 1 梯队truec.items[k] = nodetrueif _, ok := c.freqs[1]; !ok &#123;truetruec.freqs[1] = NewList()true&#125;truec.freqs[1].Prepend(node)truec.minFreq = 1&#125; minFreq 和 2 个哈希表的维护使 LFU 比 LRU 更难实现。 测试123456789101112func TestLFU(t *testing.T) &#123;truec := NewLFUCache(2)truec.Set(K1, 1) // 1:K1truec.Set(K2, 2) // 1:K2-&gt;K1truefmt.Println(c.Get(K1)) // 1:K2 2:K1 // 1truec.Set(K3, 3) // 1:K3 2:K1truefmt.Println(c.Get(K2)) // -1truefmt.Println(c.Get(K3)) // 2:k3-&gt;k1 // 3truec.Set(K4, 4) // 1:K4 2:K3truefmt.Println(c.Get(K1)) // -1truefmt.Println(c.Get(K3)) // 1:K4 3:K3 // 3&#125; 总结常见的缓存淘汰策略有队列直接实现的 FIFO，双链表实现的 LFU 与 LRU，此外还有扩展的 2LRU 与 ARC 等算法，它们的实现不依赖于任意一种数据结构，此外对于旧数据的衡量原则不同，淘汰策略也不一样。 在算法直接实现难度较大的情况下，不妨采用空间换时间，或时间换空间的策略来间接实现。要充分利用各种数据结构的优点并互补，比如链表加哈希表就实现了任意操作 O(1) 复杂度的复合数据结构。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"缓存","slug":"缓存","permalink":"https://liangyuanzheng.com/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"无头浏览器","slug":"无头浏览器","date":"2023-02-15T01:59:46.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"无头浏览器.html","link":"","permalink":"https://liangyuanzheng.com/%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8.html","excerpt":"","text":"无头浏览器Selenium的使用要点1、无头浏览器(headless browser)是什么无头浏览器是指可以在图形界面情况下运行的，可以模拟多种浏览器的运行框架。研发可以通过编程来控制该框架执行各种任务，模拟真实的浏览器操作和各种任务，例如登录、js解析、ajax动态生成、获取cookie等。 2、无头浏览器适合的场景无头浏览器的框架需要真实运行浏览器，因此系统开销大，采集运行速度慢，相对与一般的爬虫程序，其运行环境要求搭建的工具和库较多，因此如果目标网站反爬不是很难，可以直接通过简单的http请求进行采集，不适合使用无头浏览器方案。 当目标网站有多种验证机制，例如需要验证登录、ajax动生成、js反爬策略，如果研发不能进行网站行为分析的情况下，建议使用无头浏览器伪装正常用户，同时配合使用爬虫代理加强版进行数据采集。 3、无头浏览器框架推荐无头浏览器有很多，我们推荐如下： selenium+chrome+chrome driver+爬虫代理加强版 为什么叫“无头”浏览器？“无头”这个词来源于最初的“无头计算机(Headless computer)”。维基百科关于的“无头计算机”词条： 无头系统（headless system）是指已配置为无须显示器（即“头”）、键盘和鼠标操作的计算机系统或设备。无头系统通常通过网络连接控制，但也有部分无头系统的设备需要通过RS-232串行连接进行设备的管理。服务器通常采用无头模式以降低运作成本。 无头浏览器 Puppeteer 初探我们日常使用浏览器的步骤为：启动浏览器、打开一个网页、进行交互。而无头浏览器指的是我们使用脚本来执行以上过程的浏览器，能模拟真实的浏览器使用场景。 有了无头浏览器，我们就能做包括但不限于以下事情： 对网页进行截图保存为图片或 pdf 抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题) 做表单的自动提交、UI的自动化测试、模拟键盘输入等 用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题 在最新的无头浏览器环境里做测试、使用最新浏览器特性 写爬虫做你想做的事情~ 无头浏览器很多，包括但不限于: PhantomJS, 基于 Webkit SlimerJS, 基于 Gecko HtmlUnit, 基于 Rhnio TrifleJS, 基于 Trident Splash, 基于 Webkit 本文主要介绍 Google 提供的无头浏览器(headless Chrome), 他基于 Chrome DevTools protocol 提供了不少高度封装的接口方便我们控制浏览器。 参考文献 什么是「无头浏览器」 （Headless browser），它有什么应用场景？ 无头浏览器 Puppeteer 初探 无头浏览器Selenium的使用要点","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"了凡四训","slug":"了凡四训","date":"2023-02-15T01:55:14.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"了凡四训.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BA%86%E5%87%A1%E5%9B%9B%E8%AE%AD.html","excerpt":"","text":"《了凡四训》是古代著名劝善书，作者是明朝著名官员、思想家袁黄。全文通过立命之学、改过之法、积善之方、谦德之效分四个部分来讲解如何改变命运。作者以亲身经历，讲述了改变命运的过程。原本为教训自己的儿子，故取名《训子文》；其后为启迪世人，遂改今名。 第一篇：立命之学（说明人的命运是可靠自己创造，而不是被命数所束缚。） 第二篇：改过之法（从小的过失起改过，那自然便不会犯下大的过错。） 第三篇：积善之方（多做善事帮助别人，善事积多了，命运自然也有所改变。） 第四篇：谦德之效（与人相处，待人要谦虚，从中学习，自然便有进步。） 转自《了凡四训》","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"如何提高写作能力","slug":"如何提高写作能力","date":"2023-02-09T01:40:46.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"如何提高写作能力.html","link":"","permalink":"https://liangyuanzheng.com/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%86%99%E4%BD%9C%E8%83%BD%E5%8A%9B.html","excerpt":"","text":"1.多读书：阅读其他计算机专业技术文章，以获得灵感，培养写作技巧和思维方式； 2.参加社区讨论：参加一些技术社区，可以和其他技术爱好者进行交流，从中可以获得更多的信息，增强自己对相关专业技术的理解； 3.多总结：在学习新知识时，多总结，把学习到的知识总结成文章，以便从中更好地理解和掌握； 4.多实践：多实践，把学到的知识运用到实际的项目中，可以加深理解和记忆，也可以为写文章提供素材； 5.多写：多写文章，有意识地练习写作，把所学到的知识运用到实际的文章中，可以提高自己的写作能力。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"知其要者，一言而终","slug":"知其要者，一言而终","date":"2023-01-29T06:25:34.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"知其要者，一言而终.html","link":"","permalink":"https://liangyuanzheng.com/%E7%9F%A5%E5%85%B6%E8%A6%81%E8%80%85%EF%BC%8C%E4%B8%80%E8%A8%80%E8%80%8C%E7%BB%88.html","excerpt":"","text":"知其要者，一言而终，不知其要者，流散无穷。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"阅读与写作讲义","slug":"阅读与写作讲义","date":"2023-01-07T03:55:30.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"阅读与写作讲义.html","link":"","permalink":"https://liangyuanzheng.com/%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E8%AE%B2%E4%B9%89.html","excerpt":"","text":"阅读的意义，写作的技巧，有道亦有术。有理有据，很有启发。 总序为什么简单的努力破不了局？这种思维方式，依然是简单的工匠式的。技能教育，接受的再多，也不过是从一种工匠变成几种工匠。 要达到精英的水准，就需要提高综合素质。更有效的提高综合素质的方法，是接受通识教育。 在古希腊，是否接受过通识教育，是区别自由民和奴隶的依据。 人要想成为社会精英，首先要在精神上成为精英，这样才能以精英的方式思考，以主人的态度做事，才能超出常人。 通识教育的本质，即能够将这些知识用于许多地方，而不仅仅是直接用来做具体的事情。为此，通过通识教育，理解知识的结构化和关联性很重要。 通过学习这些知识，你的思维方法和做事水平会得到明显的提升。 这套基础通识讲义会包括十类核心学科，分别是： 数学 逻辑学 语文、文学和写作 文明史 自然科学 经济、金融、管理和投资 信息科学 人文地理 音乐和艺术 政治学、哲学和军事 前言为什么要学大语文以“理解他人、表达自己”为核心的大语文内容——它比任何一门专业课更能让我们受益终身。 语文的重要性不仅体现在它对人学业和工作的影响上，更体现在对人生活所产生的决定性作用上。 语文包括两个方面的内容： 第一个方面是感受（receptive），包括听、读、观察和理解。 第二个方面是表达（expressive），包括说、写、唱、表述和表演。 从语文的这两个方面来看，都有艺术的待性。既然是艺术，通常会有一个特点：有规律可循，却没有定势。 什么阶层的人用什么样的词汇。 为什么要学习语文。答案就是，如果你想过入一定的阶层，最好就要掌握那个阶层的用语，而这个教育，需要由语文来完成。 人文和艺术素养可以带来科学上原创性的创造力。 本书采用西方大语文的教学方式，强调语文和生活的关系，语文和其他知识体系的关联。 序章我们都生活在语文中大语文内涵丰富，它不仅包含基本的词汇，还包括高级的语法、修辞等语言技巧以及表达能力。 首先是词汇，它是语文最基本的元素。 在词汇之上，是语法，修辞等高级的语言技巧。 在语法、修辞之上，是书面和口头的表达能力。 策论。 如何更好地理解他人、表达自己把握住三个维度的线索，就能学好大语文。 这三个维度分别是读和写、听和说、观察和视觉表达。它们的核心功能，都是让我们更好地理解他人、表达自己。 阅读时，我们既要理解作者的思想，也要学习作者表达自我的方法；写作时，我们既要所自我表达充分，也要考虑如何便于读者理解。 ”说“是有一套系统性的表达自我的方法。 好的听众不仅会听内容，还会学习演讲者的讲话技巧；反之，好的演讲者也会顾及听众的接收能力。 美国学生的三种能力第一种是口头表达能力。 第二种是阅读严肃读物、深刻理解作者思想的能力。 第三种是在生活中运用语文的能力。 上篇 如何阅读与写作 第 1章 阅读的意义：理解他人1.1 信息：什么是合格的阅读理解读懂作者的意思，是阅读；完成形象的重构，是理解。 要做好阅读理解，先要训练自己有意识地进行阅读。 作者如果想有效地传达出自己的想法，需要提供哪些内容要素呢？ 在中文里，可以归纳为六大要素，即时间、地点、人物、发生、发展、结果。 在英文中，可以概括为：when（时间）、where（地点）、who（人物）、what（什么事情，即”发生“）、how（怎么回事、即”发展“）、why（为什么，回答疑问，给出结论）。此外，很多文章还有比较观点，需要再加上一个which（哪一个）。即七个”wh“。 阅读理解其实是一种信息的转换。 1.2 深层：理解作品和文章深意的五个要素一部好的作品，尤其是文学作品，通常在以下五个方面表现出色： 结构 描写手法 比喻（包括明喻、暗喻和借喻等） 用词用语 语气 不仅在阅读时要把握文章的结构，在写作时，也应该先考虑结构，再写细节内容，面不是想到哪里就写到哪里。一介好的解决办法是：先搭好文章的架子，也就是先确定结构，再填入内容。 1.3 思想：如何读懂作者的内心合格的读者，除了要懂字面上的基本信息，还要能读出隐含信息。但做到这些仅仅是合格而已，高明的读者还要能理解作者的本意，或者说作者的内心。 专业作者写作的目的一是要表达自己的内心世界，二是要描绘他们的时代和周围的事件。只有了解到他们的意图和思想，才算读懂了。 凡人要在伟大的事业中寻求不朽。 人类历史上那些伟大的时刻，在出现之前都经历了长时间的酝酿和势能和积累。 尽早从年轻气盛的机会主义者，慢慢变成一个踏踏实实做准备的人。 从读者的角度来讲，能够通过书中的内容反推出作者是什么样的人，才算读懂了一本书。 阅读理解到了深层次，其实就是从读书上升到了读人。 学会通过阅读作品了解作者的内心，也就掌握了清楚表达自己内心的技巧，写出来的内容也会很容易赢得读者的共鸣。 1.4 时代：如何从文艺作品了解一段历史古典主义文学的特点学是强调理性和秩序。 阅读的三个层次： 第一个层次是读出作品本身的含义，第二个层次是读出作者的本意，第三个层次是读出作者所在的那个时代。 1.5 品位：如何全面高效地构建知识体系进行大量阅读的一个重要目的，是构建自己的知识体系。 进入一个陌生领域，最好的办法就是阅读了。 构建知识体系的三步阅读法： 第一步是从阅读”正统“文献或作品开始。 所谓“正统”，是指在某个领域或者行业被主流认可的。正统提供了一个基准线。之后的阅读，都是在基准线上做修改。”基准线思维“是一个很有用的方法论。 建立知识体系这件事的成本其实不在于花了多少钱，而在于时间成本和收益比。无论是对已知还是未知的领域，从正统的观点出发，都是建立知识体系最高效的做法。 第二步是阅读权威的综述文章。 这一步就是对基准线进行修正的办法。 综述文章，基本上会把一个领域最近十年的成就都概括介绍了。想了解各个领域最新的研究进展，最简单的办法就是看综述类文章。 “权威”、“正统”。要有效地建立起知识体系，这是捷径。走正统道路的好处在于，便于和专业人士交流。这一点很重要。 当你读了正统的文献或作品，也看了很多权威的综述文章，就该迈出构建知识体系的第三步了，也就是读一起有趣的专著。 我们需要对正统的知识有所了解，以防把标新立异当作主流观念。 1.6 考试：如何回答好阅读理解题阅读理解通常可以从两个维度分类：宏观的和细节的，主观的和客观的。 1.7 速度：如何突破阅读的瓶颈第一个瓶颈是人脑接收信息的带宽。 第二个瓶颈是眼睛和大脑一同识别文字图像的速度。 提高阅读速度的办法： 第一，调整书本的位置。 第二，学会用语音辅助阅读。 第三，遇到不认识的字，不要停，跳过去。 1.8 层次：如何兼顾阅读的广度与深度阅读要分层，要兼顾广度和深度，这样才能更有效也通过阅读获取知识。 书大致可以分为三类： 第一类是供浏览的书，也就是你可以快速翻翻，在致了解一下内容的书。 浏览大量书籍，增加阅读量。 第二类书需要细读或者精读的书，我会逐句读完。 第三类是需要典藏的书。 阅读为什么要分层呢？ 因为分层阅读是我能找到的唯一可以兼顾知识面、知识完整性和深度的办法。 深度阅读的一个目的，是在把一本书读透之后，用它的内容构建自己的知识体系和认知框架。 深度阅读的另一个目的是去伪存真。深度阅读要做到两件事：第一，审查每个观点是否有依据，信息来源是否可信；第二，对一些志业的材料，需要做专业的理解，甚至需要专业人士帮助解读，以免自己理解错误。 1.9 欣赏：如何体会经典文学的魅力深度阅读文学作品，不仅能够体会语言的魅力，还能理解作者真正的思想。 本章小结阅读是我们建立知识体系的主要手段。阅读的品位决定了我们的水准。通常，最有效的方法是从正统的书籍入手，建立自己知识体系基准线，然后用更新、更高质量的内容作补充。 第 2 章 写作的核心：表达自己2.1 书面表达：写跟说有什么不同第一，用词语不同。 想要进行书面写作，积攒足够大的词汇量是非常重要的。 第二，表达的结构不同。 口头表达，常常是时间上从前往后，在逻辑上先因后果。 书面表达的结构则有很多种： 首先，可以从前往后、先因后果地写作，即顺叙。 其次，可以先讲结论，再讲做法，即倒叙。 最后，还可以先讲自己要说的道理。 第三，信息方向不同。 第四，逻辑复杂度不同。 口头表达的逻辑比较简单，最常用的是三段论，从大前提、小前提推出结论。 书面表达在论述时常采用的两个方式是层层递进和剧情大反转。 2.2 起步：如何从害怕写到天天想写一个熟练的书面写作者，需要经过从害怕写到天天想写，再从天天想写到不轻易落笔的两个过程。 如何从害怕写到天天想写： 第一步，随便找一个新鲜有趣的题材，开始写。 任何是个让你感觉“原来如此”或者“原来不过如此”的见闻，都是很好的写作题材。 第二步，突出主题。 写东西最重要的，就是要突出主题。 能记录新鲜有趣的东西，并且突出主题。 第三步，形成具有动感的故事。 一篇合格的作文要有轮廓、细节和故事情节展开的线索。 总结来说，首先，你要有一个整体的看法、态度，这是轮廓；然后，要有支持它的证据，这是细节；最后，这些细节不能以清单的方式罗列出来，而要根据一条条线索展开。 第四步，让读者产生共鸣。 想要达到写作目的，挑选素材很重要。 为了让读者产生共鸣，写作的时候还要看读者是谁，要以读者的认知体系为前提，做到有的放矢。 第五步，形成自己的风格。 这是对专业写作者的要求。 需要注意的是，不要简单地模仿某个人的风格，那样很轻易就能让人看出来是廉价的复制。不过，要形成自己的风格，需要了解很多人的风格。 上述五个步骤，可以说是写作训练的总纲。从找到新鲜有趣的题材写起来、突出主题，到形成具有动感的故事、让读者产生共鸣，最后到形成自己的风格，这是一个持续进阶的过程。 2.3 修辞：如何让外行理解陌生的东西比喻的第一层：用熟悉的事物形容不熟悉的事物，即“由简喻难” 比喻的第二层：是用来打比方的事物，相似点要直观。 比喻的第三层：要通过比喻产生美感，这样写出来的东西才能打动人心。 比喻的第四层：要上升到思想层面，就是要创造一些新概念，浓缩人类在某个方面的认知。 比喻远不只是为了让表达生动形象、亲切自然，它还是传递思想、方便读者理解的一个重要工具。 比喻是为了便于读者理解概念，但这只是达到了传递思想最基本的要求。为了让大家有更深刻的印象，通常还需要用对比和夸张的修辞手法。 多找经典的例子来学习。 2.4 写景：如何寓情于景寓情于景是描写人心理活动的一个好工具。 如何掌握好寓情于景这种写法： 第一层是采用一些千百年来人们已经习惯了思维定式。 如季节、颜色、山川河海。 第二层是通过不同人看同一景物时不同的态度，折射出他们的心情和性格。 第三层是在情和景之间建立一个桥梁。 2.5 写情：如何写好心理活动寓情于景是一种含蓄曲折地表达心情的方式，而更直接的表达方式，就是进行心理描写。 不管什么时候，表达自己的感受都是有讲究的。要向那些文学大师学习。 在文学作品中，心理活动描写大致可分为直接描写和间接描写。直接描写是最常用的手法。 间接描写有两种最常见的方式，一种是通过描写行为来表现内心。另一种是借别人的嘴说出来，或者由别人的话产生感触和联想。 2.6 叙事：如何牵着读者走顺叙的办法讲故事，有三个坑要注意： 第一，要避免写成流水帐。 第二，要避免跑题。 第三，要避免结构散掉。 相比顺序，倒叙是一种难度更高的写法。 顺序写法让读者的注意力集中在“是什么“上。倒叙让读者把注意力放在”为什么“上。 叠叙，逻辑上前后穿插交叠。 如在做汇报时，如果要汇报一些遇到的麻烦和困难，我也会采用这种方式。先把坏消息告诉大家，然后讲原因。但是故事到这里并没有结束，最后我会给出解决办法，也就是用所谓的好消息把故事推向高潮。 2.7 技巧：如何让文章更有魅力第一，设置悬念。 提出悬念，又解开谜团。 比较常见的悬念是期望式悬念，它建立在对读者不保密的基础上。 在论文写作中，经常要做比较，就是安排对立面，勾起读者的兴趣，让他们想知道到底哪种方法、方案、观点更好。 比期望式悬念更吸引人的是突发式悬念，它是依靠对读者保密，通过使人大吃一惊的情节，让人发出”原来如此“的感叹，以此达到效果。 第二，有张有弛。 高明的写作也要懂得把握节奏，有张有弛。 第三，管中窥豹。 指的是通过一个细节把全景讲清楚。 第四，点睛之笔。 一是善于总结作品的内容，最好能用一句带有”标语性质“的话把自己要说的内容总结出来。 二是要考虑读者的心理和知识背景，考虑说什么话能让他们有所触动，最好是替他们找到一句话，把他们思考了很久但是想不透彻的疑问一下点清楚。 第五，反讽手法。 2.8 实践：我是怎么写出畅销书的写文章是两个人的事情，不仅要表达好自己，还要理解读者的心理。 注重结构和逻辑，而不是文采。 记录一两个主题——对于日记来讲，写什么比怎样写更重要。 任何时候，内容都比形式重要。 一篇文章的口气和用词要保持一致，这样写出来的东西才会显得更专业。 化繁为简，参照《人类群星闪耀时》和《人类的故事》将几千年的文明史切成三十二个片段，通过这三十二个片段折射出历史的全貌。这个办法也就是前面讲到的管中窥豹。 第 3 章 日常实用写作3.1 日记：如何用日记提升写作能力写好日记的第一要素，是在每天动笔之前搞清楚写什么和不写什么，这比怎么写更重要。 值得写的三类内容。 第一类是工作日记。 工作日记更大的作用是帮助自己总结得失。 写好工作日记，既是为了让自己同样的错误不犯两遍，更是为了不断积累成功的经验 。 第二类是读书的心得和收获。 通过阅读获得三个层面的收获：对全书轮廓的了解，对书中一些细节或者知识点的了解，以及对作者写作技巧和手法的了解。 把自己的思考和想法写下来的另一个目的，是防止记信一堆似是而非的信息。 第三类是自己的特殊的经历，特别是失败的经历的感受，以防自己好了伤疤忘了痛。 日记该怎么写，主要有三个要点： 第一，要过滤出哪些内容值得写。 每天的题材可以变，但是只写一件事这个原则不能变。（更专心地写好事情） 第二，要带着目的写，每周做总结。 将一部分总结直接按照论文或者书中段落的形式写出来，而不仅仅是用只有自己一个人看得懂的形式写。 每周做总结，很容易发现就能发现自己在时间管理上的漏洞。 第三，日记要真实。 日记，无论是工作日记、读书心得还是对特殊经历的记录，都可以从三个方面提升我们的语文水平。 首先，观察能力。 其次，分析能力。 最后，表达能力。 3.2 邮件：如何写好工作邮件想要写好一封工作邮件，最重要的不是怎么写，而是弄清楚什么该写，什么不该写。“三写四不写”： 第一，不想留底的内容不要写。 第二，没有经过深思熟虑的内容不要写。 第三，负面的内容，特别是气话，不要写。 第四，一次讲不清，需要反复讨论才能搞清楚的事情不要写。 下面三条，是工作中尤其该写的。 第一，需要留底的话一定要写。 第二，必须写而大家又懒得写的备忘录一定要写。 不妨主动承担这项任务。这样做有两个好处：第一，是让部门里的人，特别是上级关注到自己，因为他们其实需要这样一份留底的书面材料；第二，能站在整个部门的角度想问题。 第三，重要的通知和安排一定要写。 写邮件时，表达自己、影响别人的四点技巧： 第一，简要清晰地说明发邮件的目的。 第二，一封邮件最好只讲一件事，几件事要用几封不同的邮件讲。 这个原则对写邮件来讲至关重要，但很多人意识不到，这是由今天的工作方式决定的。 第三，写邮件也要像讲故事那样吸引人。 比较有效的技巧是层层递进，甚至可以用一些标记来强调邮件内容的层次，比如圆点、星号等。故事讲完，一定要有结论，邮件不需要给人回味无穷的感觉。 第四，主观感受的表达要视收件人而定。 如果收件人是一个人，或者是一群利益一致的人，你可以加入自己的主观感受。 如你在协调两个部门的关系，就应该避免加入主观感受。 总的来讲，一对一邮件可以增加主观感受，使工作关系不那么冷冰冰；一对多的邮件就要少引入主观看法，以做到客观公正。 想写好工作邮件，要把重要的事放在前面，尽量一封邮件只讲一件事情，要写得吸引人，还要注意根椐收件人的不同来决定是否加入主观感受的表达。 3.3 简历：如何写好简历一个人无论是求职还是晋升，成功率和简历的质量都是强相关的。 写简历的四个忌讳。 第一，切忌把小成绩当大成就夸。 第二，切忌把别人的功劳当自己的夸。 第三，切忌平均用力，没有亮点。 不要把金子埋到沙堆里让人去找，面是要把沙子先掉，让金子更耀眼。 第四，切忌用PPT写简历。 简历应该怎么写？六个要点。 第一，搞清楚写简历的目的。 第二，要分清楚资历和能力的差异。 一份好的简历，要通过自己做过的事情体现自己的能力，特别是显示出自己比同龄人、同职位人能力更强。 第三，强调效果胜过强调水平。 对一个公司来讲，需 要的是大量能带来效果的员工，而不是头顶光环的员工。 第四，保持一致性和向上的趋势。 简历中要呈现出一种表现稳定，而且逐渐向上的趋势。 如果是针对这次的提拔和晋升，上次晋升前的功绩就清零了，因为那些功绩在上次的晋升时已经被用过一遍了，这美人鱼只会看从上次晋升到目前这一段时间里的成绩。 人不能把人生第一份功劳用一辈子。因此，在简历中需要讲这样一个故事：我在求学和职业中一直在进步，成绩越做越好。如果把一个人的表现按照时间顺序画出来，最好的情况是呈上升趋势。 第五，注意用词。 关一用词的一个细节，就是在简历中要多用名词，少用形容词。 第六，切忌篇幅冗长。 职业目标和与具体职位有关的技能、成绩是不能漏掉的。 3.4 评论：如何写好评论第一类评论：写推荐序和对某个人的全面评价。 第二类评论：一般性的评论和对某个人具体的评论。 从四个方面来谈谈第二类评论的写法。 第一，要有自己独特的视角。 第二，要看到被评论对象独特的地方，特别是其他观察者看不到的地方。 第三，非凡的结论要有非凡的证据。 前两个原则都是在强调评论的独特性，一个是从写作者的角度讲，另一个是从被评论对象的角度讲。但是，这两个原则切忌使用过度、直极端面 ，否则就变成哗众取宠、以偏概全了。 第四，要谨记三七分配原则。 用30%的篇幅描述轮廓，然后用70%的篇幅写一个侧面。 任何时候都不要轻易写负面评价。 如果不得不写，又不愿意写很正面的评论，通常有两个办法。一个办法是，写得不温不火，这样其他人读起来就能感觉到你的态度。另一个办法是，用反转手法，先从正面肯定，最后写一点和大家不同的看法或者负面的评论。 概括来讲，写评论一定要写出自己独特的角度，找到其他人没有观察到的事实，非常的结论要有非常的证据支持。在有限的篇幅内，要平衡轮廓和细节的占比，给细节70%的篇幅会让你的评论更精彩。最后，发表负面评论，一定要慎之又慎。 3.5 论文：如何写好论文论文类写作是对自己做的创新类工作的汇报；报告类写作是对客观上已经存在的，通常是别人做的工作的分析和总结。 写论文的的技巧。 第一，要重视研究综述。 写综述的目的不仅是引出问题，也是表达对前人和同行成就的认可。 第二，要重视呈现研究方法。 第三，要重视比较工作。 第四，要为 N + 2 指明方向。 写论文中有三件事一定不能做。 第一，过分拔高自己。 第三，故做惊人之语。 第三，一些次要的、相关性不强的工作，根本不需要写到论文里，因为这反而会读者更糊涂。 3.6 报告：如何写好报告综述报告的要点。 第一，综述报告要关注不同水平的读者。 第二，综述报告的覆盖面要全。 论文强调的是重点突出，而综述报告要求覆盖面全。 第三，综述报告特别强调内容的对等性。 报告中呈现的要点，需要在同一个层次上。 报告写不好最常见的原因就是忘记了对等性原则。把不同层次的内容放到一起写，会让听众和读者感觉非常混乱。如政府的工作报告，里面的主要内容都符合对等性原则。 第四，综述报告不重过程，只重结论。 研究报告的四个要点。 第一，研究报告的分析要中立、客观、到位。 第二，研究报告要做好横向和纵向对比。 第三，研究报告要注意证据的充分性和数据的规范化。 非常的结论要有非常的证据支持，这点对研究报告来说同样重要。 第四，研究报告要对数据做解读，甚至做可视化处理。 研究报告的结论和结论的合理性最重要。 概括来说，综述报告要关注不同水平的读者，内容上争取全面覆盖，讲究内容对等；研究报告则更注重对比，注重数据和证据，还要对证据进行分析。善于写报告，你就会变成更专业的人。 第 4 章 听和说的艺术4.1 听的艺术：如何高效、高质地接收信息第一，做一个有效率的听众，自己要有所准备。 对于一次性的报告，就需要先了解报告的大致内容，以及听这次报告的目的。带着问题去听，效果就会好很多。 如果有非常想了解的内容就去听。听到那部分内容就算达到目的了。 第二，要预判重点和关键点。 重点是说话人想传递的主要信息；关键节点是报告中所有结论都绕不过去的环节，没有听懂关键节点，就听不懂后面的内容。 讲报告时需要结构式地分解自己提供的干货。 听报告时，把关注的重点放在以下四个方面中的一个： 能否学到新方法或者了解新的知识； 能否听到感兴趣的结果； 能否学到分析问题的过程和逻辑； 能否学到做报告的方法（事实上，我的口才就受益于听了很多报告）。 第三，适当做笔记。 可以向老师或者报告者要讲义或PPT，拍照等。 做笔记主要是为了两个目的，一方面是记录下自己非常有感悟的重要之处，另一方面是记录下不懂之处，特别是接下来要问的问题。 遇到不明白怎么办？最有效的办法就是提问。 第四，通过提问搞懂没有听懂的地方。 问题不过夜。 提问还有一个目的，就是衡量所听内容的可信度。 第五，找出报告者打马虎眼的地方。 如何判断信息的真伪？解决这个问题最好的办法，就是提问和讨论。 报告人会打马虎眼，或者发表一些带有非常明显的主观倾向的观点。我们就需要通过提问找出对方的问题——是否夸大了结论或者隐藏了条件，是否在推理中加入了不适当的主观假设，等等。 在上述方法中，最核心的是做一名主动的听众。 4.2 说的艺术：能说、会说的背后有什么秘诀表达出来，让自己和全组的工作受到认可。 打磨汇报材料，设计好每张PPT结束、轮换时的停顿、过渡等等。多次修改，多次预演。每次讲的内容背的滚瓜烂熟。 做报告时，即使不能把内容背得滚瓜烂熟，至少也要把讲的内容写到纸上，这样最不济还能拿出来照着念。 好的口才不是天生的，而可以训练出来的。 4.3 口头表达：怎样讲才能达到预期的效果明确一件事情，就是无论怎样讲，都要以对方接收到自己的信息为目标。 克林顿的表达方式，总是以平静、有节制的语调，去夸自己过去几年最主要的成绩。平静而有节制的讲话的方式很重要，因为只有那样讲，大家才会相信你讲的内容。克林顿还善于抓信对手的逻辑漏洞，巧妙地把矛头对准对方。不过在批评和挖苦对方时，要用风趣的但不庸俗的语言，不能直接攻击对方。 为了让口头表达达到预期的效果，需要从讲知人自身以及听讲人角度这两个方向刻意训练自己。 首先，站在讲话人的角度来讲，要解决的核心问题是讲什么、不讲什么。讲的内容一定要有明确的主题，主题之下要有清晰的侧重点。“四讲四不讲”原则。 第一，最重要的主题讲，其余的都不讲。 不妨把要讲的内容列一个清单，然后删除次要的内容。删到不能再删了，就差不多了。《论语》中，孔子一次也只讲一个话题。所以永远不要觉得自己比孔子还能讲，不要觉得自己能同时讲好多个话题。 第二，能讲清楚的讲，讲不清楚或者太花时间的不讲。 做学术报告的原则——永远不要试图在有限的时间里，讲那些需要花很长时间解释且容易引起听众疑问的结果，即使这那个结果在你看起来好得不得了。 第三，自己的独到之处讲，别人都有的东西不讲。 向上级申请资源，找一个别人没有的理由，而不是最重要的理由，这样做的效果也可能会好一些。 第四，对自己和对方有利和话讲，对自己和对方没有好处的话不讲。 怎样提高口头表达能力。三个要点： 第一，口头表达要有对象感。 跟写书、写新闻报道不一样，口头表达是对特定对象说话。以一种对方愿意接受的方式传递信息，比用自己觉得最精彩的方式讲效果好得多。 第二，口头表达要有吸引力。 如，讲故事、类比和对比是最简单、最常用的增加讲话吸引力的方法。 《孟子》一书，以故事开头，但是最后总会把话题引到他想讲的道理上。 每个人都有自己熟悉的生活场景，听到和自己的生活场景类似的内容，就更容易接收信息。 有对比才有高下之分，因此在口头表达时，多做对比，听众的印象才会深刻。 第三，口头表达要掌握节奏。 从信息论的角度讲，要想让信息传输过程中没有损失，就需要增加一些冗余度，也就是一些废话和重复的话。 讲话的时候刻意留一些悬念，引起听众的好奇甚至是提问，再以解答疑惑的方式把自己的意思表达出来，对方就会觉得是自己挖掘到的信息，而不是被灌输的。 4.4 内容再呈现：如何让表达效果最大化无论是口头表达还是书面表达，做好内容的再呈现都是非常必要的。 我们需要明确，报告是以口头表达为核心的，PPT只是提供辅助信息，不能喧宾夺主。防上下陷入四种做PPT的误区。 误区一，PPT过于花哨或过于复杂。 误区二，PPT有太多文字。 PPT中一定不能有长句子，更不能有大段的文字，除了引用名人名言。 误区三，PPT就是讲稿的摘要和内容提纲。 PPT和讲稿应该是互补的，对于同一件事情，PPT从一个视角展示内容，讲话者的语言则从另一个角度来诠释。 误区四，PPT的数量太多。 PPT的数量不要超过讲话时长（分钟计）除以二得到的数。比如，讲三十分钟，准备十五张PPT就够了。 内容的再呈现要符合人接收信息的基因。 用相对多少或大小的数量词给读者一个大致的概念。无论是口头表达，还是书面表达，都需要对内容进行这样的再呈现，而不是直接给出原始的内容。 内容的展示需要根据读者和听众的不同而有所不同。 小结听和说是相互影响的，学会听别人怎么说，可以提高自己的口头表达能力；反过来，站在听众的角度多想想，也可以让自己说得更精彩。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"如何写读书笔记","slug":"如何写读书笔记","date":"2023-01-07T03:50:03.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"如何写读书笔记.html","link":"","permalink":"https://liangyuanzheng.com/%E5%A6%82%E4%BD%95%E5%86%99%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"写读书笔记是一种好习惯，可以加强对书的内容的理解，取得很好的学习效果。写读书笔记一般有以下方法： 1、表格式。先制成表格，在阅读过程中逐步填写，内容包括：书名或文题名、作者、出版日期、出版社或报社、阅读日期。 2、提纲式。把读物中主要的意思编成提纲写下来，要表达出主要内容和次要内容。 3、摘录式。把读物中有意义的话、精彩的描写等摘录下来，包括词语、句子、句群、段落，供平日熟读成诵。 4、心得式。把阅读文章后的心得写下来，记下读了什么书(文章)，书中哪些内容对自己教育最深，使自己在思想认识上、道德行为上获得哪些提高。 5、评论式。评论读物中的人物和事件，分辨是非、分清敌我。主要内容可分为：书名或文章题目，主要人物(或事件)，我的评论意见。 6、简缩式。用缩写的方法，把故事内容简缩成一段短文。 7、探索式。主要目的是为了有计划地探索阅读中遇到的各种疑难，先边读边记，再分别探索。其内容可以列成这样几项：书名或文章题目、疑难问题，准备怎样探索。 8、介绍式。读了文章以后，把它的主要内容、具体收获，一一有条理地加以叙述。 9、批注式。如果书是自己的，可以边读边思边在文章的上下左右空白处进行批注。批注的内容可以抒发感想，提出质疑，也可以叙述教益、个人见解及其他与书中内容有关的知识等。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangyuanzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"京剧经典节目","slug":"京剧经典节目","date":"2022-12-25T13:28:14.000Z","updated":"2025-10-27T00:35:41.793Z","comments":true,"path":"京剧经典节目.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BA%AC%E5%89%A7%E7%BB%8F%E5%85%B8%E8%8A%82%E7%9B%AE.html","excerpt":"","text":"现代经典《红灯记》京剧艺术片《红灯记》，是文化大革命期间的八大样板戏之一，八一电影制片厂1970年摄制。 影片根据中国京剧团的现场演出拍摄，片中讲述的是抗日战争时期，我党地下工作者李玉和一家三代，为向游击队转送密电码而前仆后继、与日寇不屈不挠斗争的英雄故事。 《红灯记》的故事取材于电影《自有后来人》，此剧是中国京剧院的优秀保留剧目。 剧情简介 抗日战争时期，东北某地隆滩火车站，共产党员李玉和，公开身份是铁路工人。这天，李玉和接到上级通知，说上级派了一个交通员，乘今晚七点半的火车来和他接头。此时敌人也得到情报，对火车站实行了戒严。王连举发现情况不妙，找到李玉和，李玉和说以后要尽量少见面，把王连举打发走了。这时火车隆隆进站，交通员从车上跳下摔昏，李玉和让王连举掩护，自己把交通员背到家中，对上暗号，交通员把密电码交给李玉和，让他设法交给柏山游击队的磨刀人。李玉和带着密电码来到接头地点，磨刀人也赶到，二人正欲接头，日本宪兵同时赶到，搜查在场人员。接头不成，李玉和把密电码放进饭盒，敌人没搜去。 敌人为找到密电码，拷问王连举，王连举叛变，供出李玉和。宪兵队长鸠山，对李玉和软硬兼施，用尽了所有伎俩，李玉和死不开口。鸠山又到李玉和家中骗取密电码，失败，只好把李玉和一家三口押到刑场，打死了李玉和母子。释放了李铁梅，企图通过对铁梅实施监控的方法得到密电码。铁梅带上密电码，在邻居田慧莲一家的掩护下，逃出虎口，直奔柏山。路遇磨刀人，此时，鸠山率宪兵队追赶铁梅至此，磨刀人让一个战士护送铁梅上山，自己率部分战友阻击敌人，打斗间，柏山游击队从山上杀下，把敌人一举歼灭。山上，铁梅把密电码交给游击队长，众战士欢庆胜利。 场次 第一场：接应交通员；第二场：接受任务； 第三场：粥棚脱险；第四场：王连举叛变；第五场：痛说革命家史；第六场：赴宴斗鸠山；第七场：群众帮助；第八场：刑场斗争；第九场：前赴后继；第十场：伏击歼敌；第十一场：胜利前进。 选段“痛说革命家史”选段“雄心壮志冲云天”《平原作战》故事情节 中国抗日战争时期，晋察冀边区派出中国共产党员、八路军排长赵勇刚来到日占区华北平原某地张庄，组织游击队，在当地的共产党支部书记李胜和群众张大娘、小英等人的帮助下，打击当地的日军大队长龟田和伪军特务队长孙守财的武装，炸毁运送军火的火车。最后在主力部队到来之后击毙龟田。 场次 第一场：星夜下山；第二场：龟田被拴；第三场：鱼水情深；第四场：智取炮楼；第五场：不屈不挠；第六场：袭扰县城；第七场：日寇诡计；第八场：青纱帐里；第九场：爆炸军火；第十场：平原歼敌。 流行唱段 披星戴月下太行 人民的安危冷暖要时刻挂心上 好妈妈疼爱咱象亲娘一样 哪里有人民哪里就有赵勇刚 以血还血 以牙还牙 做一个中华好儿女 毛主席的革命路线指引我永不迷航 选段 “做一个中华好儿女”《沙家浜》故事情节 在抗日战争期间，中国江苏常熟市郊区阳澄湖畔沙家浜的一批新四军伤病员在郭建光的带领下潜伏下来养伤。中共地下党员“春来茶馆”老板娘阿庆嫂在淞沪会战期间掩护过地方武装头目胡传魁。胡传魁在何去何从的问题上犹豫不决。从日本留学归国的当地乡绅子弟刁德一是日本、重庆国民政府的双重间谍。他当了胡传魁的参谋长之后终于说服了胡传魁的“忠义救国军”投靠了日本人。在阿庆嫂的情报帮助下，养伤复原的新四军袭击了在刁德一家中纳妾的胡传魁，俘虏了胡传魁、刁德一和日本大佐黑田及其翻译。 场次 第一场：接应； 第二场：转移； 第三场：勾结； 第四场：智斗； 第五场：坚持； 第六场：授计； 第七场：斥敌； 第八场：奔袭； 第九场：突破； 第十场：聚歼。 著名选段 【唱】 胡传魁：想当初，老子的队伍才开张，总共才有十几个人，七八条枪。遇皇军追得我，晕头转向；多亏了阿庆嫂，她叫我水缸里面把身藏。她那里提壶续水，面不改色无事一样，骗走了东洋兵，我才躲过大难一场。（阿庆嫂上）似这样救命之恩终身不忘，俺胡某讲义气，终当报偿。（对阿庆嫂抱拳） 【白】 刁德一：这个女人那不寻常。 阿庆嫂：刁德一！有什么鬼心肠？ 胡传魁：这小刁一点面子也不讲。 阿庆嫂：这草包倒是一堵挡风的墙。 【唱白】 刁德一：阿庆嫂，适才听得司令讲，阿庆嫂真是不寻常。我佩服你、沉着机灵有胆量，竟敢在鬼子面前耍花枪。若无有抗日救国的好思想，焉能够舍己救人不慌张。 阿庆嫂：参谋长，休要谬夸奖，舍己救人不敢当。开茶馆，盼兴旺，江湖义气第一桩。司令常来又常往，我有心，背靠大树好乘凉。也是司令的洪福广，方能遇难又呈祥。 刁德一：新四军久在沙家浜，这棵大树有荫凉。你与他们常来往，想必是、安排照应更周详。 阿庆嫂：垒起七星灶，铜壶煮三江。摆开八仙桌，招待十六方。来的都是客，全凭嘴一张。相逢开口笑，过后不思量。人一走，茶就凉。有什么周～详～不周～详～。 选段“智 斗”**沙家浜**革命现代京剧之一， 八个样板戏之一。最精彩的唱段就是《智斗》。《智斗》是阿庆嫂、刁德一和胡传魁三人最精彩的唱段，广为流传、家喻户晓。 主要人物 阿庆嫂：春来茶馆的老板娘，中共地下工作者。 刁德一：忠义救国军参谋长。 胡传魁：忠义救国军司令。 唱词 胡传魁： 想当初， 老子的队伍才开张， 拢共才有十几个人，七八条枪。 遇“皇军”追得我，晕头转向， 多亏了阿庆嫂， 她叫我水缸里面把身藏。 她那里提壶续水，面不改色无事一样, 哄走了东洋兵，我才躲过大难一场。 似这样救命之恩终身不忘，俺胡某讲义气，终当报偿。 阿庆嫂： 胡司令： 这么点儿小事儿，您别总挂在嘴边儿上， 当时我也是急中生智， 事过之后您猜怎么着， 我还是真有点儿后怕呀。 参谋长，烟不好，请抽一支， 胡司令，抽一支！ 刁德一∶这个女人那不寻常。 阿庆嫂∶刁德一有什么鬼心肠? 胡传魁∶这小刁，一点面子也不讲。 阿庆嫂∶这草包倒是一堵挡风的墙。 刁德一∶她态度不卑又不亢。 阿庆嫂∶他神情不阴又不阳。 胡传魁∶刁德一，搞得什么鬼花样。 阿庆嫂∶他们到底是姓蒋还是姓汪? 刁德一∶我待要旁敲侧击将她访。 阿庆嫂∶我必须察言观色把他防。 刁德一∶ 阿庆嫂， 适才听得司令讲， 阿庆嫂真是不寻常。 我佩服你沉着机灵有胆量, 竟敢在鬼子面前耍花枪。 若无有抗日救国的好思想， 焉能够舍己救人不慌张。 阿庆嫂∶ 参谋长休要谬夸奖， 舍己救人不敢当。 开茶馆，盼兴望， 江湖义气是第一桩。 司令常来又常往， 我有心，背靠大树好乘凉。 也是司令的洪福广， 方能遇难又呈祥。 刁德一∶ 新四军久在沙家浜， 这棵大树有荫凉。 你与他们常来往， 想必是安排照应更周详。 阿庆嫂∶ 垒起七星灶， 铜壶煮三江。 摆开八仙桌， 招待十六方。 来的都是客， 全凭嘴一张。 相逢开口笑， 过后不思量。 人一走，茶就凉。 有什么周详不周详。 胡传魁：哈哈哈…… 《江 姐》江姐是中华人民共和国一部以江竹筠为原型的歌剧，首演于1964年[1]。歌剧的故事根据阎肃的小说《红岩》改编，羊鸣、姜春阳、金砂等人作曲。《红梅赞》是江姐的主题曲。故事讲述的是中国共产党地下党员江雪琴（江姐）在中国人民解放军攻占重庆前夕被中华民国政府处决[2]。 选段“绣红旗”《蝶恋花》1927年，大革命失败后，杨开慧同志留在长沙东乡板仓冲，团结和领导群众，坚持地下斗争，直至1930年10月被捕，不怕敌人的威胁和利诱，宁死不降，11月14日英勇就义。展现了中国共产党人“唯有牺牲多壮志，敢叫日月换新天”的伟大精神。 选段 “古道别”《智取威虎山》故事情节 1964年 毛泽东与智取威虎山表演剧组 1946年冬季，解放战争初期，东北牡丹江一带。解放军某部团参谋长少剑波率领三十六人的追剿队，在击破奶头山之后，乘胜进军，准备消灭“座山雕”匪帮。侦察排长杨子荣得知座山雕逃回威虎山，向少剑波汇报。少剑波下令继续向前方侦察，到黑龙沟会合。 座山雕匪帮在回威虎山途中，一路洗劫，又来到夹皮沟烧杀抢掠，强掳青壮男女上山修筑工事。李勇奇深受大害，儿子被匪徒摔死，妻子被座山雕枪杀。李勇奇极力反抗，但寡不敌众，被匪掳走。杨子荣等四人沿途侦察，访问了躲藏在深山的常猎户父女。常猎户的女儿常宝闻知杨子荣是中国人民解放军，进山剿匪，为民除害，她怀着深仇大恨，控诉了座山雕的滔天罪行。 杨子荣在常猎户父女的帮助下，得悉威虎山的山路和土匪的野狼嗥的行踪。杨子荣从一撮毛身上获得了载有土匪秘密联络地点的“联络图”，胜利归来，并侦知此图为座山雕垂涎已久。杨子荣又审讯了栾平，核实了“联络图”的情况。由于威虎山工事复杂，不宜强攻，大家都认为只能智取。杨子荣自请改扮土匪胡彪，假借献图，打入威虎山。杨子荣来到匪窟威虎厅，通过座山雕的种种试探，并把“联络图”献给了座山雕，取得了初步信任。座山雕“封”杨子荣为威虎山的“老九”和“上校团副”。夹皮沟群众饥寒交迫。李勇奇冒死逃出匪窟，转回家来，母子相逢，悲喜交集。少剑波率追剿队进驻夹皮沟，当地人民因久遭匪患，不明真相，加以敌视。少剑波对李勇奇母子耐心宣传党的政策，解除疑虑，表示全力支援解放军，消灭座山雕匪帮。 座山雕对杨子荣深存戒心，满腹狐疑，设下毒计，再一次进行试探。杨子荣深入敌人心脏，又一次通过了座山雕的试探，将搜集到的情报送下山冈。孙达得及时取回杨子荣的情报。这时押运犯人的小米车二道河被土匪炸毁，野狼嗥炸死，栾平逃走。少剑波考虑到栾平若逃往威虎山，将破坏整个歼敌大计，便下令急速出兵。追剿队由李勇奇带路，迎着风雪，翻山越岭，滑雪疾进。栾平突然逃到威虎山，他在座山雕面前指认杨子荣。杨子荣在这生死成败关头，发挥了革命军人的大智大勇，战胜了栾平，并将顽匪置于死地。在“百鸡宴”上，杨子荣把座山雕与一干匪徒灌醉，追剿队及时赶到，全歼匪众，无一漏网，赢得胜利。 场次 第一场：乘胜进军；第二场：夹皮沟遭劫；第三场：深山问苦；第四场：定计；第五场：打虎上山；第六场：打进匪窟；第七场：发动群众；第八场：计送情报；第九场：急速出兵；第十场：会师百鸡宴。 选段“发动群众”《海港》故事情节 1963年，总路线执行期间，上海港要在台风来袭之前完成对北欧出口的玻璃纤维和对非洲援助的稻种和小麦的搬运工作。受到台湾国民党、日本、美国多重指派的潜伏特务钱守维趁机制造事故，把一些玻璃纤维放到一袋小麦中，再把小麦和稻种调包，试图破坏中国的国际声誉。中国共产党党支部书记方海珍和装卸组长高志扬等人发现问题，教育了不安心装卸工作的青年工人韩小强，处理了事故，捉获了企图潜逃的钱守维。 场次 第一场：突击抢运；第二场：发现散包；第三场：追查事故；第四场：战斗动员；第五场：深夜翻仓；第六场：壮志凌云；第七场：海港早晨。 流行唱段 大吊车，真厉害，成吨的钢铁，它轻轻地一抓就起来！ 细读了全会公报 咱们可不能麻痹大意，只听见机器声，听不见阶级敌人霍霍的磨刀声啊！ 莫以为码头上无风无浪，上海港从来就是激烈的战场。 选段 “忠于人民忠于党”传统名段《红 娘》选段“小姐多风采”演 唱 者： 张馨心（优秀花旦演员） 《霸王别姬》《霸王别姬》是京剧艺术大师梅兰芳编创的梅派青衣经典名剧之一。故事讲述楚汉相争末期，西楚霸王项羽中了韩信十面埋伏之计被困垓下（史称“垓下之围”），汉营随后使出四面楚歌之计，让汉军在项羽扎营处周围大唱楚歌，使得项羽士兵军心涣散，项羽以为楚军皆投降刘邦，大势已去。项羽于是唱起“垓下歌”在营帐中摆下酒宴与虞姬同饮作别，虞姬也为项羽舞剑，舞罢便自刎殉情。悲伤不已的项羽后杀出重围，鏖战后逃至乌江自觉无颜见江东父老而自刎江边。 此剧原名《楚汉争》，根据昆曲《千金记》和《史记·项羽本纪》编写而成。总共四本。1918年，由杨小楼、尚小云在北京首演。1922年2月15日，杨小楼与梅兰芳合作。齐如山、吴震修对《楚汉争》进行修改，更名为《霸王别姬》。 选段“看大王”演 唱 者： 赵悦然（优秀青衣演员） 《打龙袍》三侠五义戏，《打龙袍》 京剧名，常与《遇皇后》二剧联演，称《遇后龙袍》，又名《天齐庙》、《赵州桥》、《断后》。出自清代古典名著《三侠五义》第一回、第十五回、第十六回、第十七回、第十八回、第十九回内容。为净角与老旦的传统合作戏，为李派的传统剧目之一。 剧情简介 讲述北宋仁宗年间，包拯奉旨陈州（河南省周口市东北部的淮阳区）放粮，在天齐庙遇盲丐妇告状，历数当年宫闱秘事。此妇即是真宗之妃，是当朝天子之母，并有黄绫诗帕为证。包拯当即答应代其回朝辨冤。包拯回京，借元宵观灯之际，特设雷强张继保灯戏，指出皇帝不孝。仁宗一怒，要斩包拯。经老太监陈琳说破当年狸猫换太子之事，才赦免包拯，迎接李后还朝。李后要责仁宗，命包拯代打皇帝。包拯脱下仁宗龙袍，用打龙袍象征打皇帝。 选段“龙车凤辇进皇城”演 唱 者： 郭瑶瑶（国家一级演员） 《锁麟囊》《锁麟囊》是1940年由剧作家翁偶虹应程砚秋之约而作的京剧剧本，故事题材取自焦循《剧说卷三》引述清初笔记小说《只麈谈》 故事大意 乙酉年六月十八，登州富家小姐薛湘灵出嫁，花轿于途中遇雨，在春秋亭暂避；彼时载着贫女赵守贞的另一架花轿也避入其里。赵守贞感叹贫富相遇，世态炎凉，因而啼哭。湘灵仗义怜惜，从嫁资中取内贮珠宝之锁麟囊相赠，赵父询问湘灵姓名以便日后报恩，湘灵却不许婢女梅香告知对方自己的名氏。登时雨止，二人别去。 六年后，洪水洗劫登州，湘灵与家人失散之后逃难到了莱州，为求生计，只好在当地绅士卢家为奴。一日陪刁蛮小公子天麟在夫人曾嘱勿上的小楼下游戏，公子将球抛入小楼上，逼薛取球，湘灵不得已而为之，却见己当日赠贞之锁麟囊供在楼上，不觉悲泣，原来卢夫人即是昔日的贫家女赵守贞。卢夫人在小楼见湘灵见囊哭泣，心中生疑，问答之间得知湘灵即是当年赠宝的恩人。卢夫人既知湘灵为赠囊之人，好生感慰，敬如上宾，恰逢此时湘灵一家老小脱难寻来，最终阖家团聚。 艺术成就 声腔艺术上的成就在程派剧目中独居魁首。全剧每一折都有精彩唱段，尤以“选妆奁”中的“四平调”，“春秋亭”中大段的“二六”和“流水”, “打粥进府-绣楼”中的“二黄三眼”, “三让椅”中的“西皮原板”转“二六”，以及“团圆”中“二六”最为脍炙人口。1983年纪念程砚秋先生逝世25周年，程门五大弟子（按出场序依次为李蔷华、李世济、赵荣琛、王吟秋、新艳秋）合演《锁麟囊》, 可谓此剧的标本. 品位高雅，佳句叠出，结构巧妙，节奏得法，张驰有度。 选段“春秋亭外风雨暴”春秋亭外风雨暴，何处悲声破寂寥。隔帘只见一花轿，想必是新婚渡鹊桥。吉日良辰当欢笑，为何鲛珠化泪抛。此时却又明白了，（流水）世上何尝尽富豪。也有饥寒悲怀抱，也有失意痛哭嚎啕。轿内的人儿弹别调，必有隐情在心潮。耳听得悲声惨心中如捣，同遇人为什么这样嚎啕？莫不是夫郎丑难谐女貌，莫不是强婚配鸦占鸾巢？叫梅香你把那好言相告，问那厢因何故痛哭无聊？梅香说话好颠倒，蠢材只会乱解嘲。怜贫济困是人道，哪有个袖手旁观在壁上瞧!蠢材问话太潦草，难免怀疑在心梢。你不该人前逞骄傲，不该词费又滔滔。休要噪，且站了。薛良与我去问一遭。听薛良一语来相告，满腹骄矜顿雪消。人情冷暖凭天造，谁能移动他半分毫。我正不足他正少，他为饥寒我为娇。 分我一枝珊瑚宝，安他半世凤凰巢。忙把梅香低声叫，莫把姓名信口晓。这都是神话平空造，自把珠玉夸富豪。麟儿哪有神送到，积德才生玉树苗。小小囊儿何足道，救他饥渴胜琼瑶。 这才是人生难预料，不想团圆在今朝。 回首繁华如梦渺，残生一线付惊涛。 柳暗花明休啼笑，善果心花可自豪。 种富得富如此报，愧我当初赠木桃。 链接：https://www.zhihu.com/question/26036291/answer/149856096 《沙桥饯别》选段“提龙笔”演 唱 者： 杜 喆（国家一级演员） 《四郎探母》剧情简介 北宋时，辽王耶律贤设“双龙会”于幽州，邀宋太宗（光义）赴会议和。杨家将八虎护驾随往，中伏兵败，四郎（延辉）被擒，改名木易，与铁镜公主耶律琼娥成婚。十五年后，适辽邦萧天佐摆天门阵，杨六郎（延昭）御于飞虎峪，佘太君押粮抵营；四郎思母，欲往探，为公主识破，乃以实相告；公主计盗令箭，助其出关，四郎当夜私回宋营，与佘太君、杨六郎、发妻孟氏及两妹相聚。黎明，四郎返辽，被萧太后察知，欲斩，经公主求情，赦免。 剧目演变 清末四大徽班之一的四喜班有演连台本戏《雁门关》，其中有《八郎探母》一段。当时的剧情为：双龙会后，四郎和八郎均被辽国所擒，双双招为驸马。十二年后六郎与辽交战，佘太君率杨门女将助战。八郎得知此事，哀求公主骗取令箭入宋营探母。六郎趁机利用令箭混入辽军，打败辽军。萧太后察觉令箭被骗取后欲杀公主[1]。 中华人民共和国成立后，该剧被赋予“鼓吹投降主义”、“美化叛国变节”的政治意义，多次被禁[2]，直到改革开放后才全面恢复演出，是各院团常演剧目。 选段“杨宗保在马上忙传将令”演 唱 者： 江其虎（国家一级演员） 《坐寨盗马》清朝时，窦尔敦在口外连还套聚义，闻听梁九公口外行围，带有清帝所赐御马，顿时想到黄三太镖伤之仇，乃下山暗入梁营。 剧情简介 将御马盗去，并留下黄三太姓名。 《盗御马》《连环套》的剧情简介 一名《坐寨盗马》，又名《盗御马》。清朝时，窦尔墩被黄三太镖伤后，愤至口外连环套聚义。十数年后闻梁九公出口外行围，携有清帝赐御马，忆及前仇，乃下山暗入梁营，将御马盗去，并留下黄三太姓名。梁九公失落御马，见柬留黄三太之名，知黄已死，乃调其子记名总兵黄天霸问罪，彭朋与黄三太有旧情，暗中庇护，限令访拿。黄天霸乔妆镖客出口外，遇窦部下贺天龙，擒之，闻窦名，故释之，假意拜山，诱窦自承盗马，黄先用软语求告，窦疑之，黄道出真名，又以语激窦，约次日比武，，得脱下山，朱光祖夜入连环套，盗窦双钩，而将黄之刀插留案间，次日反责窦无勇，窦中计，怒献御马，随兵到官。又名《连还套》。 选段“将酒宴摆置在聚义厅上”演 唱 者： 王 越 （国家一级演员） 《贵妃醉酒》《贵妃醉酒》又名《百花亭》，源于清乾隆时花部地方戏《醉杨妃》的京剧剧目，是梅派代表剧目。写的是唐玄宗宠妃杨玉环与明皇约在百花亭赴筵，久候明皇不至，原来他早已转驾西宫。贵妃羞怒交加，万端愁绪无以排遣，遂命高力士、裴力士添杯奉盏，饮致大醉，怅然返宫。该剧经梅兰芳加工点缀，成为“梅派”经典演出剧目之一。 2002年，梅葆玖等根据梅兰芳原作《贵妃醉酒》、《太真外传》等改编成的大型交响京剧《大唐贵妃》，始由上海京剧院、中国京剧院、北京京剧院合作演出，以大布景、大制作闻名于市，是京剧改革的一个方向和尝试。 2007年，中国第一颗探月卫星嫦娥一号中，也特别选用这首歌曲选段搭载。 经典歌词 【四平调】 海岛冰轮初转腾， 见玉兔（啊）， 玉兔又早东升。 那冰轮离海岛， 乾坤分外明， 皓月当空， 恰便似（啊）嫦娥离月宫， 奴似嫦娥离月宫。 接【万年欢】牌子（间奏），再接【四平调】 【四平调】 好一似嫦娥下九重， 清清冷落在广寒宫， 啊， 在广寒宫。 玉石桥斜倚把栏杆靠， 鸳鸯来戏水， 金色鲤鱼在水面朝， 啊， 在水面朝， 长空雁， 雁儿飞， 哎呀雁儿呀， 雁儿并飞腾， 闻奴的声音落花荫， 这景色撩人欲醉， 不觉来到百花亭。 选段“海岛冰轮”演 唱 者： 李胜素 著名京剧表演艺术家 《大登殿》《大登殿》（传统剧目）讲述的是薛平贵得到代战公主的援助，攻破长安，拿获王允、魏虎，自立为帝，坐上龙位，封官授爵，清算余孽的情景：薛平贵在金殿封王宝钏、代战公主为昭阳正宫，分掌后宫、兵权；迎送王夫人去养老宫颐养天年；分封苏龙，问斩魏虎；王允死罪不免，经王宝钏再三求情，得赦，授衔无权，居家养老。 简介 《大登殿》是传统京剧《红鬃烈马》中的一折。全剧有《彩楼配》、《三击掌》、《投军别窑》也称《平贵别窑》、《银空山》、《武家坡》、《算军粮》、《大登殿》等数折。 《红鬃烈马》为清代花部乱弹作品。《清稗类钞》记载为秦腔演出剧目。又名《回龙鸽》、《王宝钏》。作者不详。 《红鬃烈马》在我国北方广为流行，剧目剧本、唱词因表演程式与演唱风格的差异，精彩纷呈。 梆子戏传统剧目，称《红鬃烈马》（又名《王宝钏》）的下本。一般由《武家坡》、《算粮》、《大登殿》三折构成。 秦腔、河南梆子、河南越调、河北梆子，均有不同版本，有些也流传至南方。 故事梗概 唐丞相王允，生有三女，大女王金钏，嫁苏龙，官居户部；二女王银钏，配魏虎，兵部侍郎；三女王宝钏，未曾婚配，王允在长安城内高搭彩楼，为三女儿宝钏招赘快婿。宝钏到花园焚香祈祷，见园外有一乞丐，仪表不凡，倒卧雪地，询问之后，知其名曰薛平贵。王宝钏慕其才志，心中暗许，赠以银米，嘱他参加选婿盛会。 二月二日，宝钏奉旨登楼选婿，她撇开众多公子王孙，却将彩球抛赠薛平贵。王允愤怒，与宝钏断绝关系。 宝钏下嫁薛平贵，同住寒窑。后来薛平贵因降服红鬃烈马有功，唐王大喜，封为后军都督。西凉下来战表，王允参奏，推次女婿魏虎、长女婿苏龙为正、副元帅，将平贵降为“先行”，受隶于魏虎麾下，即刻远征。 平贵无奈与宝钏告别，留下老米八斗，干柴十担，挥泪而去。出征西凉战中，魏虎与王允合谋，屡找借口，欲斩平贵，经苏龙阻拦，遂加鞭笞，即令会阵。平贵竭力苦战，获得大胜。魏虎又以庆功为名，灌醉平贵，缚马驮至敌营。西凉王爱才，反将代战公主许之。西凉王死，平贵继位为王，驾坐西凉。 过了十八年，王宝钏清守寒窑，备尝艰苦。老母亲身探望，并无懈志。一日，平贵思念王宝钏，忽有鸿雁衔书而至。平贵见王宝钏血书，急欲回国探望，暂别公主，偷过“三关”，樵装回国。路过武家坡，遇王宝钏。夫妻离别十八年，互不相识，薛平贵问路以试其心，王宝钏逃回寒窑，薛平贵赶至，直告别后经历，夫妻相认。 不久，唐王晏驾，王允篡位，兴兵捉拿平贵；代战公主保驾。在代战的帮助下，薛平贵攻陷长安，自立为帝。金殿之上，平贵封赏苏龙、斩除魏虎、赦免王允。封宝钏为正宫娘娘掌管昭阳院、代战公主为西宫娘娘掌管兵权。迎请王母，共庆团圆。 选段“龙凤阁内把衣换”演 唱 者： 于魁智 著名京剧表演艺术家 戏 歌 《三生之梦入梨园》演 唱 者：于魁智 李胜素","categories":[{"name":"京剧","slug":"京剧","permalink":"https://liangyuanzheng.com/categories/%E4%BA%AC%E5%89%A7/"}],"tags":[{"name":"现代经典","slug":"现代经典","permalink":"https://liangyuanzheng.com/tags/%E7%8E%B0%E4%BB%A3%E7%BB%8F%E5%85%B8/"},{"name":"传统名段","slug":"传统名段","permalink":"https://liangyuanzheng.com/tags/%E4%BC%A0%E7%BB%9F%E5%90%8D%E6%AE%B5/"}]},{"title":"effective-go chapter15","slug":"effective-go chapter15","date":"2022-12-14T13:13:07.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter15.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter15.html","excerpt":"","text":"A web serverLet’s finish with a complete Go program, a web server. This one is actually a kind of web re-server. Google provides a service at http://chart.apis.google.com that does automatic formatting of data into charts and graphs. It’s hard to use interactively, though, because you need to put the data into the URL as a query. The program here provides a nicer interface to one form of data: given a short piece of text, it calls on the chart server to produce a QR code, a matrix of boxes that encode the text. That image can be grabbed with your cell phone’s camera and interpreted as, for instance, a URL, saving you typing the URL into the phone’s tiny keyboard. Here’s the complete program. An explanation follows. package main import ( &quot;flag&quot; &quot;html/template&quot; &quot;log&quot; &quot;net/http&quot; ) var addr = flag.String(&quot;addr&quot;, &quot;:1718&quot;, &quot;http service address&quot;) // Q=17, R=18 var templ = template.Must(template.New(&quot;qr&quot;).Parse(templateStr)) func main() { flag.Parse() http.Handle(&quot;/&quot;, http.HandlerFunc(QR)) err := http.ListenAndServe(*addr, nil) if err != nil { log.Fatal(&quot;ListenAndServe:&quot;, err) } } func QR(w http.ResponseWriter, req *http.Request) { templ.Execute(w, req.FormValue(&quot;s&quot;)) } const templateStr = ` &lt;html&gt; &lt;head&gt; &lt;title&gt;QR Link Generator&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{if .}} &lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&quot; /&gt; &lt;br&gt; {{.}} &lt;br&gt; &lt;br&gt; {{end}} &lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;&lt;input maxLength=1024 size=70 name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;&lt;input type=submit value=&quot;Show QR&quot; name=qr&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ` The pieces up to main should be easy to follow. The one flag sets a default HTTP port for our server. The template variable templ is where the fun happens. It builds an HTML template that will be executed by the server to display the page; more about that in a moment. The main function parses the flags and, using the mechanism we talked about above, binds the function QR to the root path for the server. Then http.ListenAndServe is called to start the server; it blocks while the server runs. QR just receives the request, which contains form data, and executes the template on the data in the form value named s . The template package html/template is powerful; this program just touches on its capabilities. In essence, it rewrites a piece of HTML text on the fly by substituting elements derived from data items passed to templ.Execute , in this case the form value. Within the template text ( templateStr ), double-brace-delimited pieces denote template actions. The piece from \\{\\{if.\\}\\ to \\{\\{end\\}\\ executes only if the value of the current data item, called . (dot), is non-empty. That is, when the string is empty, this piece of the template is suppressed. The two snippets \\{\\{.\\}\\} say to show the data presented to the template—the query string—on the web page. The HTML template package automatically provides appropriate escaping so the text is safe to display. The rest of the template string is just the HTML to show when the page loads. If this is too quick an explanation, see the documentation for the template package for a more thorough discussion. And there you have it: a useful web server in a few lines of code plus some data-driven HTML text. Go is powerful enough to make a lot happen in a few lines.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter14","slug":"effective-go chapter14","date":"2022-12-14T13:03:32.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter14.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter14.html","excerpt":"","text":"ErrorsLibrary routines must often return some sort of error indication to the caller. As mentioned earlier, Go’s multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we’ll see,os.Opendoesn’t just return anilpointer on failure, it also returns an error value that describes what went wrong. By convention, errors have typeerror, a simple built-in interface. 123type error interface &#123; Error() string&#125; A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual*os.Filereturn value,os.Openalso returns an error value. If the file is opened successfully, the error will benil, but when there is a problem, it will hold anos.PathError: 1234567891011// PathError records an error and the operation and// file path that caused it.type PathError struct &#123; Op string // \"open\", \"unlink\", etc. Path string // The associated file. Err error // Returned by the system call.&#125;func (e *PathError) Error() string &#123; return e.Op + \" \" + e.Path + \": \" + e.Err.Error()&#125; PathError‘sErrorgenerates a string like this: 1open /etc/passwx: no such file or directory Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain “no such file or directory”. When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in packageimage, the string representation for a decoding error due to an unknown format is “image: unknown format”. Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. ForPathErrorsthis might include examining the internalErrfield for recoverable failures. 1234567891011for try := 0; try &lt; 2; try++ &#123; file, err = os.Create(filename) if err == nil &#123; return &#125; if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123; deleteTempFiles() // Recover some space. continue &#125; return&#125; The secondifstatement here is anothertype assertion. If it fails,okwill be false, andewill benil. If it succeeds,okwill be true, which means the error was of type*os.PathError, and then so ise, which we can examine for more information about the error. PanicThe usual way to report an error to a caller is to return anerroras an extra return value. The canonicalReadmethod is a well-known instance; it returns a byte count and anerror. But what if the error is unrecoverable? Sometimes the program simply cannot continue. For this purpose, there is a built-in functionpanicthat in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary type—often a string—to be printed as the program dies. It’s also a way to indicate that something impossible has happened, such as exiting an infinite loop. 12345678910111213// A toy implementation of cube root using Newton's method.func CubeRoot(x float64) float64 &#123; z := x/3 // Arbitrary initial value for i := 0; i &lt; 1e6; i++ &#123; prevz := z z -= (z*z*z-x) / (3*z*z) if veryClose(z, prevz) &#123; return z &#125; &#125; // A million iterations has not converged; something is wrong. panic(fmt.Sprintf(\"CubeRoot(%g) did not converge\", x))&#125; This is only an example but real library functions should avoidpanic. If the problem can be masked or worked around, it’s always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak. 1234567var user = os.Getenv(\"USER\")func init() &#123; if user == \"\" &#123; panic(\"no value for $USER\") &#125;&#125; RecoverWhenpanicis called, including implicitly for run-time errors such as indexing a slice out of bounds or failing a type assertion, it immediately stops execution of the current function and begins unwinding the stack of the goroutine, running any deferred functions along the way. If that unwinding reaches the top of the goroutine’s stack, the program dies. However, it is possible to use the built-in functionrecoverto regain control of the goroutine and resume normal execution. A call torecoverstops the unwinding and returns the argument passed topanic. Because the only code that runs while unwinding is inside deferred functions,recoveris only useful inside deferred functions. One application ofrecoveris to shut down a failing goroutine inside a server without killing the other executing goroutines. 1234567891011121314func server(workChan &lt;-chan *Work) &#123; for work := range workChan &#123; go safelyDo(work) &#125;&#125;func safelyDo(work *Work) &#123; defer func() &#123; if err := recover(); err != nil &#123; log.Println(\"work failed:\", err) &#125; &#125;() do(work)&#125; In this example, ifdo(work)panics, the result will be logged and the goroutine will exit cleanly without disturbing the others. There’s no need to do anything else in the deferred closure; callingrecoverhandles the condition completely. Becauserecoveralways returnsnilunless called directly from a deferred function, deferred code can call library routines that themselves usepanicandrecoverwithout failing. As an example, the deferred function insafelyDomight call a logging function before callingrecover, and that logging code would run unaffected by the panicking state. With our recovery pattern in place, thedofunction (and anything it calls) can get out of any bad situation cleanly by callingpanic. We can use that idea to simplify error handling in complex software. Let’s look at an idealized version of aregexppackage, which reports parsing errors by callingpanicwith a local error type. Here’s the definition ofError, anerrormethod, and theCompilefunction. 123456789101112131415161718192021222324// Error is the type of a parse error; it satisfies the error interface.type Error stringfunc (e Error) Error() string &#123; return string(e)&#125;// error is a method of *Regexp that reports parsing errors by// panicking with an Error.func (regexp *Regexp) error(err string) &#123; panic(Error(err))&#125;// Compile returns a parsed representation of the regular expression.func Compile(str string) (regexp *Regexp, err error) &#123; regexp = new(Regexp) // doParse will panic if there is a parse error. defer func() &#123; if e := recover(); e != nil &#123; regexp = nil // Clear return value. err = e.(Error) // Will re-panic if not a parse error. &#125; &#125;() return regexp.doParse(str), nil&#125; IfdoParsepanics, the recovery block will set the return value tonil—deferred functions can modify named return values. It will then check, in the assignment toerr, that the problem was a parse error by asserting that it has the local typeError. If it does not, the type assertion will fail, causing a run-time error that continues the stack unwinding as though nothing had interrupted it. This check means that if something unexpected happens, such as an index out of bounds, the code will fail even though we are usingpanicandrecoverto handle parse errors. With error handling in place, theerrormethod (because it’s a method bound to a type, it’s fine, even natural, for it to have the same name as the builtinerrortype) makes it easy to report parse errors without worrying about unwinding the parse stack by hand: 123if pos == 0 &#123; re.error(\"'*' illegal at start of expression\")&#125; Useful though this pattern is, it should be used only within a package.Parseturns its internalpaniccalls intoerrorvalues; it does not exposepanicsto its client. That is a good rule to follow. By the way, this re-panic idiom changes the panic value if an actual error occurs. However, both the original and new failures will be presented in the crash report, so the root cause of the problem will still be visible. Thus this simple re-panic approach is usually sufficient—it’s a crash after all—but if you want to display only the original value, you can write a little more code to filter unexpected problems and re-panic with the original error. That’s left as an exercise for the reader.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter13","slug":"effective-go chapter13","date":"2022-12-14T13:03:29.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"effective-go chapter13.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter13.html","excerpt":"","text":"ConcurrencyShare by communicatingConcurrent programming is a large topic and there is space only for some Go-specific highlights here. Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan: Do not communicate by sharing memory; instead, share memory by communicating. This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs. One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there’s still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go’s approach to concurrency originates in Hoare’s Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes. GoroutinesThey’re called_goroutines_because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I&#x2F;O, others continue to run. Their design hides many of the complexities of thread creation and management. Prefix a function or method call with the go keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell’s &amp; notation for running a command in the background.) 1go list.Sort() // run list.Sort concurrently; don't wait for it. A function literal can be handy in a goroutine invocation. 123456func Announce(message string, delay time.Duration) &#123; go func() &#123; time.Sleep(delay) fmt.Println(message) &#125;() // Note the parentheses - must call the function.&#125; In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active. These examples aren’t too practical because the functions have no way of signaling completion. For that, we need channels. ChannelsLike maps, channels are allocated with make , and the resulting value acts as a reference to an underlying data structure. If an optional integer parameter is provided, it sets the buffer size for the channel. The default is zero, for an unbuffered or synchronous channel. 123ci := make(chan int) // unbuffered channel of integerscj := make(chan int, 0) // unbuffered channel of integerscs := make(chan *os.File, 100) // buffered channel of pointers to Files Unbuffered channels combine communication—the exchange of a value—with synchronization—guaranteeing that two calculations (goroutines) are in a known state. There are lots of nice idioms using channels. Here’s one to get us started. In the previous section we launched a sort in the background. A channel can allow the launching goroutine to wait for the sort to complete. 12345678c := make(chan int) // Allocate a channel.// Start the sort in a goroutine; when it completes, signal on the channel.go func() &#123; list.Sort() c &lt;- 1 // Send a signal; value does not matter.&#125;()doSomethingForAWhile()&lt;-c // Wait for sort to finish; discard sent value. Receivers always block until there is data to receive. If the channel is unbuffered, the sender blocks until the receiver has received the value. If the channel has a buffer, the sender blocks only until the value has been copied to the buffer; if the buffer is full, this means waiting until some receiver has retrieved a value. A buffered channel can be used like a semaphore, for instance to limit throughput. In this example, incoming requests are passed to handle , which sends a value into the channel, processes the request, and then receives a value from the channel to ready the “semaphore” for the next consumer. The capacity of the channel buffer limits the number of simultaneous calls to process . 1234567891011121314var sem = make(chan int, MaxOutstanding)func handle(r *Request) &#123; sem &lt;- 1 // Wait for active queue to drain. process(r) // May take a long time. &lt;-sem // Done; enable next request to run.&#125;func Serve(queue chan *Request) &#123; for &#123; req := &lt;-queue go handle(req) // Don't wait for handle to finish. &#125;&#125; Once MaxOutstanding handlers are executing process , any more will block trying to send into the filled channel buffer, until one of the existing handlers finishes and receives from the buffer. This design has a problem, though: Serve creates a new goroutine for every incoming request, even though only MaxOutstanding of them can run at any moment. As a result, the program can consume unlimited resources if the requests come in too fast. We can address that deficiency by changing Serve to gate the creation of the goroutines. Here’s an obvious solution, but beware it has a bug we’ll fix subsequently: 123456789func Serve(queue chan *Request) &#123; for req := range queue &#123; sem &lt;- 1 go func() &#123; process(req) // Buggy; see explanation below. &lt;-sem &#125;() &#125;&#125; The bug is that in a Go for loop, the loop variable is reused for each iteration, so the req variable is shared across all goroutines. That’s not what we want. We need to make sure that req is unique for each goroutine. Here’s one way to do that, passing the value of req as an argument to the closure in the goroutine: 123456789func Serve(queue chan *Request) &#123; for req := range queue &#123; sem &lt;- 1 go func(req *Request) &#123; process(req) &lt;-sem &#125;(req) &#125;&#125; Compare this version with the previous to see the difference in how the closure is declared and run. Another solution is just to create a new variable with the same name, as in this example: 12345678910func Serve(queue chan *Request) &#123; for req := range queue &#123; req := req // Create new instance of req for the goroutine. sem &lt;- 1 go func() &#123; process(req) &lt;-sem &#125;() &#125;&#125; It may seem odd to write 1req := req but it’s legal and idiomatic in Go to do this. You get a fresh version of the variable with the same name, deliberately shadowing the loop variable locally but unique to each goroutine. Going back to the general problem of writing the server, another approach that manages resources well is to start a fixed number of handle goroutines all reading from the request channel. The number of goroutines limits the number of simultaneous calls to process . This Serve function also accepts a channel on which it will be told to exit; after launching the goroutines it blocks receiving from that channel. 12345678910111213func handle(queue chan *Request) &#123; for r := range queue &#123; process(r) &#125;&#125;func Serve(clientRequests chan *Request, quit chan bool) &#123; // Start handlers for i := 0; i &lt; MaxOutstanding; i++ &#123; go handle(clientRequests) &#125; &lt;-quit // Wait to be told to exit.&#125; Channels of channelsOne of the most important properties of Go is that a channel is a first-class value that can be allocated and passed around like any other. A common use of this property is to implement safe, parallel demultiplexing. In the example in the previous section, handle was an idealized handler for a request but we didn’t define the type it was handling. If that type includes a channel on which to reply, each client can provide its own path for the answer. Here’s a schematic definition of type Request . 12345type Request struct &#123; args []int f func([]int) int resultChan chan int&#125; The client provides a function and its arguments, as well as a channel inside the request object on which to receive the answer. 123456789101112func sum(a []int) (s int) &#123; for _, v := range a &#123; s += v &#125; return&#125;request := &amp;Request&#123;[]int&#123;3, 4, 5&#125;, sum, make(chan int)&#125;// Send requestclientRequests &lt;- request// Wait for response.fmt.Printf(\"answer: %d\\n\", &lt;-request.resultChan) On the server side, the handler function is the only thing that changes. 12345func handle(queue chan *Request) &#123; for req := range queue &#123; req.resultChan &lt;- req.f(req.args) &#125;&#125; There’s clearly a lot more to do to make it realistic, but this code is a framework for a rate-limited, parallel, non-blocking RPC system, and there’s not a mutex in sight. ParallelizationAnother application of these ideas is to parallelize a calculation across multiple CPU cores. If the calculation can be broken into separate pieces that can execute independently, it can be parallelized, with a channel to signal when each piece completes. Let’s say we have an expensive operation to perform on a vector of items, and that the value of the operation on each item is independent, as in this idealized example. 123456789type Vector []float64// Apply the operation to v[i], v[i+1] ... up to v[n-1].func (v Vector) DoSome(i, n int, u Vector, c chan int) &#123; for ; i &lt; n; i++ &#123; v[i] += u.Op(v[i]) &#125; c &lt;- 1 // signal that this piece is done&#125; We launch the pieces independently in a loop, one per CPU. They can complete in any order but it doesn’t matter; we just count the completion signals by draining the channel after launching all the goroutines. 12345678910111213const numCPU = 4 // number of CPU coresfunc (v Vector) DoAll(u Vector) &#123; c := make(chan int, numCPU) // Buffering optional but sensible. for i := 0; i &lt; numCPU; i++ &#123; go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c) &#125; // Drain the channel. for i := 0; i &lt; numCPU; i++ &#123; &lt;-c // wait for one task to complete &#125; // All done.&#125; Rather than create a constant value for numCPU, we can ask the runtime what value is appropriate. The function runtime.NumCPU returns the number of hardware CPU cores in the machine, so we could write 1var numCPU = runtime.NumCPU() There is also a function runtime.GOMAXPROCS , which reports (or sets) the user-specified number of cores that a Go program can have running simultaneously. It defaults to the value of runtime.NumCPU but can be overridden by setting the similarly named shell environment variable or by calling the function with a positive number. Calling it with zero just queries the value. Therefore if we want to honor the user’s resource request, we should write 1var numCPU = runtime.GOMAXPROCS(0) Be sure not to confuse the ideas of concurrency—structuring a program as independently executing components—and parallelism—executing calculations in parallel for efficiency on multiple CPUs. Although the concurrency features of Go can make some problems easy to structure as parallel computations, Go is a concurrent language, not a parallel one, and not all parallelization problems fit Go’s model. For a discussion of the distinction, see the talk cited inthis blog post. A leaky bufferThe tools of concurrent programming can even make non-concurrent ideas easier to express. Here’s an example abstracted from an RPC package. The client goroutine loops receiving data from some source, perhaps a network. To avoid allocating and freeing buffers, it keeps a free list, and uses a buffered channel to represent it. If the channel is empty, a new buffer gets allocated. Once the message buffer is ready, it’s sent to the server on serverChan . 123456789101112131415161718var freeList = make(chan *Buffer, 100)var serverChan = make(chan *Buffer)func client() &#123; for &#123; var b *Buffer // Grab a buffer if available; allocate if not. select &#123; case b = &lt;-freeList: // Got one; nothing more to do. default: // None free, so allocate a new one. b = new(Buffer) &#125; load(b) // Read next message from the net. serverChan &lt;- b // Send to server. &#125;&#125; The server loop receives each message from the client, processes it, and returns the buffer to the free list. 12345678910111213func server() &#123; for &#123; b := &lt;-serverChan // Wait for work. process(b) // Reuse buffer if there's room. select &#123; case freeList &lt;- b: // Buffer on free list; nothing more to do. default: // Free list full, just carry on. &#125; &#125;&#125; The client attempts to retrieve a buffer from freeList ; if none is available, it allocates a fresh one. The server’s send to freeList puts b back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The default clauses in the select statements execute when no other case is ready, meaning that the selects never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter12","slug":"effective-go chapter12","date":"2022-12-14T13:03:25.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"effective-go chapter12.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter12.html","excerpt":"","text":"EmbeddingGo does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by_embedding_types within a struct or interface. Interface embedding is very simple. We’ve mentioned theio.Readerandio.Writerinterfaces before; here are their definitions. 1234567type Reader interface &#123; Read(p []byte) (n int, err error)&#125;type Writer interface &#123; Write(p []byte) (n int, err error)&#125; Theiopackage also exports several other interfaces that specify objects that can implement several such methods. For instance, there isio.ReadWriter, an interface containing bothReadandWrite. We could specifyio.ReadWriterby listing the two methods explicitly, but it’s easier and more evocative to embed the two interfaces to form the new one, like this: 12345// ReadWriter is the interface that combines the Reader and Writer interfaces.type ReadWriter interface &#123; Reader Writer&#125; This says just what it looks like: AReadWritercan do what aReaderdoes_and_what aWriterdoes; it is a union of the embedded interfaces (which must be disjoint sets of methods). Only interfaces can be embedded within interfaces. The same basic idea applies to structs, but with more far-reaching implications. Thebufiopackage has two struct types,bufio.Readerandbufio.Writer, each of which of course implements the analogous interfaces from packageio. Andbufioalso implements a buffered reader&#x2F;writer, which it does by combining a reader and a writer into one struct using embedding: it lists the types within the struct but does not give them field names. 123456// ReadWriter stores pointers to a Reader and a Writer.// It implements io.ReadWriter.type ReadWriter struct &#123; *Reader // *bufio.Reader *Writer // *bufio.Writer&#125; The embedded elements are pointers to structs and of course must be initialized to point to valid structs before they can be used. TheReadWriterstruct could be written as 1234type ReadWriter struct &#123; reader *Reader writer *Writer&#125; but then to promote the methods of the fields and to satisfy theiointerfaces, we would also need to provide forwarding methods, like this: 123func (rw *ReadWriter) Read(p []byte) (n int, err error) &#123; return rw.reader.Read(p)&#125; By embedding the structs directly, we avoid this bookkeeping. The methods of embedded types come along for free, which means thatbufio.ReadWriternot only has the methods ofbufio.Readerandbufio.Writer, it also satisfies all three interfaces:io.Reader,io.Writer, andio.ReadWriter. There’s an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they are invoked the receiver of the method is the inner type, not the outer one. In our example, when theReadmethod of abufio.ReadWriteris invoked, it has exactly the same effect as the forwarding method written out above; the receiver is thereaderfield of theReadWriter, not theReadWriteritself. Embedding can also be a simple convenience. This example shows an embedded field alongside a regular, named field. 1234type Job struct &#123; Command string *log.Logger&#125; TheJobtype now has theLog,Logfand other methods of*log.Logger. We could have given theLoggera field name, of course, but it’s not necessary to do so. And now, once initialized, we can log to theJob: 1job.Log(\"starting now...\") TheLoggeris a regular field of theJobstruct, so we can initialize it in the usual way inside the constructor forJob, like this, 123func NewJob(command string, logger *log.Logger) *Job &#123; return &amp;Job&#123;command, logger&#125;&#125; or with a composite literal, 1job := &amp;Job&#123;command, log.New(os.Stderr, \"Job: \", log.Ldate)&#125; If we need to refer to an embedded field directly, the type name of the field, ignoring the package qualifier, serves as a field name, as it did in theReadmethod of ourReadWriterstruct. Here, if we needed to access the*log.Loggerof aJobvariablejob, we would writejob.Logger, which would be useful if we wanted to refine the methods ofLogger. 123func (job *Job) Logf(format string, args ...interface&#123;&#125;) &#123; job.Logger.Logf(\"%q: %s\", job.Command, fmt.Sprintf(format, args...))&#125; Embedding types introduces the problem of name conflicts but the rules to resolve them are simple. First, a field or methodXhides any other itemXin a more deeply nested part of the type. Iflog.Loggercontained a field or method calledCommand, theCommandfield ofJobwould dominate it. Second, if the same name appears at the same nesting level, it is usually an error; it would be erroneous to embedlog.Loggerif theJobstruct contained another field or method calledLogger. However, if the duplicate name is never mentioned in the program outside the type definition, it is OK. This qualification provides some protection against changes made to types embedded from outside; there is no problem if a field is added that conflicts with another field in another subtype if neither field is ever used.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter11","slug":"effective-go chapter11","date":"2022-12-14T13:03:22.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"effective-go chapter11.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter11.html","excerpt":"","text":"The blank identifierWe’ve mentioned the blank identifier a couple of times now, in the context offorrangeloopsandmaps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It’s a bit like writing to the Unix/dev/nullfile: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we’ve seen already. The blank identifier in multiple assignmentThe use of a blank identifier in aforrangeloop is a special case of a general situation: multiple assignment. If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value. 123if _, err := os.Stat(path); os.IsNotExist(err) &#123;truefmt.Printf(\"%s does not exist\\n\", path)&#125; Occasionally you’ll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they’re provided for a reason. 12345// Bad! This code will crash if path does not exist.fi, _ := os.Stat(path)if fi.IsDir() &#123; fmt.Printf(\"%s is a directory\\n\", path)&#125; Unused imports and variablesIt is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround. This half-written program has two unused imports (fmtandio) and an unused variable (fd), so it will not compile, but it would be nice to see if the code so far is correct. 123456789101112131415161718package mainimport ( \"fmt\" \"io\" \"log\" \"os\")func main() &#123; fd, err := os.Open(\"test.go\") if err != nil &#123; log.Fatal(err) &#125; // TODO: use fd.&#125; To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variablefdto the blank identifier will silence the unused variable error. This version of the program does compile. 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"io\" \"log\" \"os\")var _ = fmt.Printf // For debugging; delete when done.var _ io.Reader // For debugging; delete when done.func main() &#123; fd, err := os.Open(\"test.go\") if err != nil &#123; log.Fatal(err) &#125; // TODO: use fd. _ = fd&#125; By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later. Import for side effectAn unused import likefmtorioin the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during itsinitfunction, thenet/http/pprofpackage registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier: 1import _ \"net/http/pprof\" This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn’t have a name. (If it did, and we didn’t use that name, the compiler would reject the program.) Interface checksAs we saw in the discussion ofinterfacesabove, a type need not declare explicitly that it implements an interface. Instead, a type implements the interface just by implementing the interface’s methods. In practice, most interface conversions are static and therefore checked at compile time. For example, passing an*os.Fileto a function expecting anio.Readerwill not compile unless*os.Fileimplements theio.Readerinterface. Some interface checks do happen at run-time, though. One instance is in theencoding/jsonpackage, which defines aMarshalerinterface. When the JSON encoder receives a value that implements that interface, the encoder invokes the value’s marshaling method to convert it to JSON instead of doing the standard conversion. The encoder checks this property at run time with atype assertionlike: 1m, ok := val.(json.Marshaler) If it’s necessary only to ask whether a type implements an interface, without actually using the interface itself, perhaps as part of an error check, use the blank identifier to ignore the type-asserted value: 123if _, ok := val.(json.Marshaler); ok &#123; fmt.Printf(\"value %v of type %T implements json.Marshaler\\n\", val, val)&#125; One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type—for example,json.RawMessage—needs a custom JSON representation, it should implementjson.Marshaler, but there are no static conversions that would cause the compiler to verify this automatically. If the type inadvertently fails to satisfy the interface, the JSON encoder will still work, but will not use the custom implementation. To guarantee that the implementation is correct, a global declaration using the blank identifier can be used in the package: 1var _ json.Marshaler = (*RawMessage)(nil) In this declaration, the assignment involving a conversion of a*RawMessageto aMarshalerrequires that*RawMessageimplementsMarshaler, and that property will be checked at compile time. Should thejson.Marshalerinterface change, this package will no longer compile and we will be on notice that it needs to be updated. The appearance of the blank identifier in this construct indicates that the declaration exists only for the type checking, not to create a variable. Don’t do this for every type that satisfies an interface, though. By convention, such declarations are only used when there are no static conversions already present in the code, which is a rare event.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter10","slug":"effective-go chapter10","date":"2022-12-14T13:03:19.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"effective-go chapter10.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter10.html","excerpt":"","text":"Interfaces and other types &#124; 接口与其他类型Interfaces &#124; 接口Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here. We’ve seen a couple of simple examples already; custom printers can be implemented by a String method while Fprintf can generate output to anything with a Write method. Interfaces with only one or two methods are common in Go code, and are usually given a name derived from the method, such as io.Writer for something that implements Write. Go 中的接口提供了一种指定对象行为的方法：如果有东西可以做到这一点，那么它就可以在这里使用。我们已经看过几个简单的例子；自定义打印函数可以通过 String 方法实现，而 Fprintf 可以使用 Write 方法生成任何输出。只有一两个方法的接口在 Go 代码中很常见，并且通常被赋予从方法派生的名称，例如 io.Writer 表示实现了 Write 的一类对象。 A type can implement multiple interfaces. For instance, a collection can be sorted by the routines in package sort if it implements sort.Interface , which contains Len() , Less(i, j int) bool , and Swap(i, j int) , and it could also have a custom formatter. In this contrived example Sequence satisfies both. 一个类型可以实现多个接口。例如，如果集合实现了 sort.Interface 接口，就可以通过 sort 包中的例程对其进行排序，接口包含Len()、Less(i, j int) bool 和 Swap(i, j int) ，它也可以有一个自定义的格式化程序。 一个类型可以实现多个接口。例如，如果集合实现了 sort.Interface 包，则可以通过 sort 包中的例程对集合进行排序，其中包含 Len()、Less(i, j int) bool 和 Swap(i, j int) ，它也可以有一个自定义的格式化程序。以下构造的例子中，Sequence 满足两种情况。 12345678910111213141516171819202122232425type Sequence []int// Methods required by sort.Interface.func (s Sequence) Len() int &#123; return len(s)&#125;func (s Sequence) Less(i, j int) bool &#123; return s[i] &lt; s[j]&#125;func (s Sequence) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i]&#125;// Method for printing - sorts the elements before printing.func (s Sequence) String() string &#123; sort.Sort(s) str := \"[\" for i, elem := range s &#123; if i &gt; 0 &#123; str += \" \" &#125; str += fmt.Sprint(elem) &#125; return str + \"]\"&#125; Conversions &#124; 转换The String method of Sequence is recreating the work that Sprint already does for slices. We can share the effort if we convert the Sequence to a plain []int before calling Sprint . Sequence 的 String方法重新实现了 Sprint为切片实现的功能。如果我们在调用Sprint前把 Sequence 转为纯粹的 []int，就可以共享之前的功能。 1234func (s Sequence) String() string &#123; sort.Sort(s) return fmt.Sprint([]int(s))&#125; This method is another example of the conversion technique for calling Sprintf safely from a String method. Because the two types ( Sequence and []int ) are the same if we ignore the type name, it’s legal to convert between them. The conversion doesn’t create a new value, it just temporarily acts as though the existing value has a new type. (There are other legal conversions, such as from integer to floating point, that do create a new value.) 该方法是转换技术的另一个例子，在 String 方法中安全地调用Sprintf 。如果我们忽略类型名的话，其实这两种类型（ Sequence and []int）是相同的，因此它们之间是可以相互转换的。转换并不会创建新的值，它只是暂时让现在的值看起来有一个新类型而已。（也有一些会创建新值的合法转换，如从整数转为浮点数。） It’s an idiom in Go programs to convert the type of an expression to access a different set of methods. As an example, we could use the existing type sort.IntSlice to reduce the entire example to this: 在Go语言中，访问不同方法集时进行类型转换是一种习惯用法。例如，我们可以用现有类型 sort.IntSlice 来简化整个例子。 1234567type Sequence []int// Method for printing - sorts the elements before printingfunc (s Sequence) String() string &#123; sort.IntSlice(s).Sort() return fmt.Sprint([]int(s))&#125; Now, instead of having Sequence implement multiple interfaces (sorting and printing), we’re using the ability of a data item to be converted to multiple types ( Sequence , sort.IntSlice and []int ), each of which does some part of the job. That’s more unusual in practice but can be effective. 现在，不必为Sequence 实现多个接口（sorting and printing），我们可以通过将数据项转换为多种类型（Sequence , sort.IntSlice and []int），每个完成其一部分工作。在实践中虽不多见，却往往很高效。 Interface conversions and type assertions &#124; 接口转换和类型断言Type switches are a form of conversion: they take an interface and, for each case in the switch, in a sense convert it to the type of that case. Here’s a simplified version of how the code under fmt.Printf turns a value into a string using a type switch. If it’s already a string, we want the actual string value held by the interface, while if it has a String method we want the result of calling the method. 类型选择是一种转换形式，他们接收一个接口，在选择语句中转换为条件对应的类型。以下是fmt.Printf的简化代码，它使用类型转换将值转换成一个字符串。如果它已经是一个字符串，我们需要接口中的实际字符串值，而如果它有一个String方法，我们需要调用该方法的结果。 1234567891011type Stringer interface &#123; String() string&#125;var value interface&#123;&#125; // Value provided by caller.switch str := value.(type) &#123;case string: return strcase Stringer: return str.String()&#125; The first case finds a concrete value; the second converts the interface into another interface. It’s perfectly fine to mix types this way. 第一种情况是获取具体值；第二种则转换为一个新接口。对于混合类型这种方式非常好。 What if there’s only one type we care about? If we know the value holds a string and we just want to extract it? A one-case type switch would do, but so would a_type assertion_. A type assertion takes an interface value and extracts from it a value of the specified explicit type. The syntax borrows from the clause opening a type switch, but with an explicit type rather than the type keyword: 如果我们只关心一种类型呢？如果我们知道它的值是个字符串，而我们只想提取它呢？一个 case 的 switch 可以实现，类型断言也可以。类型断言采用接口值并从中提取指定显式类型的值。该语法借鉴了一个 case 的 switch 子句，但使用了显式类型而不是type关键字： 1value.(typeName) and the result is a new value with the static type typeName . That type must either be the concrete type held by the interface, or a second interface type that the value can be converted to. To extract the string we know is in the value, we could write: 结果是一个静态类型为 typeName 的新值。该类型必须是接口持有的具体类型，或者是值可以转换的第二种接口类型。要提取其中的字符串，我们可以这样写： 1str := value.(string) But if it turns out that the value does not contain a string, the program will crash with a run-time error. To guard against that, use the “comma, ok” idiom to test, safely, whether the value is a string: 如果事实上值中不包含字符串，程序就会崩溃并报运行时错误。为防止这种情况，使用”逗号, ok”习语来安全地测试值是否为字符串： 123456str, ok := value.(string)if ok &#123; fmt.Printf(\"string value is: %q\\n\", str)&#125; else &#123; fmt.Printf(\"value is not a string\\n\")&#125; If the type assertion fails, str will still exist and be of type string, but it will have the zero value, an empty string. 如果类型断言失败了， str 仍然存在并且是一个字符串类开，但它将是零值，一个空字符串。 As an illustration of the capability, here’s an if - else statement that’s equivalent to the type switch that opened this section. 为了说明这个功能，来看下这个if-else语句，它等同于前面的swith 12345if str, ok := value.(string); ok &#123; return str&#125; else if str, ok := value.(Stringer); ok &#123; return str.String()&#125; Generality &#124; If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. In such cases, the constructor should return an interface value rather than the implementing type. As an example, in the hash libraries both crc32.NewIEEE and adler32.New return the interface type hash.Hash32 . Substituting the CRC-32 algorithm for Adler-32 in a Go program requires only changing the constructor call; the rest of the code is unaffected by the change of algorithm. A similar approach allows the streaming cipher algorithms in the various crypto packages to be separated from the block ciphers they chain together. The Block interface in the crypto/cipher package specifies the behavior of a block cipher, which provides encryption of a single block of data. Then, by analogy with the bufio package, cipher packages that implement this interface can be used to construct streaming ciphers, represented by the Stream interface, without knowing the details of the block encryption. The crypto/cipher interfaces look like this: 123456789type Block interface &#123; BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte)&#125;type Stream interface &#123; XORKeyStream(dst, src []byte)&#125; Here’s the definition of the counter mode (CTR) stream, which turns a block cipher into a streaming cipher; notice that the block cipher’s details are abstracted away: 123// NewCTR returns a Stream that encrypts/decrypts using the given Block in// counter mode. The length of iv must be the same as the Block's block size.func NewCTR(block Block, iv []byte) Stream NewCTR applies not just to one specific encryption algorithm and data source but to any implementation of the Block interface and any Stream . Because they return interface values, replacing CTR encryption with other encryption modes is a localized change. The constructor calls must be edited, but because the surrounding code must treat the result only as a Stream , it won’t notice the difference. Interfaces and methods &#124; Since almost anything can have methods attached, almost anything can satisfy an interface. One illustrative example is in the http package, which defines the Handler interface. Any object that implements Handler can serve HTTP requests. 123type Handler interface &#123; ServeHTTP(ResponseWriter, *Request)&#125; ResponseWriter is itself an interface that provides access to the methods needed to return the response to the client. Those methods include the standard Write method, so an http.ResponseWriter can be used wherever an io.Writer can be used. Request is a struct containing a parsed representation of the request from the client. For brevity, let’s ignore POSTs and assume HTTP requests are always GETs; that simplification does not affect the way the handlers are set up. Here’s a trivial but complete implementation of a handler to count the number of times the page is visited. 123456789// Simple counter server.type Counter struct &#123; n int&#125;func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; ctr.n++ fmt.Fprintf(w, \"counter = %d\\n\", ctr.n)&#125; (Keeping with our theme, note how Fprintf can print to an http.ResponseWriter .) For reference, here’s how to attach such a server to a node on the URL tree. 1234import \"net/http\"...ctr := new(Counter)http.Handle(\"/counter\", ctr) But why make Counter a struct? An integer is all that’s needed. (The receiver needs to be a pointer so the increment is visible to the caller.) 1234567// Simpler counter server.type Counter intfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr)&#125; What if your program has some internal state that needs to be notified that a page has been visited? Tie a channel to the web page. 12345678// A channel that sends a notification on each visit.// (Probably want the channel to be buffered.)type Chan chan *http.Requestfunc (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; ch &lt;- req fmt.Fprint(w, \"notification sent\")&#125; Finally, let’s say we wanted to present on /args the arguments used when invoking the server binary. It’s easy to write a function to print the arguments. 123func ArgServer() &#123; fmt.Println(os.Args)&#125; How do we turn that into an HTTP server? We could make ArgServer a method of some type whose value we ignore, but there’s a cleaner way. Since we can define a method for any type except pointers and interfaces, we can write a method for a function. The http package contains this code: 12345678910// The HandlerFunc type is an adapter to allow the use of// ordinary functions as HTTP handlers. If f is a function// with the appropriate signature, HandlerFunc(f) is a// Handler object that calls f.type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, req).func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) &#123; f(w, req)&#125; HandlerFunc is a type with a method, ServeHTTP , so values of that type can serve HTTP requests. Look at the implementation of the method: the receiver is a function, f , and the method calls f . That may seem odd but it’s not that different from, say, the receiver being a channel and the method sending on the channel. To make ArgServer into an HTTP server, we first modify it to have the right signature. 1234// Argument server.func ArgServer(w http.ResponseWriter, req *http.Request) &#123; fmt.Fprintln(w, os.Args)&#125; ArgServer now has same signature as HandlerFunc , so it can be converted to that type to access its methods, just as we converted Sequence to IntSlice to access IntSlice.Sort . The code to set it up is concise: 1http.Handle(\"/args\", http.HandlerFunc(ArgServer)) When someone visits the page /args , the handler installed at that page has value ArgServer and type HandlerFunc . The HTTP server will invoke the method ServeHTTP of that type, with ArgServer as the receiver, which will in turn call ArgServer (via the invocation f(w, req) inside HandlerFunc.ServeHTTP ). The arguments will then be displayed. In this section we have made an HTTP server from a struct, an integer, a channel, and a function, all because interfaces are just sets of methods, which can be defined for (almost) any type.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter9","slug":"effective-go chapter9","date":"2022-12-14T13:03:15.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter9.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter9.html","excerpt":"","text":"Methods&#124; 方法Pointers vs. Values&#124; 指针与值As we saw with ByteSize , methods can be defined for any named type (except a pointer or an interface); the receiver does not have to be a struct. 正如我们在 ByteSize 中看到的，可以为任何命名类型（除了指针或接口）定义方法；接收者不必是一个结构体。 In the discussion of slices above, we wrote an Append function. We can define it as a method on slices instead. To do this, we first declare a named type to which we can bind the method, and then make the receiver for the method a value of that type. 在上面对切片的讨论中，我们编写了一个 Append 函数。我们可以将其定义为切片上的方法。为此，我们首先声明一个可以将方法绑定到的命名类型，然后将方法的接收者设为该类型的值。 12345type ByteSlice []bytefunc (slice ByteSlice) Append(data []byte) []byte &#123; // Body exactly the same as the Append function defined above.&#125; This still requires the method to return the updated slice. We can eliminate that clumsiness by redefining the method to take apointerto a ByteSlice as its receiver, so the method can overwrite the caller’s slice. 这仍然需要方法返回更新后的切片。我们可以通过重新定义方法以将指向 ByteSlice 的指针作为其接收者来消除这种笨拙，因此该方法可以覆盖调用者的切片。 12345func (p *ByteSlice) Append(data []byte) &#123; slice := *p // Body as above, without the return. *p = slice&#125; In fact, we can do even better. If we modify our function so it looks like a standard Write method, like this, 事实上，我们可以做得更好。如果我们修改我们的函数，使它看起来像一个标准的 Write 方法，像这样， 123456func (p *ByteSlice) Write(data []byte) (n int, err error) &#123; slice := *p // Again as above. *p = slice return len(data), nil&#125; then the type *ByteSlice satisfies the standard interface io.Writer , which is handy. For instance, we can print into one. 那么 *ByteSlice 类型满足标准接口 io.Writer ，这就很方便了。例如，我们可以打印成一个。 12var b ByteSlicefmt.Fprintf(&amp;b, \"This hour has %d days\\n\", 7) We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer . The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers. 我们传递 ByteSlice 的地址，因为只有 *ByteSlice 满足 io.Writer 。接收者是指针与值的规则是：值方法可以在指针和值上调用，但指针方法只能在指针上调用。 This rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write . The compiler will rewrite that to (&amp;b).Write for us. 出现这个规则是因为指针方法可以修改接收者；在一个值上调用它们会导致该方法接收的是该值的副本，因此任何修改都将被丢弃。因此，该语言不允许这种错误。不过，有一个方便的例外。当值是可寻址的时，该语言通过自动插入地址运算符来处理对值调用指针方法的常见情况。在我们的示例中，变量 b 是可寻址的，因此我们可以仅使用 b.Write 调用它的 Write 方法。编译器将为我们将其重写为 (&amp;b).Write 。 By the way, the idea of using Write on a slice of bytes is central to the implementation of bytes.Buffer . 顺便说一句，在 bytes 切片上使用 Write 的想法是 bytes.Buffer 实现的核心。","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter8","slug":"effective-go chapter8","date":"2022-12-14T13:03:12.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter8.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter8.html","excerpt":"","text":"Initialization&#124; 初始化Although it doesn’t look superficially very different from initialization in C or C++, initialization in Go is more powerful. Complex structures can be built during initialization and the ordering issues among initialized objects, even among different packages, are handled correctly. 虽然从表面上看起来，它与 C 或 C++ 的初始化没有太大的区别，但是 Go 的初始化更加强大。复杂的结构体可以在初始化期间构建，初始化对象之间的顺序问题，甚至不同包之间的顺序问题，都能得到正确的处理。 Constants&#124; 常量Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1&lt;&lt;3 is a constant expression, while math.Sin(math.Pi/4) is not because the function call to math.Sin needs to happen at run time. Go 中的常量就是常数。它们是在编译时创建的，即使在函数中定义的局部变量，也只能是数字、字符（runes）、字符串或布尔值。由于编译时的限制，定义它们的表达式必须是可由编译器计算的常量表达式。例如， 1&lt;&lt;3 是一个常量表达式，而 math.Sin(math.Pi/4) 不是，因为对 math.Sin 的函数调用需要在运行时发生。 In Go, enumerated constants are created using the iota enumerator. Since iota can be part of an expression and expressions can be implicitly repeated, it is easy to build intricate sets of values. 在 Go 中，枚举常量是使用 iota 枚举器创建的。 由于 iota 可以是表达式的一部分，并且表达式可以隐式重复，因此很容易构建复杂的值集。 12345678910111213type ByteSize float64const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 &lt;&lt; (10 * iota) MB GB TB PB EB ZB YB) The ability to attach a method such as String to any user-defined type makes it possible for arbitrary values to format themselves automatically for printing. Although you’ll see it most often applied to structs, this technique is also useful for scalar types such as floating-point types like ByteSize . 将诸如 String 之类的方法附加到任何用户定义的类型的能力，使得任意值可以自动格式化以进行打印。 尽管您会看到它最常应用于结构体，但这种技术也适用于标量类型，例如 ByteSize 之类的浮点类型。 123456789101112131415161718192021func (b ByteSize) String() string &#123; switch &#123; case b &gt;= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b &gt;= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b &gt;= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b &gt;= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b &gt;= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b &gt;= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b &gt;= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b &gt;= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) &#125; return fmt.Sprintf(\"%.2fB\", b)&#125; The expression YB prints as 1.00YB , while ByteSize(1e13) prints as 9.09TB . 表达式 YB 打印为 1.00YB ，而 ByteSize(1e13) 打印为 9.09TB 。 The use here of Sprintf to implement ByteSize ‘s String method is safe (avoids recurring indefinitely) not because of a conversion but because it calls Sprintf with %f , which is not a string format: Sprintf will only call the String method when it wants a string, and %f wants a floating-point value. 在这里使用 Sprintf 来实现 ByteSize 的 String 方法是安全的（避免无限重复），不是因为转换，而是因为它使用 %f 调用 Sprintf ，它不是字符串格式： Sprintf 只会在需要字符串时调用 String 方法，而 %f 需要浮点值。 Variables&#124; 变量Variables can be initialized just like constants but the initializer can be a general expression computed at run time. 变量可以像常量一样被初始化，但初始化器可以是在运行时计算的通用表达式。 12345var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\")) The init function&#124; init 方法Finally, each source file can define its own niladic init function to set up whatever state is required. (Actually each file can have multiple init functions.) And finally means finally: init is called after all the variable declarations in the package have evaluated their initializers, and those are evaluated only after all the imported packages have been initialized. 最后，每个源文件都可以定义自己的无参数 init 函数来设置所需的任何状态。（实际上每个文件可以有多个 init 函数。）finally 的意思是： init 在包中的所有变量声明都评估了它们的初始值设定项之后被调用，并且只有在所有导入的包都被评估后才被评估初始化。 Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before real execution begins. 除了不能表示为声明的初始化之外， init 函数的一个常见用途是在实际执行开始之前验证或修复程序状态的正确性。 12345678910111213func init() &#123; if user == \"\" &#123; log.Fatal(\"$USER not set\") &#125; if home == \"\" &#123; home = \"/home/\" + user &#125; if gopath == \"\" &#123; gopath = home + \"/go\" &#125; // gopath may be overridden by --gopath flag on command line. flag.StringVar(&amp;gopath, \"gopath\", gopath, \"override default GOPATH\")&#125;","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter7","slug":"effective-go chapter7","date":"2022-12-14T13:03:07.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter7.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter7.html","excerpt":"","text":"数据（Data）使用 new 分配 （Allocation with new ）Go 有两个分配原语。内置函数 new 和 make 。它们会干不同的事情，分配不同的类型，虽然有点迷惑人，但区分规则很简单。我们先来说 new 。它是一个内置的分配内存的函数，但它在其他语言中的同名兄弟，它不会初始化内存，仅仅是初始为零值。也就是说， new(T) 分配了一个类型为T的条目，并且被初始化为零值的存储空间，并返回它的地址，类型为 *T 。在Go的术语中，它返回了一个指针，指向类型为 T 的新分配的零值。 Go has two allocation primitives, the built-in functions new and make. They do different things and apply to different types, which can be confusing, but the rules are simple. Let’s talk about new first. It’s a built-in function that allocates memory, but unlike its namesakes in some other languages it does not initialize the memory, it only zeros it. That is, new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. In Go terminology, it returns a pointer to a newly allocated zero value of type T. 由于 new 返回的内存是零值，这会有助于设计你的数据结构，每个类型的零值都可以直接使用，无需额外初始化操作。这意味着，结构体的使用者可以直接使用 new 创建，并可以直接使用。例如， bytes.Bufer 的文档中说 Buffer 的零值是一个空的待用的缓存。类似的， sync.Mutex 没有显式构造或者初始化方法。相反的， sync.Mutex 的零值被定义为一个未加锁的互斥量。 Since the memory returned by new is zeroed, it’s helpful to arrange when designing your data structures that the zero value of each type can be used without further initialization. This means a user of the data structure can create one with new and get right to work. For example, the documentation for bytes.Buffer states that “the zero value for Buffer is an empty buffer ready to use.” Similarly, sync.Mutex does not have an explicit constructor or Init method. Instead, the zero value for a sync.Mutex is defined to be an unlocked mutex. 零值的属性是可以传递的，请看如下类型声明： The zero-value-is-useful property works transitively. Consider this type declaration. 1234type SyncedBuffer struct &#123; lock sync.Mutex buffer bytes.Buffer&#125; SyncedBuffer 类型的值也可以在分配或者声明时立即使用。在下一个片段， p 和 v 无需进一步的处理即可正常使用。 Values of type SyncedBuffer are also ready to use immediately upon allocation or just declaration. In the next snippet, both p and v will work correctly without further arrangement. 12p := new(SyncedBuffer) // type *SyncedBuffervar v SyncedBuffer // type SyncedBuffer 构造函数和复合文字有时候，零值并不是很好，这时一个初始化构造函数就很有必要了，就如同这个从 os 包中提取的例子。 Sometimes the zero value isn’t good enough and an initializing constructor is necessary, as in this example derived from package os. 12345678910func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f&#125; 这里有很多的示例。我们可以使用复合文字简化它，即，使用一个表达式创建一个新实例。 There’s a lot of boiler plate in there. We can simplify it using a composite literal, which is an expression that creates a new instance each time it is evaluated. 1234567func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil &#125; f := File&#123;fd, name, nil, 0&#125; return &amp;f&#125; 注意，与 C 不同，在 Go 中返回局部变量的地址是完全没问题的，与变量相关的存储在函数返回后不会释放。事实上，获取复合文字的地址时，每个新的实例有一个地址，因此我们可以把最后两行合并起来。 Note that, unlike in C, it’s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. 1return &amp;File&#123;fd, name, nil, 0&#125; 复合文字的字段按序列出，并且所有字段都要使用到。然而，通过显式的成对列出字段名：字段值，就可以以任意次序初始化了（不再受次序限制），没列出的将会被设置为各自的零值。因此，可以写成这样： The fields of a composite literal are laid out in order and must all be present. However, by labeling the elements explicitly as field : value pairs, the initializers can appear in any order, with the missing ones left as their respective zero values. Thus we could say 1return &amp;File&#123;fd: fd, name: name&#125; 一个极端的情况，若复合文字中不包含任何字段，它会创建为这个类型的零值。表达式 new(File)和&amp;File{} 是等值的。 复合文字也可以用来创建arrays，slices 和 maps，字段标号使用索引或 map key。再这些例子中，不论 Enone 、 Eio 和 Einval 的取值如何，只要不同即可初始化。 As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and &amp;File{} are equivalent. Composite literals can also be created for arrays, slices, and maps, with the field labels being indices or map keys as appropriate. In these examples, the initializations work regardless of the values of Enone , Eio , and Einval , as long as they are distinct. 123a := [...]string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;s := []string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;m := map[int]string&#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125; 用make分配说到（资源）分配。内置函数 make(T, args) 与 new(T) 的作用略有不同。 make 仅用来创建 slices, maps, and channels Back to allocation. The built-in function make(T,args) serves a purpose different from new(T) . It creates slices, maps, and channels only, and it returns an initialized (not zeroed) value of type T (not *T ). The reason for the distinction is that these three types represent, under the covers, references to data structures that must be initialized before use. A slice, for example, is a three-item descriptor containing a pointer to the data (inside an array), the length, and the capacity, and until those items are initialized, the slice is nil . For slices, maps, and channels, make initializes the internal data structure and prepares the value for use. For instance, 1make([]int, 10, 100) allocates an array of 100 ints and then creates a slice structure with length 10 and a capacity of 100 pointing at the first 10 elements of the array. (When making a slice, the capacity can be omitted; see the section on slices for more information.) In contrast, new([]int) returns a pointer to a newly allocated, zeroed slice structure, that is, a pointer to a nil slice value. These examples illustrate the difference between new and make . 123456789var p *[]int = new([]int) // allocates slice structure; *p == nil; rarely usefulvar v []int = make([]int, 100) // the slice v now refers to a new array of 100 ints// Unnecessarily complex:var p *[]int = new([]int)*p = make([]int, 100, 100)// Idiomatic:v := make([]int, 100) Remember that make applies only to maps, slices and channels and does not return a pointer. To obtain an explicit pointer allocate with new or take the address of a variable explicitly. ArraysArrays are useful when planning the detailed layout of memory and sometimes can help avoid allocation, but primarily they are a building block for slices, the subject of the next section. To lay the foundation for that topic, here are a few words about arrays. There are major differences between the ways arrays work in Go and C. In Go, Arrays are values. Assigning one array to another copies all the elements. In particular, if you pass an array to a function, it will receive a copy of the array, not a pointer to it. The size of an array is part of its type. The types[10]intand[20]intare distinct. The value property can be useful but also expensive; if you want C-like behavior and efficiency, you can pass a pointer to the array. 123456789func Sum(a *[3]float64) (sum float64) &#123; for _, v := range *a &#123; sum += v &#125; return&#125;array := [...]float64&#123;7.0, 8.5, 9.1&#125;x := Sum(&amp;array) // Note the explicit address-of operator But even this style isn’t idiomatic Go. Use slices instead. SlicesSlices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. Except for items with explicit dimension such as transformation matrices, most array programming in Go is done with slices rather than simple arrays. Slices hold references to an underlying array, and if you assign one slice to another, both refer to the same array. If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller, analogous to passing a pointer to the underlying array. A Read function can therefore accept a slice argument rather than a pointer and a count; the length within the slice sets an upper limit of how much data to read. Here is the signature of the Read method of the File type in package os : 1func (f *File) Read(buf []byte) (n int, err error) The method returns the number of bytes read and an error value, if any. To read into the first 32 bytes of a larger buffer buf , slice(here used as a verb) the buffer. 1n, err := f.Read(buf[0:32]) Such slicing is common and efficient. In fact, leaving efficiency aside for the moment, the following snippet would also read the first 32 bytes of the buffer. 12345678910var n intvar err errorfor i := 0; i &lt; 32; i++ &#123; nbytes, e := f.Read(buf[i:i+1]) // Read one byte. if nbytes == 0 || e != nil &#123; err = e break &#125; n += nbytes&#125; The length of a slice may be changed as long as it still fits within the limits of the underlying array; just assign it to a slice of itself. Thecapacityof a slice, accessible by the built-in function cap , reports the maximum length the slice may assume. Here is a function to append data to a slice. If the data exceeds the capacity, the slice is reallocated. The resulting slice is returned. The function uses the fact that len and cap are legal when applied to the nil slice, and return 0. 12345678910111213func Append(slice, data []byte) []byte &#123; l := len(slice) if l + len(data) &gt; cap(slice) &#123; // reallocate // Allocate double what's needed, for future growth. newSlice := make([]byte, (l+len(data))*2) // The copy function is predeclared and works for any slice type. copy(newSlice, slice) slice = newSlice &#125; slice = slice[0:l+len(data)] copy(slice[l:], data) return slice&#125; We must return the slice afterwards because, although Append can modify the elements of slice , the slice itself (the run-time data structure holding the pointer, length, and capacity) is passed by value. The idea of appending to a slice is so useful it’s captured by the append built-in function. To understand that function’s design, though, we need a little more information, so we’ll return to it later. Two-dimensional slicesGo’s arrays and slices are one-dimensional. To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays or slice-of-slices, like this: 12type Transform [3][3]float64 // A 3x3 array, really an array of arrays.type LinesOfText [][]byte // A slice of byte slices. Because slices are variable-length, it is possible to have each inner slice be a different length. That can be a common situation, as in our LinesOfText example: each line has an independent length. 12345text := LinesOfText&#123; []byte(\"Now is the time\"), []byte(\"for all good gophers\"), []byte(\"to bring some fun to the party.\"),&#125; Sometimes it’s necessary to allocate a 2D slice, a situation that can arise when processing scan lines of pixels, for instance. There are two ways to achieve this. One is to allocate each slice independently; the other is to allocate a single array and point the individual slices into it. Which to use depends on your application. If the slices might grow or shrink, they should be allocated independently to avoid overwriting the next line; if not, it can be more efficient to construct the object with a single allocation. For reference, here are sketches of the two methods. First, a line at a time: 123456// Allocate the top-level slice.picture := make([][]uint8, YSize) // One row per unit of y.// Loop over the rows, allocating the slice for each row.for i := range picture &#123; picture[i] = make([]uint8, XSize)&#125; And now as one allocation, sliced into lines: 12345678// Allocate the top-level slice, the same as before.picture := make([][]uint8, YSize) // One row per unit of y.// Allocate one large slice to hold all the pixels.pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.// Loop over the rows, slicing each row from the front of the remaining pixels slice.for i := range picture &#123; picture[i], pixels = pixels[:XSize], pixels[XSize:]&#125; MapsMaps are a convenient and powerful built-in data structure that associate values of one type (the_key_) with values of another type (the_element_or_value_). The key can be of any type for which the equality operator is defined, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. Slices cannot be used as map keys, because equality is not defined on them. Like slices, maps hold references to an underlying data structure. If you pass a map to a function that changes the contents of the map, the changes will be visible in the caller. Maps can be constructed using the usual composite literal syntax with colon-separated key-value pairs, so it’s easy to build them during initialization. 1234567var timeZone = map[string]int&#123; \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60,&#125; Assigning and fetching map values looks syntactically just like doing the same for arrays and slices except that the index doesn’t need to be an integer. 1offset := timeZone[\"EST\"] An attempt to fetch a map value with a key that is not present in the map will return the zero value for the type of the entries in the map. For instance, if the map contains integers, looking up a non-existent key will return 0 . A set can be implemented as a map with value type bool . Set the map entry to true to put the value in the set, and then test it by simple indexing. 123456789attended := map[string]bool&#123; \"Ann\": true, \"Joe\": true, ...&#125;if attended[person] &#123; // will be false if person is not in the map fmt.Println(person, \"was at the meeting\")&#125; Sometimes you need to distinguish a missing entry from a zero value. Is there an entry for &quot;UTC&quot; or is that 0 because it’s not in the map at all? You can discriminate with a form of multiple assignment. 123var seconds intvar ok boolseconds, ok = timeZone[tz] For obvious reasons this is called the “comma ok” idiom. In this example, if tz is present, seconds will be set appropriately and ok will be true; if not, seconds will be set to zero and ok will be false. Here’s a function that puts it together with a nice error report: 1234567func offset(tz string) int &#123; if seconds, ok := timeZone[tz]; ok &#123; return seconds &#125; log.Println(\"unknown time zone:\", tz) return 0&#125; To test for presence in the map without worrying about the actual value, you can use theblank identifier( _ ) in place of the usual variable for the value. 1_, present := timeZone[tz] To delete a map entry, use the delete built-in function, whose arguments are the map and the key to be deleted. It’s safe to do this even if the key is already absent from the map. 1delete(timeZone, \"PDT\") // Now on Standard Time PrintingFormatted printing in Go uses a style similar to C’s printf family but is richer and more general. The functions live in the fmt package and have capitalized names: fmt.Printf , fmt.Fprintf , fmt.Sprintf and so on. The string functions ( Sprintf etc.) return a string rather than filling in a provided buffer. You don’t need to provide a format string. For each of Printf , Fprintf and Sprintf there is another pair of functions, for instance Print and Println . These functions do not take a format string but instead generate a default format for each argument. The Println versions also insert a blank between arguments and append a newline to the output while the Print versions add blanks only if the operand on neither side is a string. In this example each line produces the same output. 1234fmt.Printf(\"Hello %d\\n\", 23)fmt.Fprint(os.Stdout, \"Hello \", 23, \"\\n\")fmt.Println(\"Hello\", 23)fmt.Println(fmt.Sprint(\"Hello \", 23)) The formatted print functions fmt.Fprint and friends take as a first argument any object that implements the io.Writer interface; the variables os.Stdout and os.Stderr are familiar instances. Here things start to diverge from C. First, the numeric formats such as %d do not take flags for signedness or size; instead, the printing routines use the type of the argument to decide these properties. 12var x uint64 = 1&lt;&lt;64 - 1fmt.Printf(\"%d %x; %d %x\\n\", x, x, int64(x), int64(x)) prints 118446744073709551615 ffffffffffffffff; -1 -1 If you just want the default conversion, such as decimal for integers, you can use the catchall format %v (for “value”); the result is exactly what Print and Println would produce. Moreover, that format can print_any_value, even arrays, slices, structs, and maps. Here is a print statement for the time zone map defined in the previous section. 1fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) which gives output 1map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200] For maps the keys may be output in any order, of course. When printing a struct, the modified format %+v annotates the fields of the structure with their names, and for any value the alternate format %#v prints the value in full Go syntax. 12345678910type T struct &#123; a int b float64 c string&#125;t := &amp;T&#123; 7, -2.35, \"abc\\tdef\" &#125;fmt.Printf(\"%v\\n\", t)fmt.Printf(\"%+v\\n\", t)fmt.Printf(\"%#v\\n\", t)fmt.Printf(\"%#v\\n\", timeZone) prints 1234&amp;&#123;7 -2.35 abc def&#125;&amp;&#123;a:7 b:-2.35 c:abc def&#125;&amp;main.T&#123;a:7, b:-2.35, c:\"abc\\tdef\"&#125;map[string] int&#123;\"CST\":-21600, \"PST\":-28800, \"EST\":-18000, \"UTC\":0, \"MST\":-25200&#125; (Note the ampersands.) That quoted string format is also available through %q when applied to a value of type string or []byte . The alternate format %#q will use backquotes instead if possible. (The %q format also applies to integers and runes, producing a single-quoted rune constant.) Also, %x works on strings, byte arrays and byte slices as well as on integers, generating a long hexadecimal string, and with a space in the format ( % x ) it puts spaces between the bytes. Another handy format is %T , which prints the_type_of a value. 1fmt.Printf(\"%T\\n\", timeZone) prints 1map[string] int If you want to control the default format for a custom type, all that’s required is to define a method with the signature String() string on the type. For our simple type T , that might look like this. 1234func (t *T) String() string &#123; return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c)&#125;fmt.Printf(\"%v\\n\", t) to print in the format 17/-2.35/\"abc\\tdef\" (If you need to print_values_of type T as well as pointers to T , the receiver for String must be of value type; this example used a pointer because that’s more efficient and idiomatic for struct types. See the section below onpointers vs. value receiversfor more information.) Our String method is able to call Sprintf because the print routines are fully reentrant and can be wrapped this way. There is one important detail to understand about this approach, however: don’t construct a String method by calling Sprintf in a way that will recur into your String method indefinitely. This can happen if the Sprintf call attempts to print the receiver directly as a string, which in turn will invoke the method again. It’s a common and easy mistake to make, as this example shows. 12345type MyString stringfunc (m MyString) String() string &#123; return fmt.Sprintf(\"MyString=%s\", m) // Error: will recur forever.&#125; It’s also easy to fix: convert the argument to the basic string type, which does not have the method. 1234type MyString stringfunc (m MyString) String() string &#123; return fmt.Sprintf(\"MyString=%s\", string(m)) // OK: note conversion.&#125; In theinitialization sectionwe’ll see another technique that avoids this recursion. Another printing technique is to pass a print routine’s arguments directly to another such routine. The signature of Printf uses the type ...interface{} for its final argument to specify that an arbitrary number of parameters (of arbitrary type) can appear after the format. 1func Printf(format string, v ...interface&#123;&#125;) (n int, err error) &#123; Within the function Printf , v acts like a variable of type []interface{} but if it is passed to another variadic function, it acts like a regular list of arguments. Here is the implementation of the function log.Println we used above. It passes its arguments directly to fmt.Sprintln for the actual formatting. 1234// Println prints to the standard logger in the manner of fmt.Println.func Println(v ...interface&#123;&#125;) &#123; std.Output(2, fmt.Sprintln(v...)) // Output takes parameters (int, string)&#125; We write ... after v in the nested call to Sprintln to tell the compiler to treat v as a list of arguments; otherwise it would just pass v as a single slice argument. There’s even more to printing than we’ve covered here. See the godoc documentation for package fmt for the details. By the way, a ... parameter can be of a specific type, for instance ...int for a min function that chooses the least of a list of integers: 123456789func Min(a ...int) int &#123; min := int(^uint(0) &gt;&gt; 1) // largest int for _, i := range a &#123; if i &lt; min &#123; min = i &#125; &#125; return min&#125; AppendNow we have the missing piece we needed to explain the design of the append built-in function. The signature of append is different from our custom Append function above. Schematically, it’s like this: 1func append(slice []T, elements ...T) []T whereTis a placeholder for any given type. You can’t actually write a function in Go where the type T is determined by the caller. That’s why append is built in: it needs support from the compiler. What append does is append the elements to the end of the slice and return the result. The result needs to be returned because, as with our hand-written Append , the underlying array may change. This simple example 123x := []int&#123;1,2,3&#125;x = append(x, 4, 5, 6)fmt.Println(x) prints [1 2 3 4 5 6] . So append works a little like Printf , collecting an arbitrary number of arguments. But what if we wanted to do what our Append does and append a slice to a slice? Easy: use ... at the call site, just as we did in the call to Output above. This snippet produces identical output to the one above. 1234x := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) Without that ... , it wouldn’t compile because the types would be wrong; y is not of type int .","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter6","slug":"effective-go chapter6","date":"2022-12-14T12:58:08.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter6.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter6.html","excerpt":"","text":"多个返回值Go 的一个不同寻常的特性就是，函数和方法可以返回多个值。这种形式可以用来改进 C 程序中一些笨拙的习语：一些标志性的错误，例如用 -1 表示 EOF ，并且修改传递的地址参数。 在 C 中，一个写错误由一个带有错误码的负计数标识的，它存储在一个可变的地方。在 Go 中， Write 可以返回一个计数和一个错误：“是的，你写了一些字节，但没有全部写完，由于你填满了设备”。在包 os 中，文件 Write 方法的签名是： One of Go’s unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address. In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, Write can return a count and an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the Write method on files from package os is: 1func (file *File) Write(b []byte) (n int, err error) 如文档所说，它返回写入的字节数，当 n != len(b) 时会返回一个非 nil 的错误。这是一种常见的风格；有关更多示例，请参考错误处理部分。 and as the documentation says, it returns the number of bytes written and a non-nil error when n !&#x3D; len(b). This is a common style; see the section on error handling for more examples. 类似的方法排除了向返回值传递指针以模拟引用参数的必要。这里有一个简单的函数，从直接切片中获取一个数字，并返回这个数字和下一个位置。 A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here’s a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position. 123456789func nextInt(b []byte, i int) (int, int) &#123; for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ &#123; &#125; x := 0 for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ &#123; x = x*10 + int(b[i]) - '0' &#125; return x, i&#125; 你可以使用它（上面的函数），去扫描切片 b 中的数字。 You could use it to scan the numbers in an input slice b like this: 1234for i := 0; i &lt; len(b); &#123; x, i = nextInt(b, i) fmt.Println(x)&#125; 命名返回参数Go中函数的返回值是可以指定名字的，并可以像常规变量一样使用，就像是入参一样。当返回参数被命名时，在函数开始时它们会被初始化为对应类型的零值；如果函数执行了没有参数的return语句，则结果参数的当前值将被用作返回值。 The return or result “parameters” of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values. 返回值的名字并非强制性的，但是它们可以让代码看起来更简短、更清晰：它们就是文档本身。如果我们给nextInt的返回值指定名字话，每个int所代表的含义就很明显了。 The names are not mandatory but they can make code shorter and clearer: they’re documentation. If we name the results of nextInt it becomes obvious which returned int is which. 1func nextInt(b []byte, pos int) (value, nextPos int) &#123; 延迟执行Go的defer语句会安排一个函数调用（defer函数），使得在return之前立即执行defer函数。这是一个不同寻常但高效的方式，去处理类似的场景：不论从哪个函数分支返回，资源必须得到释放。典型的例子是解锁互斥锁，或者关闭文件。 Go’s defer statement schedules a function call (the deferred function) to be run immediately before the function executing the defer returns. It’s an unusual but effective way to deal with situations such as resources that must be released regardless of which path a function takes to return. The canonical examples are unlocking a mutex or closing a file. 12345678910111213141516171819202122// Contents returns the file's contents as a string.func Contents(filename string) (string, error) &#123; f, err := os.Open(filename) if err != nil &#123; return \"\", err &#125; defer f.Close() // f.Close will run when we're finished. var result []byte buf := make([]byte, 100) for &#123; n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) // append is discussed later. if err != nil &#123; if err == io.EOF &#123; break &#125; return \"\", err // f will be closed if we return here. &#125; &#125; return string(result), nil // f will be closed if we return here.&#125; 延迟类似 Close 这样的函数执行，有两个好处。第一，它可以保证你永远不会忘记关闭文件，特别是在以后改写这个函数并添加新的返回分支的情况下，极易犯的一个错误。第二，这意味着 close 紧挨着 open ，这远比放在函数末尾要清晰得多。 Deferring a call to a function such as Close has two advantages. First, it guarantees that you will never forget to close the file, a mistake that’s easy to make if you later edit the function to add a new return path. Second, it means that the close sits near the open, which is much clearer than placing it at the end of the function. defer 函数的参数（如果函数是方法，则包括接收方）是在延迟执行时计算的，而非调用执行时计算。此外，不必担心变量的值在函数执行时变化，也就是说，一个延迟执行也会延迟其他延迟函数的执行。举一个简单的例子。 The arguments to the deferred function (which include the receiver if the function is a method) are evaluated when the defer executes, not when the call executes. Besides avoiding worries about variables changing values as the function executes, this means that a single deferred call site can defer multiple function executions. Here’s a silly example. 123for i := 0; i &lt; 5; i++ &#123; defer fmt.Printf(\"%d \", i)&#125; defer 函数的执行遵循 LIFO 的顺序，因此，这段代码在返回时会打印出 4 3 2 1 。另一个更加可信的例子是，这是一种简单的方式，它可以跟踪程序的执行过程。我们可以写出很多跟踪执行路径的例子，比如： Deferred functions are executed in LIFO order, so this code will cause 4 3 2 1 0 to be printed when the function returns. A more plausible example is a simple way to trace function execution through the program. We could write a couple of simple tracing routines like this: 123456789func trace(s string) &#123; fmt.Println(\"entering:\", s) &#125;func untrace(s string) &#123; fmt.Println(\"leaving:\", s) &#125;// Use them like this:func a() &#123; trace(\"a\") defer untrace(\"a\") // do something....&#125; 我们可以更好地利用延迟函数的参数在延迟执行时计算这一事实。traceing 为 untracing 设置参数。例如： We can do better by exploiting the fact that arguments to deferred functions are evaluated when the defer executes. The tracing routine can set up the argument to the untracing routine. This example: 1234567891011121314151617181920212223func trace(s string) string &#123; fmt.Println(\"entering:\", s) return s&#125;func un(s string) &#123; fmt.Println(\"leaving:\", s)&#125;func a() &#123; defer un(trace(\"a\")) fmt.Println(\"in a\")&#125;func b() &#123; defer un(trace(\"b\")) fmt.Println(\"in b\") a()&#125;func main() &#123; b()&#125; 输出 prints 123456entering: bin bentering: ain aleaving: aleaving: b 来自于其他语言已经习惯于块资源管理的程序员来说， defer 可能看起来有点奇怪，但是它是最有趣的，强大的应用恰恰来自于这样一个事实：它不是基于块而是基于函数的。在异常和恢复一节中，我们会看到另外一个例子，和它的可能性。 For programmers accustomed to block-level resource management from other languages, defer may seem peculiar, but its most interesting and powerful applications come precisely from the fact that it’s not block-based but function-based. In the section on panic and recover we’ll see another example of its possibilities.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter5","slug":"effective-go chapter5","date":"2022-12-14T12:54:23.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter5.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter5.html","excerpt":"","text":"Go的控制结构与C相关，但是在重要的方面存在差异。Go中没有 do 、 while 循环，只有一个略微广义的 for ； switch 则更加灵活， if 和 switch 接受类似于for的可选初始化语句； break 和 continue 语句接受一个可选的标号来标识中断或继续什么；也有一些新的控制结构，包括类型 switch 和多路通信多路复用器（a multiway communications multiplexer），select。语法上，也略微不同：没有括号，控制结构体必须总是由大括号包起来。 The control structures of Go are related to those of C but differ in important ways. There is no do or while loop, only a slightly generalized for ; switch is more flexible; if and switch accept an optional initialization statement like that of for ; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select . The syntax is also slightly different: there are no parentheses and the bodies must always be brace-delimited. If在Go中，一个 if 的例子大概长这样： In Go a simple if looks like this: 123if x &gt; 0 &#123; return y&#125; 强制性的大括号g7里在多行中编写简单语句。不管怎样，这样做是一个好的风格，尤其是当控制体包含一条控制一句时，比如 return 或者 break 。 由于if和switch可以接受初始化语句，那么常见的情况是用来创建一个局部变量。 Mandatory braces encourage writing simple if statements on multiple lines. It’s good style to do so anyway, especially when the body contains a control statement such as a return or break . Since if and switch accept an initialization statement, it’s common to see one used to set up a local variable. 1234if err := file.Chmod(0664); err != nil &#123; log.Print(err) return err&#125; 在Go的基础库中，if语句不会不会流向下一条语句时——也就是说，控制体以 break ， continue ， goto 或者 return 结尾——这时，没有不要的 else 会被省略。 In the Go libraries, you’ll find that when an if statement doesn’t flow into the next statement—that is, the body ends in break , continue , goto , or return —the unnecessary else is omitted. 12345f, err := os.Open(name)if err != nil &#123; return err&#125;codeUsing(f) 这是一个常见的示例，代码需要防范这这一系列的错误。如果代码走下去的都是成功流，可读性会很好。当出现错误时，立即消除它们。由于错误情况会以 return 语句结尾，因此代码不需要 else 语句。 This is an example of a common situation where code must guard against a sequence of error conditions. The code reads well if the successful flow of control runs down the page, eliminating error cases as they arise. Since error cases tend to end in return statements, the resulting code needs no else statements. 12345678910f, err := os.Open(name)if err != nil &#123; return err&#125;d, err := f.Stat()if err != nil &#123; f.Close() return err&#125;codeUsing(f, d) 重新声明和重新赋值题外话， 上一节点最后一个例子演示了 := 短声明的细节。该声明调用 os.Open 进行读取， An aside: The last example in the previous section demonstrates a detail of how the := short declaration form works. The declaration that calls os.Open reads, 1f, err := os.Open(name) 这个语句声明了两个变量， f 和 err 。几行之后，调用 f.Stat 进行读取， This statement declares two variables, f and err . A few lines later, the call to f.Stat reads, 1d, err := f.Stat() 这看起来像是声明了 d 和 err 。但是注意，这连个语句中都出现了 err 。这种重复是合法的：因为 err 是被第一个语句声明，在第二个语句中仅仅是重新赋值。这意味着 f.Stat 使用了前面已经声明的变量 err ，仅仅是给他赋予了新值而已。 which looks as if it declares d and err . Notice, though, that err appears in both statements. This duplication is legal: err is declared by the first statement, but only_re-assigned_in the second. This means that the call to f.Stat uses the existing err variable declared above, and just gives it a new value. 在 := 声明中，变量 v 即使声明过，也是可以再次出现的，前提是： 这个声明和已有声明v在相同的作用域（如果v已经在外面的作用域声明了，这里的声明将会创建一个新的变量§） 初始化中相应的值可以赋值给v，或者 在声明中至少有一个新的变量。 In a := declaration a variable v may appear even if it has already been declared, provided: this declaration is in the same scope as the existing declaration of v (if v is already declared in an outer scope, the declaration will create a new variable §), the corresponding value in the initialization is assignable to v , and there is at least one other variable in the declaration that is being declared anew. 这种不同寻常的特性是纯粹的实用主义，例如，你会经常看到，在一个长的 if-else 链中，更易于使用单个 err 值。 § 值得一提的是，在Go中，函数参数和返回值的作用域跟函数体是一致的。尽管它们在词法上在包裹函数体的大括号之外。 This unusual property is pure pragmatism, making it easy to use a single err value, for example, in a long if-else chain. You’ll see it used often. § It’s worth noting here that in Go the scope of function parameters and return values is the same as the function body, even though they appear lexically outside the braces that enclose the body. For在Go中，for循环跟C的相似——但又不完全相同。它统一了for和while，在Go中没有do-while语句。一共有三种形式，只有只有带有分号。 The Go for loop is similar to—but not the same as—C’s. It unifies for and while and there is no do-while . There are three forms, only one of which has semicolons. 12345678// Like a C forfor init; condition; post &#123; &#125;// Like a C whilefor condition &#123; &#125;// Like a C for(;;)for &#123; &#125; 短声明使得在循环中很容易声明索引变量。 Short declarations make it easy to declare the index variable right in the loop. 1234sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125; 如果你正在循环遍历一个 array ， slice ， string ，或者 map ，亦或是从 channel 中读数据，那么可以使用 range 子句管理循环。 If you’re looping over an array, slice, string, or map, or reading from a channel, a range clause can manage the loop. 123for key, value := range oldMap &#123; newMap[key] = value&#125; 如你仅仅需要 range 的第一项（健或者索引），就丢掉第二个： If you only need the first item in the range (the key or index), drop the second: 12345for key := range m &#123; if key.expired() &#123; delete(m, key) &#125;&#125; 如果你仅需要 range 的第二项（值），可以使用空白标识 _ 下划线，以丢弃第一个： If you only need the second item in the range (the value), use the blank identifier, an underscore, to discard the first: 1234sum := 0for _, value := range array &#123; sum += value&#125; 空白标识符有很多用处，接下来的一节我们会对此详述。 对于字符串， range 为你可以做更过的事情，通过解析 UTF-8 编码来拆分单个 Unicode 编码点。错误的编码会小号一个字节，并产生一个替换性的符文 U+FFFD 。（ rune （相关的内置类型）这个词是 Go 中的术语，用以标记单个 Unicode 编码点。到语言规范查看更多详情）。循环 The blank identifier has many uses, as described in a later section. For strings, the range does more work for you, breaking out individual Unicode code points by parsing the UTF-8. Erroneous encodings consume one byte and produce the replacement rune U+FFFD. (The name (with associated builtin type) rune is Go terminology for a single Unicode code point. See the language specification for details.) The loop 123for pos, char := range \"日本\\x80語\" &#123; // \\x80 is an illegal UTF-8 encoding fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos)&#125; 打印如下： prints 1234character U+65E5 '日' starts at byte position 0character U+672C '本' starts at byte position 3character U+FFFD '�' starts at byte position 6character U+8A9E '語' starts at byte position 7 最后， Go 没有都好运算符， ++ 和 -- 谁语句而不是表达式。因此，如果你想在for中运行多个变量，你应该是用并行赋值（虽然这样会妨碍使用 ++ 和 -- ） Finally, Go has no comma operator and ++ and – are statements not expressions. Thus if you want to run multiple variables in a for you should use parallel assignment (although that precludes ++ and –). 1234// Reverse afor i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 &#123; a[i], a[j] = a[j], a[i]&#125; SwitchGo的 switch 比 C 的更加通用。表达式不必是常量，甚至是整数， case 从上到下的顺序进行求值，直到匹配。如果 switch 没有表达式，则它回匹配 true 。 switch 就像是一个 if-else-if-else 的链。 Go’s switch is more general than C’s. The expressions need not be constants or even integers, the cases are evaluated top to bottom until a match is found, and if the switch has no expression it switches on true. It’s therefore possible—and idiomatic—to write an if-else-if-else chain as a switch. 1234567891011func unhex(c byte) byte &#123; switch &#123; case '0' &lt;= c &amp;&amp; c &lt;= '9': return c - '0' case 'a' &lt;= c &amp;&amp; c &lt;= 'f': return c - 'a' + 10 case 'A' &lt;= c &amp;&amp; c &lt;= 'F': return c - 'A' + 10 &#125; return 0&#125; Go中，switch不会自动通过case，但是case条件可以以逗号表达式列表的形式展示。 There is no automatic fall through, but cases can be presented in comma-separated lists. 1234567func shouldEscape(c byte) bool &#123; switch c &#123; case ' ', '?', '&amp;', '=', '#', '+', '%': return true &#125; return false&#125; break语句可以用来结束一个switch，尽管在Go中并不像在其他语言中那么常见。但是，有时候需要需要跳出一个循环，而不是switch，在Go中可以通过设置一个标号来中断循环。下面的例子会演示这两种用法： Although they are not nearly as common in Go as some other C-like languages, break statements can be used to terminate a switch early. Sometimes, though, it’s necessary to break out of a surrounding loop, not the switch, and in Go that can be accomplished by putting a label on the loop and “breaking” to that label. This example shows both uses. 12345678910111213141516171819202122Loop:truefor n := 0; n &lt; len(src); n += size &#123;truetrueswitch &#123;truetruecase src[n] &lt; sizeOne:truetruetrueif validateOnly &#123;truetruetruetruebreaktruetruetrue&#125;truetruetruesize = 1truetruetrueupdate(src[n])truetruecase src[n] &lt; sizeTwo:truetruetrueif n+1 &gt;= len(src) &#123;truetruetruetrueerr = errShortInputtruetruetruetruebreak Looptruetruetrue&#125;truetruetrueif validateOnly &#123;truetruetruetruebreaktruetruetrue&#125;truetruetruesize = 2truetruetrueupdate(src[n] + src[n+1]&lt;&lt;shift)truetrue&#125;true&#125; 当然，continue语句可以接受一个可选的标号，但是它只能应用于循环。 为结束这一节，这里有一个使用switch语句对字节切片进行比较的例子。 Of course, the continue statement also accepts an optional label but it applies only to loops. To close this section, here’s a comparison routine for byte slices that uses two switch statements。 1234567891011121314151617181920// Compare returns an integer comparing the two byte slices,// lexicographically.// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; bfunc Compare(a, b []byte) int &#123; for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ &#123; switch &#123; case a[i] &gt; b[i]: return 1 case a[i] &lt; b[i]: return -1 &#125; &#125; switch &#123; case len(a) &gt; len(b): return 1 case len(a) &lt; len(b): return -1 &#125; return 0&#125; Type switchswitch 也可以用来发现接口变量的动态类型。这种 type switch 使用类型断言，括号中使用关键字 type 。如果在switch在表达式中声明了一个变量，则变量在每个子句中就会有响应的类型。在这种情况下复用名字也是习惯用法，声明一个变量，在每个子句中类型不同，但有着相同的名字。 A switch can also be used to discover the dynamic type of an interface variable. Such a type switch uses the syntax of a type assertion with the keyword type inside the parentheses. If the switch declares a variable in the expression, the variable will have the corresponding type in each clause. It’s also idiomatic to reuse the name in such cases, in effect declaring a new variable with the same name but a different type in each case.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter4","slug":"effective-go chapter4","date":"2022-12-14T07:34:59.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter4.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter4.html","excerpt":"","text":"跟C一样，Go 的正式语法使用分号结束语句，但与C不同的是，这些分号在源码中不可见。取而代之的是，词法分析器会使用一个简单的规则，在扫描时自动插入分号，所以输入文本中几乎没有它。 具体规则是这样的。在新的一行之前，最后如果是一个这样的标识符（包括 int 、 float64 ），一个基本的文字，如数字、字符串常量、或者是下面符号中的一个 Like C, Go’s formal grammar uses semicolons to terminate statements, but unlike in C, those semicolons do not appear in the source. Instead the lexer uses a simple rule to insert semicolons automatically as it scans, so the input text is mostly free of them. The rule is this. If the last token before a newline is an identifier (which includes words like int and float64 ), a basic literal such as a number or string constant, or one of the tokens 1break continue fallthrough return ++ -- ) &#125; 词法分析器总会在标记后面插入一个分号。这可以总结为：“如果新的一行紧跟一个语句的结束符，就会插入一个分号”。 也可以在右大括号前省略分号，如下语句 the lexer always inserts a semicolon after the token. This could be summarized as, “if the newline comes after a token that could end a statement, insert a semicolon”. A semicolon can also be omitted immediately before a closing brace, so a statement such as 1go func() &#123; for &#123; dst &lt;- &lt;-src &#125; &#125;() 无需分号。习惯用法是，Go程序只在像 for 循环这样的语句中使用分号，以分割初始化器，条件，延续元素。分号还用于分割一行的多条语句。 插入分号的一个结果是，你不能把控制语句的左大括号放在下一行。如果你确实这样做了，括号前就会插入一个分号，这将导致不可预知的结果。要这样写： needs no semicolons. Idiomatic Go programs have semicolons only in places such as for loop clauses, to separate the initializer, condition, and continuation elements. They are also necessary to separate multiple statements on a line, should you write code that way. One consequence of the semicolon insertion rules is that you cannot put the opening brace of a control structure ( if , for , switch , or select ) on the next line. If you do, a semicolon will be inserted before the brace, which could cause unwanted effects. Write them like this 123if i &lt; f() &#123; g()&#125; 而不是这样： not like this 1234if i &lt; f() // wrong!&#123; // wrong! g()&#125;","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter3","slug":"effective-go chapter3","date":"2022-12-14T07:34:49.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter3.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter3.html","excerpt":"","text":"和其他语言一样，名字在Go中同样重要。它们甚至有着一样的语义：一个包内的名字是否对外可见，取决于其首字母是否大写。因此，花一点时间讨论一波Go程序的命名约定是很有必要的。 Names are as important in Go as in any other language. They even have semantic effect: the visibility of a name outside a package is determined by whether its first character is upper case. It’s therefore worth spending a little time talking about naming conventions in Go programs. 包名当一个导入一个包时，包名就是包内容的访问器。在如下标识之后： When a package is imported, the package name becomes an accessor for the contents. After 1import \"bytes\" 以导入包 bytes.Buffer 为例讨论包导入。如果可以使用相同的名字来访问一个包都内容将会非常有用，这也意味着包名是好的：简短，简洁，有吸引力。按惯例，包名通常时一个小写的单词；不需要使用下划线或者混合大小写。要力求简洁，因为每个用这个包都人都会敲这个名字。另外，不必担心与先前的名字有冲突。包名仅仅是导入后的默认名字，在所有代码中不必唯一，在少有的冲突情况下，可以选一个不同的名称在本地使用。不管怎样，冲突很少见，因为导入的文件名确定了要使用的包。 the importing package can talk about bytes.Buffer . It’s helpful if everyone using the package can use the same name to refer to its contents, which implies that the package name should be good: short, concise, evocative. By convention, packages are given lower case, single-word names; there should be no need for underscores or mixedCaps. Err on the side of brevity, since everyone using your package will be typing that name. And don’t worry about collisionsa priori. The package name is only the default name for imports; it need not be unique across all source code, and in the rare case of a collision the importing package can choose a different name to use locally. In any case, confusion is rare because the file name in the import determines just which package is being used. 另外一个约定是，包名是源目录的基础名。程序包 src/encoding/base64 以 encoding/base64 导入，但是包名是 base64 ，不是 encoding_base64 也不是 encodingBase64 。 Another convention is that the package name is the base name of its source directory; the package in src/encoding/base64 is imported as &quot;encoding/base64&quot; but has name base64 , not encoding_base64 and not encodingBase64 . 程序包引入者将使用这个名字引用包内容。因此，包中的导出名字可以利用这个事实来避免残迹。（不要使用 import . 标记，这将会简化那些必须运行在包之外而不可避免的测试）例如，在包 bufio 中缓冲阅读类型叫做 Reader ，而不是 BufReader ，因为用户会把它看作是 bufio.Reader 这样是清晰的、简洁的名字。此外，还因为导入实体通常使用他们他们的包名称寻址的， bufio.Reader 与 io.Reader 并不冲突。同样，创建一个 ring.Ring 的新实例——Go中构造的定义——通常会叫做 NewRing ，但是由于包名是 ring ，而 Ring 仅仅是包的导出类型，它只叫做 New 。这样，客户端看到的将是 ring.New 。使用包结构可以帮助你选择好的名字。 The importer of a package will use the name to refer to its contents, so exported names in the package can use that fact to avoid stutter. (Don’t use the import . notation, which can simplify tests that must run outside the package they are testing, but should otherwise be avoided.) For instance, the buffered reader type in the bufio package is called Reader , not BufReader , because users see it as bufio.Reader , which is a clear, concise name. Moreover, because imported entities are always addressed with their package name, bufio.Reader does not conflict with io.Reader . Similarly, the function to make new instances of ring.Ring —which is the definition of a constructor in Go—would normally be called NewRing , but since Ring is the only type exported by the package, and since the package is called ring , it’s called just New , which clients of the package see as ring.New . Use the package structure to help you choose good names. 另一个简短的例子是 once.Do ； once.Do(setup) 的可读性很好，写成 once.DoOrWaitUntilDone(setup) 并不会有所改善。更长的名字并不会自动变得更易读。通常，一条有用的文档注释比额外的长名字更有价值。 Another short example is once.Do ; once.Do(setup) reads well and would not be improved by writing once.DoOrWaitUntilDone(setup) . Long names don’t automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name. Get方法Go 并未提供自动的 get/se t方法。不过，你自行提供 get/set 方法也无可厚非，通常这么做也是合适的。但是，在 Get 方法前面加 get ，既不是习惯也没有必要。如果你有一个字段 owner （小写的，非导出型），它的 get 方法应该叫作 Owner （大写的，导出型），而不是 GetOwner 。大写名字导出的用法，提供了区分字段和方法的钩子。一个 set 方法，如果有必要的话，可能叫作 SetOwner 。这两个名字在实际应用中可读性都很好。 Go doesn’t provide automatic support for getters and setters. There’s nothing wrong with providing getters and setters yourself, and it’s often appropriate to do so, but it’s neither idiomatic nor necessary to put Get into the getter’s name. If you have a field called owner (lower case, unexported), the getter method should be called Owner (upper case, exported), not GetOwner . The use of upper-case names for export provides the hook to discriminate the field from the method. A setter function, if needed, will likely be called SetOwner . Both names read well in practice: 1234owner := obj.Owner()if owner != user &#123; obj.SetOwner(user)&#125; 接口名依管理，一个方法接口由方法名加上 er 后缀或者类似的修改来命名，以构造一个替代性的名词：Reader，Writer，Formatter，CloseNotifier 等等。 By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader , Writer , Formatter , CloseNotifier etc. 由很多类似的名字，尊重它们和它们说体现的函数名，是最富有成效的了。Read，Write，Close，Flush，String 等等有着最具规范的签名和含义。以免混乱，不要给你的方法起这些名字，除非它有相同的签名和含义。相反的，如果你的类型实现了一个有相同含义的方法，跟常用类型的方法一样，可以给他一个相同的名字和函数签名：可以把你的字符串转换方法叫作 String 而不是 ToString 。 There are a number of such names and it’s productive to honor them and the function names they capture. Read , Write , Close , Flush , String and so on have canonical signatures and meanings. To avoid confusion, don’t give your method one of those names unless it has the same signature and meaning. Conversely, if your type implements a method with the same meaning as a method on a well-known type, give it the same name and signature; call your string-converter method String not ToString . 混合大小写最后，在Go中有这样一个约定，使用混合大小写的形式（类似驼峰，但是注意首字母），而不是下划线，来写多单词的名字。 Finally, the convention in Go is to use MixedCaps or mixedCaps rather than underscores to write multiword names.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter2","slug":"effective-go chapter2","date":"2022-12-14T07:34:40.000Z","updated":"2025-10-27T00:35:41.792Z","comments":true,"path":"effective-go chapter2.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter2.html","excerpt":"","text":"格式Go 提供了 C-style 的块注释 /* */ 和 C++ style 的行注释。通常情况下用行注释；块注释大多数作为包注释，在表达式中或者禁用大量代码时也是非常有用得。 Go provides C-style /* */ block comments and C++-style // line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code. 程序——同时又是网络服务器—— godoc ，处理 Go 源文件并导出包内容生成文档。在顶层声明出现前，没有出现换行符的注释，回和声明一起被导出作为该项的解释性文本。注释的性质和风格决定了 godoc 生成文档的质量。 The program—and web server— godoc processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation godoc produces. 每个包都应该有一个包子句前面的块注释。对于多文件包，包注释只需要出现在一个文件中，任何一个都可以。包注释应该介绍包，并提供与整个包相关的信息。它（注释）会出现在 godoc 页面，并应该建立后续的详细文档。 Every package should have apackage comment, a block comment preceding the package clause. For multi-file packages, the package comment only needs to be present in one file, and any one will do. The package comment should introduce the package and provide information relevant to the package as a whole. It will appear first on the godoc page and should set up the detailed documentation that follows. 1234567891011121314151617181920/*Package regexp implements a simple library for regular expressions.The syntax of the regular expressions accepted is: regexp: concatenation &#123; '|' concatenation &#125; concatenation: &#123; closure &#125; closure: term [ '*' | '+' | '?' ] term: '^' '$' '.' character '[' [ '^' ] character-ranges ']' '(' regexp ')'*/package regexp 如果包比较简单的话，包注释也可以简洁一些。 If the package is simple, the package comment can be brief. 12// Package path implements utility routines for// manipulating slash-separated filename paths. 注释并不需要额外格式，比如星号横幅。生成的输出甚至可能不以固定宽度字体展示，所以，不要依赖空格去对齐—— godoc ，比如 gofmt ，记得这一点。注释是不被解释的纯文本，因此 HTML ，还有诸如 _this_ 的这类注释将会被逐字复制，最好不要使用（效果非预期）。godoc使用等宽文本，适合于程序片段。包 fmt package 使用了这种方式，获得了很好的效果。 Comments do not need extra formatting such as banners of stars. The generated output may not even be presented in a fixed-width font, so don’t depend on spacing for alignment— godoc , like gofmt , takes care of that. The comments are uninterpreted plain text, so HTML and other annotations such as _this_ will reproduce verbatim and should not be used. One adjustment godoc does do is to display indented text in a fixed-width font, suitable for program snippets. The package comment for the fmt package uses this to good effect. 根据上下文的不同， godoc 甚至可能不会重新格式化注释，因此，确保这些注释看起来非常直观：拼写正确，标点和句子结构，折叠过长的行，等等。 Depending on the context, godoc might not even reformat comments, so make sure they look good straight up: use correct spelling, punctuation, and sentence structure, fold long lines, and so on. 在一个包里，在顶级声明之前的任何注释都将作为文档注释。程序的每个导出的（大写的）名称都应该有一个文档注释。 Inside a package, any comment immediately preceding a top-level declaration serves as a doc commentfor that declaration. Every exported (capitalized) name in a program should have a doc comment. 文档注释最好是完整的句子，它允许各种各样的自动化展示。第一句应该是一句总结性的话，并以被声明的名称开头。 Doc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared. 123// Compile parses a regular expression and returns, if successful,// a Regexp that can be used to match against text.func Compile(str string) (*Regexp, error) &#123; 如果每个文档注释都以所描述的条目的名称开头，那么，就可以很方便的通过grep来处理 godoc 的输出。假设你正在找正则表达式的解析函数，却未能记住“Compile”这个名字，这时就可以运行命令： If every doc comment begins with the name of the item it describes, the output of godoc can usefully be run through grep . Imagine you couldn’t remember the name “Compile” but were looking for the parsing function for regular expressions, so you ran the command, 1$ godoc regexp | grep -i parse 如果包中注释都以“This function”开头，grep将不会有任何帮助。但由于包文档注释都以名称开头，你将会看到类似的场景，来帮助你回忆起你所要找寻东西。 If all the doc comments in the package began, “This function…”, grep wouldn’t help you remember the name. But because the package starts each doc comment with the name, you’d see something like this, which recalls the word you’re looking for. 12345$ godoc regexp | grep parse Compile parses a regular expression and returns, if successful, a Regexp parsed. It simplifies safe initialization of global variables holding cannot be parsed. It simplifies safe initialization of global variables$ Go的声明语法允许对声明进行分组。单个文档注释可以引入一组相关的常量或变量。因为展示的是整个声明，这种注释看起来就略显敷衍了。 Go’s declaration syntax allows grouping of declarations. A single doc comment can introduce a group of related constants or variables. Since the whole declaration is presented, such a comment can often be perfunctory. 1234567// Error codes returned by failures to parse an expression.var ( ErrInternal = errors.New(\"regexp: internal error\") ErrUnmatchedLpar = errors.New(\"regexp: unmatched '('\") ErrUnmatchedRpar = errors.New(\"regexp: unmatched ')'\") ...) 分组还可以表明不同条目间的关系，比如一组变量受到互斥对象的保护。 Grouping can also indicate relationships between items, such as the fact that a set of variables is protected by a mutex. 123456var ( countLock sync.Mutex inputCount uint32 outputCount uint32 errorCount uint32)","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"effective-go chapter1 前言","slug":"effective-go chapter1","date":"2022-12-14T07:34:35.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"effective-go chapter1.html","link":"","permalink":"https://liangyuanzheng.com/effective-go%20chapter1.html","excerpt":"","text":"格式问题是最具争议但影响最小的问题。人们可以适应不同的格式风格，但如果他们不必这样做就更好了（鬼知道有没有强迫症），这样就不必专门花时间去讨论遵循相同风格的问题了。问题是如何在没有冗长风格指南的情况下实现这个乌托邦。 Formatting issues are the most contentious but the least consequential. People can adapt to different formatting styles but it’s better if they don’t have to, and less time is devoted to the topic if everyone adheres to the same style. The problem is how to approach this Utopia without a long prescriptive style guide. 在 Go 中，我们使用一种不同寻常的方法，让机器础处理大多数格式化问题。程序 gofmt （或者 go fmt ，在包级别操作而不是源文件级别）读取 Go 程序，以标准风格缩进和垂直对齐，保留并在必要时重新格式化注释。如果你想知道如何处理一些新的布局情况，运行 gofmt ，如果结果看起来不对，那就重新组织你的程序（或者报个 gofmt 的 bug ），不要绕过这个问题。 With Go we take an unusual approach and let the machine take care of most formatting issues. The gofmt program (also available as go fmt , which operates at the package level rather than source file level) reads a Go program and emits the source in a standard style of indentation and vertical alignment, retaining and if necessary reformatting comments. If you want to know how to handle some new layout situation, run gofmt ; if the answer doesn’t seem right, rearrange your program (or file a bug about gofmt ), don’t work around it. 例如，不必花时间去对注释进行排版， gofmt 对帮助你做到。给定一个声明： As an example, there’s no need to spend time lining up the comments on the fields of a structure. Gofmt will do that for you. Given the declaration 1234type T struct &#123; name string // name of the object value int // its value&#125; gofmt 将会重新按列进行排列： gofmt will line up the columns: 1234type T struct &#123; name string // name of the object value int // its value&#125; 标准包中断所有 Go 代码都已经使用 gofmt 格式化过。 保留了一些格式细节，非常简洁： 缩进 gofmt 默认使用 tabs 缩进，只有在必要时才会使用空格。 每行长度 Go 中没有对行长度作限制。不必担心溢出穿孔卡。如果觉得一行太长，可以改为多行并以tab缩进。 括号 Go 比 C 和 Java 需要的括号更少：控制结构（if，for，switch）无需括号。此外，运算符优先层次也更短、更清晰。因此，x&lt;&lt;8 + y&lt;&lt;16 的含义也就由空格表明了，这是与其他语言不同的。 All Go code in the standard packages has been formatted with gofmt . Some formatting details remain. Very briefly: Indentation We use tabs for indentation and gofmt emits them by default. Use spaces only if you must. Line length Go has no line length limit. Don’t worry about overflowing a punched card. If a line feels too long, wrap it and indent with an extra tab. Parentheses Go needs fewer parentheses than C and Java: control structures ( if , for , switch ) do not have parentheses in their syntax. Also, the operator precedence hierarchy is shorter and clearer, so x&lt;&lt;8 + y&lt;&lt;16 means what the spacing implies, unlike in the other languages.","categories":[{"name":"effective-go","slug":"effective-go","permalink":"https://liangyuanzheng.com/categories/effective-go/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"燕京八景","slug":"燕京八景","date":"2022-12-12T16:00:00.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"燕京八景.html","link":"","permalink":"https://liangyuanzheng.com/%E7%87%95%E4%BA%AC%E5%85%AB%E6%99%AF.html","excerpt":"","text":"“燕京八景”又称“燕山八景”或“燕台八景”等，得名于金代明昌间，后代文人纷纷题诗，遂名闻遐迩。明代李东阳于八景之外又增“南囿秋风”、“东郊时雨”并赋《十景》诗，所以又有“燕京十景”之说。 清乾隆十六年（1751 年）御定八景为：太液秋风、琼岛春阴、金台夕照、蓟门烟树、西山晴雪、玉泉趵突、卢沟晓月、居庸叠翠，当时均刻石立碑并有小序、诗文。燕京八景的出现，对于后来的风景点建设产生了巨大影响。从此之后，无论“十室之邑，三里之城，五亩之园，以及琳宫梵宇，靡不有八景诗矣”。现代园林、庭院绿化亦借鉴燕京八景，建造景点，在一定程度上推动了园林建设的发展。 西山晴雪西山是指北京西郊连绵山脉的总称，是太行山的’一支余脉。所说的雪景亦泛指此一带。香山是这一带典型的山峰，故乾隆把”西山晴雪”碑立在香山山腰。 蓟门烟树“蓟门烟树”碑，立在德胜门外五里的土城边。这里历史上曾有“烟树”的景观。 居庸叠翠古时居庸关范围包括全部关沟峡谷。下端沟口叫下口或夏口，也叫南口。关沟曲折而上。经居庸关、上关，直达北口 ── 八达岭。北沟是北京北部燕山山脉的缺口，山谷中峰峦叠嶂，林木葱郁，山花烂漫，层林尽染，山水明媚，景致非凡，”居庸叠翠”碑就在此谷中部的叠翠山上。 太液秋枫今中南海(原名太液池)东岸万善门旁，有一水埠，水中有亭名为”水云榭”，榭中立景名牌。《燕京八景图》中记述说：”……天气晴明，日月晃漾而波澜涟漪清澈可爱，故曰太液晴波。”乾隆诗中有”秋到农居爽籁生，玉湖澄碧画桥横”之句，故叫太液秋风。 琼岛春阴乾隆钦定该景石碑原在今北海白塔山西坡悦心门前。乾隆五十一年(1786 年)迁到白塔山东侧现址。 玉泉趵突玉泉山在万寿山之西。金章宗于山麓建泉水院。玉泉山有三个石洞，一个在山西南，下面有泉，深浅莫测;一个在山南，泉水流出”鸣若杂佩，色如素练”;一在山根，有泉涌出，其味甘冽，门刻”玉泉”二字。 金台夕照小北先科普一下，此金台非杭州那个金台，这里说的是黄金台。原指公元前三世纪，燕昭王为礼贤下士所置之土台，上面放着千金，聘请天下名士。目前有金台七八处。乾隆皇帝曾把石碑立在朝外,原苗家地教场东边半里的土丘上。1935 年出版的《旧都文物略》中，还能见到石碑倒卧的照片。现在无任何遗迹了。 卢沟晓月卢沟即永定河，古来交通要津。金世宗 1189 年下令建桥，1192 年(明昌三年)落成，命名广利桥。桥如长虹，十一拱券门，四个华表，望柱上雕有大水石狮 485 个。桥长 266 米，宽 9 米。古时交通不太方便，京城距此约是半天的路程。送别京门，打尖住宿，来日早行。鸡鸣上路，尚见明月当空，大地似银，”卢沟桥上月如霜”。于是“晓月”的意境名传遐迩。 此外，后来北京又有了燕京小八景(后燕京八景)：南囿秋风、东郊时雨、银锭观山、西便群羊、燕社鸣秋、长安观塔、回光返照(史料尚缺一景) 北京其他地区“八景”大兴八景：星台晓望、云塔夕登、满井春游、漕艘午渡、鱼塘濯锦、燕社鸣秋、名刹古棠、亦园新柳。 宛平八景：北海冰航、西湖莲径、梵宫塔影、佛殿松阴、山轩御笔、竹轩御笔、竹墅龙湫、退谷水源、栖隐岩洞。 通州八景：古塔凌云、长桥映月、柳荫龙舟、波分凤沼、高台丛树、平野孤峰、二水会流、万舟骈集。 燕平(昌平)八景：松盖长青、天峰拔翠、石洞仙踪、银山铁壁、虎峪辉金、龙泉喷玉、安济春流、居庸霁雪。 怀柔八景：寒泉喷珠、忝谷阳和、钓台秋月、龙潭春水、红螺呈秀、定惠双塔、松棚挽翠、金鸡鸣祥。 房山八景：大房耸翠、上方山寺、云水奇观、西天胜概、红螺三(山佥)、孔水仙舟、金山香水、白水异浆。 平谷八景：盘阴积雪、(氵句)水晚渡、石室清风、峨嵋耸翠、独乐晴波、鼓岭同云、峰台返照、灵泉漱玉。 密云八景：冶塔仙灯、圣水鸣琴、白檀晴光、清洞晓色、霞峰散彩、水沼呈祥、五峰凌云、回阳返照。 范阳(顺义)八景：玉(石童)金马、金牛古洞、宝塔凌风、曲水晴涛、高台仙阁、海岛回澜、圣井涌泉、三山隐秀。 延庆八景：海沱飞雨、神峰列翠、荷池夕照、妫川积雪、古城烟树、独山夜月、缙阳远眺、珠泉喷玉。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"TODO","slug":"todo","permalink":"https://liangyuanzheng.com/tags/todo/"},{"name":"收藏","slug":"收藏","permalink":"https://liangyuanzheng.com/tags/%E6%94%B6%E8%97%8F/"},{"name":"北京","slug":"北京","permalink":"https://liangyuanzheng.com/tags/%E5%8C%97%E4%BA%AC/"}]},{"title":"从零开始搭建一个通用的业务技术架构","slug":"从零开始搭建一个通用的业务技术架构","date":"2022-12-11T14:11:36.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"从零开始搭建一个通用的业务技术架构.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.html","excerpt":"","text":"1、通用架构概述创业之初，我们往往会为了快速迭代出产品，而选择最简单的技术架构，比如LAMP架构，SSH三层架构。这些架构可以适应初期业务的快速发展，但是，随着业务变得越来越复杂，我们会发现这些架构越来越难支撑业务的发展，出现在一个类中写好几千行代码，一个方法中到处都是if else语句，如果中间遇到主程序猿离职，后面介入的程序猿几乎无法理解这些代码，到最后，产品越来越难迭代，只能推翻重做。如果我们在创业初始就以一种适应性较强的架构去写代码，后面就会少走很多弯路。下面的文章是我自己总结出来的一套架构，经过实践，适应性还算不错。 2、通用架构实现总的来说我的通用架构还是以三层架构为基础进行演变的，在经典的三层架构中，最上层的是controller，中间是service，下层是dao。在我的架构中，最上层是网关层，controller只是网关的一种，中间是业务层，service只是业务层的入口，最下层是基础层，dao只是基础层中的数据存储组件。 2.1、网关层网关层本质上是对不同的网络协议的请求进行处理，比如HTTP协议，TCP协议，当然，也可以对其他协议进行处理。具体见下图： 2.1.1、HTTP请求一般来自PC端和APP端的请求都是基于HTTP协议的，对于处理HTTP请求的方案，业内已经非常成熟了。首先，tomcat容器本身已经把HTTP请求处理的复杂性封装掉了，其次，spring mvc对请求处理提供了RESTful风格的编码方式，大大降低了开发的复杂度。我们要做的就是对controller按照业务领域划分，比如按照订单、会员去划分大的领域，里面的各种方法就是这个领域内的操作。这里的controller就是统一网关处理层，对于每个controller的方法只做三件事，第一，将请求参数解析出来并组装成内部参数，第二调用下层服务执行业务逻辑，第三组装返回结果，对于异常情况，需要记录异常堆栈日志并转换错误码，堆栈信息不要暴露到调用方。 2.1.2、TCP请求对于处理TCP请求的方案，业内也已经很成熟了，比如Netty。但是，TCP请求毕竟太底层，我们往往会基于TCP协议去开发自己的协议。另外，很多分布式框架都是基于TCP协议的，比如RPC框架Dubbo，消息框架RocketMQ等等。从单机系统到分布式系统，无非就是网关层多了处理TCP请求的逻辑，理论上底层的业务是无需感知自己到底是出于单机环境还是分布式环境，网关层的作用就是要屏蔽这种不同外部调用源的细节。在Dubbo服务端中，我们需要实现远程接口，并对远程服务调用进行内部的转发，转发的逻辑也很简单，首先是解析参数并组装内部参数，然后调用业务层的接口执行业务逻辑，最后组装返回结果，对于异常处理也需要在这里做掉，防止异常暴露给外部应用。 2.1.3、小结网关层本质是对协议进行处理，同时将业务逻辑收敛到网关层，而不是暴露给外部，当内部业务逻辑进行重构的时候，外部调用方就不需要感知这些变化，当外部调用源增加时，内部业务逻辑不需要感知这种变化，从而将外部调用方和内部业务逻辑进行了解耦。 2.2、业务层业务层是一个系统，无论是单机系统还是分布式系统群中的某个业务系统，业务层都是承载业务流程和规则的地方。业务层从外到内包含三层：第一层是业务服务，第二层是业务流程，第三层是业务组件。具体如下图： 2.2.1、业务服务业务服务是业务层对外的统一门面，它由三方面组成：业务接口、入参、出参。 a) 业务接口 一个业务接口代表一个领域的业务服务，比如订单域的业务服务就由接口OrderService表示，会员域的业务服务就由接口MemberService表示。接口可以按照执行性质分为读接口和写接口，比如OrderReadService和OrderWriteService。读写分离的好处是可以对集群进行读写分组，从而管理流量，当然，单机系统读写分离意义不是太大。领域内的操作则以业务接口中的方法的形式体现，比如订单域有下单createOrder，取消订单cancelOrder等等操作。对于这些操作，尽量设计出有业务含义的方法，而不是增删改查，当然，对于一些简单的业务，也只能增删改查。 b) 入参 接下来，是入参的设计。入参对于读方法，比较简单，不做讨论。对于写方法，我们将入参设计成有层次的数据模型。首先需要设计出公共的数据模型，比如订单数据模型，商家数据模型，商品数据模型等，然后将这些数据模型和一些特定业务下的个性数据结合，组成Request对象，这个request对象按照不同业务操作不同而不同，对应的返回结果就是response，它也是随着不同业务返回的参数不同。 举个例子，拿下餐饮订单来说，首先，我们应该识别出这些业务流程中一些比较基础的数据模型，比如餐饮领域的菜品、桌位等，这些模型之所以说是基础模型，是因为，不管下什么餐饮订单，菜品和桌位肯定是逃不了的，它们是可以被复用的！因此，我们分别为这些基础模型设计相对于的DO（Domian Object）:DishDO（菜品）、BoardDO（桌位）等等，接下来，我们为下餐饮订单设计一个请求对象DishOrderCreateRequest其中DishOrderCreateRequest内部包含了DishDO和BoardDO，另外会包含一些特定的属性，比如人数啊，折扣啊等等，这样一来就能做到通用和灵活兼顾，DishOrderCreateRequest代表的个性化的灵活的业务入参，而DishDO和BoardDO等则代表了不易变化的基础模型。 c) 出参 最后，是出参的设计。对于写方法，一般出参比较简单。对于读方法，出参往往是一个结构与层次比较复杂的组合对象。比如查询一个订单，这个订单有订单基本信息，还有商品信息，收货人地址信息等。在设计出参的时候，结构上要设计成组合对象，但是真正查询的时候，通过查询选择器，去查询不同的组合对象。比如查询选择器设置商品查询为true，地址查询为false，那么这次查询出的订单就只包含商品，而不包含地址。 2.2.2、业务流程业务流程其实就是对业务规则的解释，只是这种解释使用代码去实现的，我们要做的其实就是准确翻译这些业务规则，并维护好这些业务规则。 业务流程中可以大致分为三种动作节点，1、组装参数节点 2、规则判断节点 3、执行动作节点，其中每个动作节点都是一些业务代码的片段。举个例子，下餐饮订单，我们第一步就是将上层传入的参数组装出一个基础的DishOrderDO（组装参数节点），然后按照特定的规则去填充这个DishOrderDO（规则判断节点），然后就是调用DAO去创建DishOrderDO（执行动作节点）。 业务流程是最容易变化的地方，要想维护好业务流程并不容易，总的思想是将大的业务流程拆分成小的业务流程，抽出每个业务流程中共有的代码片段，变成可维护的业务组件。 2.2.2、业务组件a) 基础组件 业务组件其实是将一些内聚的可复用的代码片段进行封装。和业务流程中的三种业务节点相对应，业务组件也分为三种：组装参数组件 、规则判断组件 、动作执行业务组件。业务组件的抽象往往是对业务有了深刻理解之后才进行的，盲目地进行业务组件的抽象，往往到头来白忙活。 b) 能力 对业务组件进行进一步抽象，可以得到能力。业务能力是具有一定复用性的组件的组合，比如发短信能力&#x3D;组装短信参数组件+发短信组件。对于发短信能力，可以被不同的业务流程复用，比如订单下单成功发短信，支付成功发短信，逻辑都是相似的，只有内容不同。能力是一种粒度比较大的组件，粒度越大，往往复用性就越小，对能力的抽取，也是基于对特定业务深刻的理解，没有一劳永逸的银弹。 c) 更高纬度的抽象 经过本人的实践，对于互联网这样的需求变化极快的场景，更高纬度的组件抽象往往性价比很低，不建议大家去做。 2.3、基础层基础层包含两个部分，第一是接口定义，第二是技术组件。 2.3.1、接口定义接口定义是按照不同的技术框架，同时结合业务需要，设计出合理的接口，对于业务组件来说，它们只会感知技术接口，而不会去感知技术实现，我们也不应该将具体的技术细节向上暴露，这也就是所谓的面向接口编程。技术接口往往是业务与技术之间的桥梁，接口本身是含有业务含义的，最常见的就是DAO接口，我们设计DAO接口的时候，不会设计成insert、update、query这样业务无关的接口，而是设计成insertUser，updateUserById等等和业务相关的接口，同样的道理，设计缓存接口的时候，也不能设计成put、get这样的接口，而应该设计成cacheUser，deprecateUser这样的接口。 2.3.2、技术组件单机系统的技术组件一般来说分两种，一种是通用的技术组件，比如：数据存储、缓存、消息和调度任务、事务、锁。一种是基础设施，比如spring容器，tomcat容器。下面稍微谈谈通用技术组件。 数据存储：数据存储包括关系型数据库、非关系型数据库以及文件存储系统。关系型数据库，比如MySQL，适合存放绝大部分业务数据。非关系型数据库，比如hbase，可以存放历史日志，也可以对历史的MySQL数据进行归档。文件存储系统，一般都是基于Linux文件系统，比如图片、html文件等等，也有基于HDFS的，用于大数据分析。 缓存：缓存按响应时间分，可以分为纳秒级缓存，毫秒级缓存和百毫秒级缓存。纳秒级缓存就是一般的基于本地内存的缓存，比如encache，毫秒级缓存一般是集中式的内存缓存，比如memcache，由于访问时远程调用，因此响应时间会延长到几毫秒，百毫秒级缓存一般是集中式可持久化的缓存，比如redis，由于存在远程访问以及缓存击穿导致的读取持久化记录，它的响应时间会更长些，到几十甚至上百毫秒。单机系统一般用本地内存缓存就够了，当缓存被击穿的时候，直接访问数据库。 消息和调度任务：消息和调度任务本质都是一种异步化的手段，区别在于消息无法控制异步的时间，而调度任务可以。一般，消息发送出去后，监听消息的系统会立即收到消息，从而立即触发业务逻辑的执行，而调度任务则会按照调度规则，一次或者多次的执行业务逻辑。单机系统中消息和调度任务用到的比较少，在做日志监控的时候可能会用到消息，在进行数据报表统计的时候可能会用到调度任务。 事务：事务本质都是基于数据库去实现的，单机系统的事务就是依赖数据库的事务，我们可以使用spring-tx的事务模板进行事务操作，在业务逻辑开发中，一定要把握事务的大小，建议把业务比较紧密的一堆数据库操作放在一个事务里，不要随意的为每个方法都开启事务。 锁：单机系统中主要用到两种锁：乐观锁和悲观锁。乐观锁依靠在数据库的业务表加版本字段来实现，每次更新都会去判断版本是否变化，如果变化则需要重试，这种锁的粒度比较小。悲观锁是基于JDK的Lock接口的，对一个业务流程进行加锁和释放锁的操作，锁的粒度比较粗。 转自《从零开始搭建一个通用的业务技术架构，这套架构绝了！》","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://liangyuanzheng.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"《生死疲劳》人物关系","slug":"《生死疲劳》人物关系","date":"2022-12-10T08:59:56.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"《生死疲劳》人物关系.html","link":"","permalink":"https://liangyuanzheng.com/%E3%80%8A%E7%94%9F%E6%AD%BB%E7%96%B2%E5%8A%B3%E3%80%8B%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB.html","excerpt":"","text":"","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"同时配置多个 git 账号","slug":"同时配置多个 git 账号","date":"2022-12-10T08:54:39.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"同时配置多个 git 账号.html","link":"","permalink":"https://liangyuanzheng.com/%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%20git%20%E8%B4%A6%E5%8F%B7.html","excerpt":"","text":"多个账号配置 ssh 生成公私钥 12ssh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/work_id_rsassh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/github_id_rsa 公钥（*.pub）copy到平台上 12cat ~/.ssh/work_id_rsa.pubcat ~/.ssh/github_id_rsa.pub 修改config文件 12345678Host work.domain.com HostName work.domain.com User git IdentityFile ~/.ssh/work_id_rsaHost github.com HostName github.com IdentityFile ~/.ssh/github_id_rsa 测试配置结果12ssh -T git@github.comHi LeungGeorge! You've successfully authenticated, but GitHub does not provide shell access. hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"},{"name":"git","slug":"git","permalink":"https://liangyuanzheng.com/tags/git/"}]},{"title":"《西厢记》摘录","slug":"《西厢记》摘录","date":"2022-12-10T08:52:18.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"《西厢记》摘录.html","link":"","permalink":"https://liangyuanzheng.com/%E3%80%8A%E8%A5%BF%E5%8E%A2%E8%AE%B0%E3%80%8B%E6%91%98%E5%BD%95.html","excerpt":"","text":"人值残春蒲郡东，门掩重关萧寺中；花落水流红，闲愁万种，无语怨东风。 萤窗雪案，刮垢磨光，学成满腹文章，尚在湖海飘零，何日得遂大志也呵！万金宝剑藏秋水，满马春愁压绣鞍。 才高难入俗人机，时乖不遂男儿愿。空雕虫篆刻，缀断简残编。 呖呖莺声花外啭，行一步可人怜。解舞腰肢娇又软，千般袅娜，万般旖旎，似垂柳晚风前。 兰麝香仍在，佩环声渐远。东风摇曳垂杨线，游丝牵惹桃花片，珠帘掩映芙蓉面。 “十年不识君王面，始信婵娟解解误人”。 怪黄莺儿作对，怨粉蝶儿成双。 院宇深，枕簟凉，一灯孤影摇书幌。纵然酬得今生志，着甚支吾此夜长。睡不着如翻掌，少可有一万声长吁短叹，五千遍捣枕捶床。 闲寻方丈高僧语，闷对西厢皓月吟。 似汀陵妃子，斜倚舜庙朱扉；如玉殿嫦娥，微现蟾宫素影。 月色溶溶夜，花阴寂寂春；如何临皓魄，不见月中人？ 方信道“惺惺的自古惜惺惺“。 有心争似无心好，多情却被无情恼。劳攘了一宵，月儿沈，钟儿响，鸡儿叫。 好句有情怜夜月，落花无语怨东风。 地生连理木，水出并头莲。 才子多情，佳人薄幸。 其声壮，似铁骑刀枪冗冗；其声幽，似落花流水溶溶；其声高，似风清月朗鹤唳空；其声低，似听儿女语，小窗中，喁喁。 有美人兮，见之不忘。一日不见兮，思之如狂。凤飞翩翩兮，四海求凰。无奈佳人兮，不在东墙。张弦代语兮，欲诉衷肠。何时见许兮，慰我彷徨？愿言配德兮，携手相将！不得于飞兮，使我沦亡。 沈约病多般，宋玉愁无二。 且将宋玉风流策，寄与蒲东窈窕娘。 悲欢聚散一杯酒，南北东西万里。 碧云天，黄花地，西风紧。北雁南飞。晓来谁染霜林醉？总是离人泪。 青霄有路终须到，金榜无名誓不还。 淋漓襟袖啼红泪，比司马青衫更湿。伯劳东去燕西飞，未登程先问归期。 你休忧”文齐福不齐“，我则怕你”停妻再娶妻“。休要”一春鱼雁无消息“！我这里青鸾有信频须寄，你却休”金榜无名誓不归“。此一节君须记，若见了那异乡花草，再休似此处栖迟。 洛阳才子善属文，火急修书信。白马将军到时分，灭了烟尘。夫人小姐都心顺，则为他“威而不猛”，“言而有信”，因此上“不敢慢于人“。","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"代码评审","slug":"代码评审","date":"2022-12-08T02:18:00.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"代码评审.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1.html","excerpt":"","text":"代码评审的流程谷歌的一个典型代码评审流程包括以下步骤： 代码评审的好处设计良好的代码评审流程和认真对待代码评审的文化提供了以下好处： 检查代码正确性 确保代码变更能够被其他工程师理解 增强整个代码库的一致性 心理上促进团队的责任感 知识共享 提供代码评审本身的历史记录 代码评审最佳实践 礼貌而专业 小的变更 清晰的变更描述 评审者数量最少化 尽可能自动化 代码评审类型不同类型的代码变更要求对评审过程的务个方 面给予不同程度的关注。 绿地代码评审和新特性开发 全新代码，即所谓的绿地评审。 绿地评审是评估代码是否经得起时间考验的最重要时间。 绿地评审应确保API与商定的设计相匹配，并经过充分测试。 行为变更、改过和优化 即，对现有代码的修改。 消除无效或过时的代码是改进整体代码健康状况的最好办法之一。 缺陷修复和回滚 缺陷修复应该只关注修复指定的缺陷，不要去试图解决其他问题。 变更尽可能小和原子化。 重构和大规模变更","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"代码评审","slug":"代码评审","permalink":"https://liangyuanzheng.com/tags/%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1/"},{"name":"Google 软件工程","slug":"google-软件工程","permalink":"https://liangyuanzheng.com/tags/google-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"author":"七点一刻"},{"title":"敬畏生命, 敬畏规章, 敬畏职责！","slug":"敬畏生命-敬畏规章-敬畏职责！","date":"2021-04-04T02:52:35.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"敬畏生命-敬畏规章-敬畏职责！.html","link":"","permalink":"https://liangyuanzheng.com/%E6%95%AC%E7%95%8F%E7%94%9F%E5%91%BD-%E6%95%AC%E7%95%8F%E8%A7%84%E7%AB%A0-%E6%95%AC%E7%95%8F%E8%81%8C%E8%B4%A3%EF%BC%81.html","excerpt":"","text":"","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"梦想就是那种让你感到坚持就是幸福的东西","slug":"梦想就是那种让你感到坚持就是幸福的东西","date":"2021-04-04T02:45:16.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"梦想就是那种让你感到坚持就是幸福的东西.html","link":"","permalink":"https://liangyuanzheng.com/%E6%A2%A6%E6%83%B3%E5%B0%B1%E6%98%AF%E9%82%A3%E7%A7%8D%E8%AE%A9%E4%BD%A0%E6%84%9F%E5%88%B0%E5%9D%9A%E6%8C%81%E5%B0%B1%E6%98%AF%E5%B9%B8%E7%A6%8F%E7%9A%84%E4%B8%9C%E8%A5%BF.html","excerpt":"","text":"","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"行有不得, 反求诸己","slug":"行有不得-反求诸己","date":"2021-04-03T02:44:25.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"行有不得-反求诸己.html","link":"","permalink":"https://liangyuanzheng.com/%E8%A1%8C%E6%9C%89%E4%B8%8D%E5%BE%97-%E5%8F%8D%E6%B1%82%E8%AF%B8%E5%B7%B1.html","excerpt":"","text":"","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"什么读书方法效果最好？","slug":"什么读书方法效果最好？","date":"2021-02-03T01:56:38.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"什么读书方法效果最好？.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BB%80%E4%B9%88%E8%AF%BB%E4%B9%A6%E6%96%B9%E6%B3%95%E6%95%88%E6%9E%9C%E6%9C%80%E5%A5%BD%EF%BC%9F.html","excerpt":"","text":"苏轼在被贬黄州期间，一位朋友前来拜访，等了很长时间才得以见面。苏轼不好意思地说，自己刚才在做每天功课，耽误了时间才有失远迎。这位朋友很惊讶，询问每天做的是什么功课。苏轼回答，自己正在学习《汉书》，每天边读边手抄。朋友更加震惊，当时苏轼已颇具盛名，为何还用手抄这种费时费力的方法来学经典呢？ 苏轼解释，自己读《汉书》一共手抄了三遍，第一遍每段抄三个字作为标记，第二遍减少为抄两个字，第三遍只需抄一个字就行。苏轼拿来所抄书稿给朋友过目，并说自己可以对照这些单字，背诵出对应的段落。朋友尝试发问几次，发现苏轼背诵得丝毫不差，对他佩服得五体投地。 ——摘自什么读书方法效果最好？","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://liangyuanzheng.com/tags/reading/"}]},{"title":"如何创建一个npm包","slug":"如何创建一个npm包","date":"2020-02-04T06:58:00.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"如何创建一个npm包.html","link":"","permalink":"https://liangyuanzheng.com/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnpm%E5%8C%85.html","excerpt":"","text":"注册npm账号去 官网 注册一个账号，后面发布npm包时会用到。 创建包1➜ mkdir grimoire-tool &amp;&amp; cd grimoire-tool 初始化包 带上 –yes 会直接创建一默认的 package.json ，后面可以直接修改文件内容。 1➜ npm init 或者 1➜ npm init --yes 我的 package.json 文件： 12345678910111213141516171819202122232425&#123; \"name\": \"grimoire-tool\", \"version\": \"1.0.0\", \"description\": \"魔法书的工具包 grimoire-tool\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/LeungGeorge/grimoire-tool.git\" &#125;, \"keywords\": [ \"魔法书的工具包\" ], \"author\": \"liangyuanzheng\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/LeungGeorge/grimoire-tool/issues\" &#125;, \"bin\": &#123; \"grimoire-tool\": \"./bin/grimoire-tool\" &#125;, \"homepage\": \"https://github.com/LeungGeorge/grimoire-tool\"&#125; 编辑包可以看到，我这个包使用的 git 的一个编译产出： 123\"bin\": &#123; \"grimoire-tool\": \"./bin/grimoire-tool\" &#125;, 发布包发布（版本号 v1.0.0 ）： 1➜ npm publish 发布后可以继续打补丁（版本号 v1.0.1 ）： 1➜ npm version patch 查看发布结果123➜ npm search grimoire-toolNAME | DESCRIPTION | AUTHOR | DATE | VERSION | KEYWORDSgrimoire-tool | 魔法书工具包 | =liangyuanzheng | 2020-02-04 | 1.0.2 | 魔法书 工具包 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://liangyuanzheng.com/tags/npm/"}]},{"title":"golang 令牌桶限流器 rate","slug":"golang-令牌桶限流器-rate","date":"2020-02-01T14:22:04.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"golang-令牌桶限流器-rate.html","link":"","permalink":"https://liangyuanzheng.com/golang-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81%E5%99%A8-rate.html","excerpt":"","text":"令牌桶算法令牌桶算法(Token Bucket)随着时间流逝, 系统会按恒定1&#x2F;QPS时间间隔(如果QPS&#x3D;100, 则间隔是10ms)往桶里加入Token, 如果桶已经满了就不再加了。新请求来临时, 会各自拿走一个Token, 如果没有Token可拿了就阻塞或者拒绝服务. 限流器 rate 原理与上图的令牌桶类似。 限流器 rate 的用法和实现逻辑官方代码库 github.com&#x2F;golang&#x2F;time，限流器主要用来限制请求速率，保护服务，防止服务过载。 NewLimiter1func NewLimiter(r Limit, b int) *Limiter 构造限流器，参数说明： r : 令牌桶每秒可以产生 r 个 token。 b : 令牌桶的大小。 Reserve&#x2F;ReserveN 获取一个预定对象 r，表示调用者需要等待的相关信息（如，是否可以处理、何时可以处理等等），调用者可根据 r 自行决定处理逻辑。 如下 case 返回 false：1). 请求令牌数 n 超过桶容量 12func (lim *Limiter) Reserve() *Reservationfunc (lim *Limiter) ReserveN(now time.Time, n int) *Reservation 用法： 12345678// Usage example:r := lim.ReserveN(time.Now(), 1)if !r.OK() &#123; // Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ? return&#125;time.Sleep(r.Delay())// Act() 实现逻辑 Allow&#x2F;AllowN 截止到某一时刻，是否可以从桶中获取 N 个令牌。如果可以，消费 n 个 token 并返回 true；否则返回 false。 按照频率限制执行，超过频率限制时丢弃或者跳过 12func (lim *Limiter) Allow()func (lim *Limiter) AllowN(now time.Time, n int) bool Allow 是 AllowN(time. Now(), 1) 的简写。 实现逻辑实现逻辑与 ReserveN 相同，仅使用预定对象的成功状态，即： 1return lim.reserveN(now, n, 0).ok Wait&#x2F;WaitN 阻塞等待，可自定义等待时间（超时自动取消）。 如下 case 会报 error：1). 请求令牌数 n 超过桶容量2). 请求被取消3). 等待超时 12func (lim *Limiter) Wait(ctx context.Context) (err error)func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) Wait 是 WaitN(ctx, 1) 的简写。 实现逻辑 SetLimit&#x2F;SetLimitAt令牌桶限流频率设置。 SetBurst&#x2F;SetBurstAt令牌桶容量设置。 引用限流算法之漏桶算法、令牌桶算法 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"令牌桶","slug":"令牌桶","permalink":"https://liangyuanzheng.com/tags/%E4%BB%A4%E7%89%8C%E6%A1%B6/"},{"name":"限流器","slug":"限流器","permalink":"https://liangyuanzheng.com/tags/%E9%99%90%E6%B5%81%E5%99%A8/"},{"name":"rate","slug":"rate","permalink":"https://liangyuanzheng.com/tags/rate/"}]},{"title":"你应该知道的伟大程序架构","slug":"你应该知道的伟大程序架构","date":"2019-11-02T13:59:06.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"你应该知道的伟大程序架构.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BC%9F%E5%A4%A7%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84.html","excerpt":"","text":"当一个程序很容易地运行,有可能在同样设备上也有其它程序运行。但是，如果所有正在运行的程序需要内部通讯怎么办？这是由该程序的架构来解决这个问题。一个程序架构是一种设计的结构,在设计时就要考虑相互通讯方案，两个程序通讯也许中间需要经历许多相互等待的阶段，因此，当你使用你喜欢的任何语言编写这种程序时，必须要记住，程序必须遵循的架构，如线性编程(顺序编程)，也就是说所有的步骤要遵循一个接一个的顺序，这当然会付出执行时间的代价。另一方面，当所有的步骤都是并行执行，并在最后一步全部完成时，所需的累积(cumulative )时间是相当少。因此，最好的架构是至少有一个累积等待阶段。 但是，这并不意味着线性编程就没有用而总是使用并行架构。重要的是要知道最好的几种可能的架构，这样您可以轻松地创建一个适合所有要求的优化方案。 Clean架构外圈的层次可以依赖内层，反之不可以，内圈核心的实体代表业务，不可以依赖其所处的技术环境。 The Clean Architecture DCI架构本站中文DCI架构专题，DCI代表Data, Context, Interaction。 DCI模型架构 DDD&#x2F;CQRS 领域驱动设计Domain Code Design（DDD）领域驱动设计。DDD中有工厂和仓库来管理领域模型，前者主要用于创建，而后者则用于存储。这就表明在DDD中是默认将读写分离的，DDD似乎就天生和CQRS有着无缝的链接。 CQRS往往要求数据库进行读写分离，具体来说，所有的更新操作均无返回值(void)，而读操作才返回对应的值。 浅析DDD(领域驱动设计)领域驱动设计(DDD) Command Query Responsibility Segregation（CQRS）命令（增删改）和查询的责任分离。 图片摘自微信公众号：coderising Command: 改变对象或者系统的状态。触发命令是唯一改变系统状态的方法。命令负责引起所有的对系统的改变。如果没有命令，系统状态保持不变！ Query: 返回结果，并不会改变对象的状态。查询是一个读操作。它读取系统的状态，过滤，聚总，以及转换数据，并将其转化为最有用的格式。它可以执行多次，而且不会影响系统的状态。 Command 命令端由于读取端已经被分开，doamin(也就是写入端)只关注处理命令。现在的领域对象对象不再需要公开的内部状态。储存库除了除了GetById只有几个查询方法。 Query 端查询将只包含获取数据的方法。从架构的角度来看，这些将是在屏幕上显示客户消费返回DTOs(数据传递对象)的所有方法。DTOs直接来自使用一个read层的数据存储。在某些情况下，它可能是一个非常痛苦的过程，尤其是当要求复杂的DTO。 使用CQRS你能避免这些预测。相反，它是可以引入一个新的DTO的投影方式。您可以绕过域模型和DTO的直接使用读出层从数据存储。当一个应用程序请求数据，这可能是由一个单向的调用read层返回单个包含所有需要的数据DTO。 CQRSPattern: Command Query Responsibility Segregation (CQRS)领域驱动设计(DDD:Domain-Driven Design) 六边形架构 允许应用程序都是由用户，程序，自动化测试或批处理脚本驱动的，在事件驱动和数据库环境下被开发和隔离测试。一个事件从外面世界到达一个端口，特定技术的适配器将其转换成可用的程序调用或消息，并将其传递给应用程序。该应用程序是可以无需了解输入设备的性质(调用者是哪个)。当应用程序有结果需要发出时，它会通过一个端口适配器发送它，这个适配器会创建接收技术（人类或自动）所需的相应信号。该应用程序与在它各方面的适配器形成语义良性互动，但是实际上不知道适配器的另一端的谁在处理任务。 这个有点懵逼！ 你应该知道的四种优秀架构 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"cqrs","slug":"cqrs","permalink":"https://liangyuanzheng.com/tags/cqrs/"},{"name":"微服务","slug":"微服务","permalink":"https://liangyuanzheng.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"架构","slug":"架构","permalink":"https://liangyuanzheng.com/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"12306是如何支撑百万qps的？","slug":"12306是如何支撑百万qps的？","date":"2019-10-27T04:48:32.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"12306是如何支撑百万qps的？.html","link":"","permalink":"https://liangyuanzheng.com/12306%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%92%91%E7%99%BE%E4%B8%87qps%E7%9A%84%EF%BC%9F.html","excerpt":"每到节假日期间，一二线城市返乡、外出游玩的人们几乎都面临着一个问题：抢火车票！ 收藏了，一点一点拜读。","text":"每到节假日期间，一二线城市返乡、外出游玩的人们几乎都面临着一个问题：抢火车票！ 收藏了，一点一点拜读。 12306 抢票，极限并发带来的思考虽然现在大多数情况下都能订到票，但是放票瞬间即无票的场景，相信大家都深有体会。 尤其是春节期间，大家不仅使用 12306，还会考虑“智行”和其他的抢票软件，全国上下几亿人在这段时间都在抢票。 “12306 服务”承受着这个世界上任何秒杀系统都无法超越的 QPS，上百万的并发再正常不过了！ 笔者专门研究了一下“12306”的服务端架构，学习到了其系统设计上很多亮点，在这里和大家分享一下并模拟一个例子：如何在 100 万人同时抢 1 万张火车票时，系统提供正常、稳定的服务。 Github 代码仓库 大型高并发系统架构高并发的系统架构都会采用分布式集群部署，服务上层有着层层负载均衡，并提供各种容灾手段（双火机房、节点容错、服务器灾备等）保证系统的高可用，流量也会根据不同的负载能力和配置策略均衡到不同的服务器上。 下边是一个简单的示意图： 负载均衡简介 上图中描述了用户请求到服务器经历了三层的负载均衡，下边分别简单介绍一下这三种负载均衡。 ①OSPF（开放式最短链路优先）是一个内部网关协议（Interior Gateway Protocol，简称 IGP） OSPF 通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF 会自动计算路由接口上的 Cost 值，但也可以通过手工指定该接口的 Cost 值，手工指定的优先于自动计算的值。 OSPF 计算的 Cost，同样是和接口带宽成反比，带宽越高，Cost 值越小。到达目标相同 Cost 值的路径，可以执行负载均衡，最多 6 条链路同时执行负载均衡。 ②LVS （Linux Virtual Server） 它是一种集群（Cluster）技术，采用 IP 负载均衡技术和基于内容请求分发技术。 调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。 ③Nginx 想必大家都很熟悉了，是一款非常高性能的 HTTP 代理&#x2F;反向代理服务器，服务开发中也经常使用它来做负载均衡。 Nginx 实现负载均衡的方式主要有三种： 轮询 加权轮询 IP Hash 轮询 下面我们就针对 Nginx 的加权轮询做专门的配置和测试。 Nginx 加权轮询的演示Nginx 实现负载均衡通过 Upstream 模块实现，其中加权轮询的配置是可以给相关的服务加上一个权重值，配置的时候可能根据服务器的性能、负载能力设置相应的负载。 下面是一个加权轮询负载的配置，我将在本地的监听 3001-3004 端口，分别配置 1，2，3，4 的权重： 123456789101112131415#配置负载均衡 upstream load_rule &#123; server 127.0.0.1:3001 weight=1; server 127.0.0.1:3002 weight=2; server 127.0.0.1:3003 weight=3; server 127.0.0.1:3004 weight=4; &#125; ... server &#123; listen 80; server_name load_balance.com www.load_balance.com; location / &#123; proxy_pass http://load_rule; &#125;&#125; 我在本地 &#x2F;etc&#x2F;hosts 目录下配置了 www.load_balance.com 的虚拟域名地址。 接下来使用 Go 语言开启四个 HTTP 端口监听服务，下面是监听在 3001 端口的 Go 程序，其他几个只需要修改端口即可： 12345678910111213141516171819202122232425262728package mainimport ( \"net/http\" \"os\" \"strings\")func main() &#123; http.HandleFunc(\"/buy/ticket\", handleReq) http.ListenAndServe(\":3001\", nil)&#125;//处理请求函数,根据请求将响应结果信息写入日志func handleReq(w http.ResponseWriter, r *http.Request) &#123; failedMsg := \"handle in port:\" writeLog(failedMsg, \"./stat.log\")&#125;//写入日志func writeLog(msg string, logPath string) &#123; fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) defer fd.Close() content := strings.Join([]string&#123;msg, \"\"&#125;, \"3001\") buf := []byte(content) fd.Write(buf)&#125; 我将请求的端口日志信息写到了 .&#x2F;stat.log 文件当中，然后使用 AB 压测工具做压测： 1ab -n 1000 -c 100 http://www.load_balance.com/buy/ticket 统计日志中的结果，3001-3004 端口分别得到了 100、200、300、400 的请求量。 这和我在 Nginx 中配置的权重占比很好的吻合在了一起，并且负载后的流量非常的均匀、随机。 具体的实现大家可以参考 Nginx 的 Upsteam 模块实现源码，这里推荐一篇文章《Nginx 中 Upstream 机制的负载均衡》： 1https://www.kancloud.cn/digest/understandingnginx/202607 秒杀抢购系统选型回到我们最初提到的问题中来：火车票秒杀系统如何在高并发情况下提供正常、稳定的服务呢？ 从上面的介绍我们知道用户秒杀流量通过层层的负载均衡，均匀到了不同的服务器上，即使如此，集群中的单机所承受的 QPS 也是非常高的。如何将单机性能优化到极致呢？ 要解决这个问题，我们就要想明白一件事：通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段。 我们系统要做的事情是要保证火车票订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发。 这三个阶段的先后顺序该怎么分配才更加合理呢？我们来分析一下： 下单减库存 当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。 这种顺序是我们一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。 但是这样也会产生一些问题： 在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的。 如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制 IP 和用户的购买订单数量，这也不算是一个好方法。 支付减库存 如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单。 当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘 IO。 预扣库存 从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库 IO。 那么有没有一种不需要直接操作数据库 IO 的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？ 我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。 订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费队列中处理，订单量比较少的情况下，生成订单非常快，用户几乎不用排队。 扣库存的艺术从上面的分析可知，显然预扣库存的方案最合理。我们进一步分析扣库存的细节，这里还有很大的优化空间，库存存在哪里？怎样保证高并发下，正确的扣库存，还能快速的响应用户请求？ 在单机低并发情况下，我们实现扣库存通常是这样的： 为了保证扣库存和生成订单的原子性，需要采用事务处理，然后取库存判断、减库存，最后提交事务，整个流程有很多 IO，对数据库的操作又是阻塞的。 这种方式根本不适合高并发的秒杀系统。接下来我们对单机扣库存的方案做优化：本地扣库存。 我们把一定的库存量分配到本地机器，直接在内存中减库存，然后按照之前的逻辑异步创建订单。 改进过之后的单机系统是这样的： 这样就避免了对数据库频繁的 IO 操作，只在内存中做运算，极大的提高了单机抗并发的能力。 但是百万的用户请求量单机是无论如何也抗不住的，虽然 Nginx 处理网络请求使用 Epoll 模型，c10k 的问题在业界早已得到了解决。 但是 Linux 系统下，一切资源皆文件，网络请求也是这样，大量的文件描述符会使操作系统瞬间失去响应。 上面我们提到了 Nginx 的加权均衡策略，我们不妨假设将 100W 的用户请求量平均均衡到 100 台服务器上，这样单机所承受的并发量就小了很多。 然后我们每台机器本地库存 100 张火车票，100 台服务器上的总库存还是 1 万，这样保证了库存订单不超卖，下面是我们描述的集群架构： 问题接踵而至，在高并发情况下，现在我们还无法保证系统的高可用，假如这 100 台服务器上有两三台机器因为扛不住并发的流量或者其他的原因宕机了。那么这些服务器上的订单就卖不出去了，这就造成了订单的少卖。 要解决这个问题，我们需要对总订单量做统一的管理，这就是接下来的容错方案。服务器不仅要在本地减库存，另外要远程统一减库存。 有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“Buffer 库存”用来防止机器中有机器宕机的情况。 我们结合下面架构图具体分析一下： 我们采用 Redis 存储统一库存，因为 Redis 的性能非常高，号称单机 QPS 能抗 10W 的并发。 在本地减库存以后，如果本地有订单，我们再去请求 Redis 远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示，这样也能有效的保证订单不会超卖。 当机器中有机器宕机时，因为每个机器上有预留的 Buffer 余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。 Buffer 余票设置多少合适呢，理论上 Buffer 设置的越多，系统容忍宕机的机器数量就越多，但是 Buffer 设置的太大也会对 Redis 造成一定的影响。 虽然 Redis 内存数据库抗并发能力非常高，请求依然会走一次网络 IO，其实抢票过程中对 Redis 的请求次数是本地库存和 Buffer 库存的总量。 因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑。 这在一定程度上也避免了巨大的网络请求量把 Redis 压跨，所以 Buffer 值设置多少，需要架构师对系统的负载能力做认真的考量。 代码演示Go 语言原生为并发设计，我采用 Go 语言给大家演示一下单机抢票的具体流程。 初始化工作Go 包中的 Init 函数先于 Main 函数执行，在这个阶段主要做一些准备性工作。 我们系统需要做的准备工作有：初始化本地库存、初始化远程 Redis 存储统一库存的 Hash 键值、初始化 Redis 连接池。 另外还需要初始化一个大小为 1 的 Int 类型 Chan，目的是实现分布式锁的功能。 也可以直接使用读写锁或者使用 Redis 等其他的方式避免资源竞争，但使用 Channel 更加高效，这就是 Go 语言的哲学：不要通过共享内存来通信，而要通过通信来共享内存。 Redis 库使用的是 Redigo，下面是代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647...//localSpike包结构体定义package localSpiketype LocalSpike struct &#123; LocalInStock int64 LocalSalesVolume int64&#125;...//remoteSpike对hash结构的定义和redis连接池package remoteSpike//远程订单存储健值type RemoteSpikeKeys struct &#123; SpikeOrderHashKey string //redis中秒杀订单hash结构key TotalInventoryKey string //hash结构中总订单库存key QuantityOfOrderKey string //hash结构中已有订单数量key&#125;//初始化redis连接池func NewPool() *redis.Pool &#123; return &amp;redis.Pool&#123; MaxIdle: 10000, MaxActive: 12000, // max number of connections Dial: func() (redis.Conn, error) &#123; c, err := redis.Dial(\"tcp\", \":6379\") if err != nil &#123; panic(err.Error()) &#125; return c, err &#125;, &#125;&#125;...func init() &#123; localSpike = localSpike2.LocalSpike&#123; LocalInStock: 150, LocalSalesVolume: 0, &#125; remoteSpike = remoteSpike2.RemoteSpikeKeys&#123; SpikeOrderHashKey: \"ticket_hash_key\", TotalInventoryKey: \"ticket_total_nums\", QuantityOfOrderKey: \"ticket_sold_nums\", &#125; redisPool = remoteSpike2.NewPool() done = make(chan int, 1) done &lt;- 1&#125; 本地扣库存和统一扣库存本地扣库存逻辑非常简单，用户请求过来，添加销量，然后对比销量是否大于本地库存，返回 Bool 值： 123456package localSpike//本地扣库存,返回bool值func (spike *LocalSpike) LocalDeductionStock() bool&#123; spike.LocalSalesVolume = spike.LocalSalesVolume + 1 return spike.LocalSalesVolume &lt; spike.LocalInStock&#125; 注意这里对共享数据 LocalSalesVolume 的操作是要使用锁来实现的，但是因为本地扣库存和统一扣库存是一个原子性操作，所以在最上层使用 Channel 来实现，这块后边会讲。 统一扣库存操作 Redis，因为 Redis 是单线程的，而我们要实现从中取数据，写数据并计算一些列步骤，我们要配合 Lua 脚本打包命令，保证操作的原子性： 1234567891011121314151617181920212223package remoteSpike......const LuaScript = ` local ticket_key = KEYS[1] local ticket_total_key = ARGV[1] local ticket_sold_key = ARGV[2] local ticket_total_nums = tonumber(redis.call('HGET', ticket_key, ticket_total_key)) local ticket_sold_nums = tonumber(redis.call('HGET', ticket_key, ticket_sold_key)) -- 查看是否还有余票,增加订单数量,返回结果值 if(ticket_total_nums &gt;= ticket_sold_nums) then return redis.call('HINCRBY', ticket_key, ticket_sold_key, 1) end return 0`//远端统一扣库存func (RemoteSpikeKeys *RemoteSpikeKeys) RemoteDeductionStock(conn redis.Conn) bool &#123; lua := redis.NewScript(1, LuaScript) result, err := redis.Int(lua.Do(conn, RemoteSpikeKeys.SpikeOrderHashKey, RemoteSpikeKeys.TotalInventoryKey, RemoteSpikeKeys.QuantityOfOrderKey)) if err != nil &#123; return false &#125; return result != 0&#125; 我们使用 Hash 结构存储总库存和总销量的信息，用户请求过来时，判断总销量是否大于库存，然后返回相关的 Bool 值。 在启动服务之前，我们需要初始化 Redis 的初始库存信息： 1hmset ticket_hash_key \"ticket_total_nums\" 10000 \"ticket_sold_nums\" 0 响应用户信息我们开启一个 HTTP 服务，监听在一个端口上： 123456package main...func main() &#123; http.HandleFunc(\"/buy/ticket\", handleReq) http.ListenAndServe(\":3005\", nil)&#125; 上面我们做完了所有的初始化工作，接下来 handleReq 的逻辑非常清晰，判断是否抢票成功，返回给用户信息就可以了。 12345678910111213141516171819202122232425262728package main//处理请求函数,根据请求将响应结果信息写入日志func handleReq(w http.ResponseWriter, r *http.Request) &#123; redisConn := redisPool.Get() LogMsg := \"\" &lt;-done //全局读写锁 if localSpike.LocalDeductionStock() &amp;&amp; remoteSpike.RemoteDeductionStock(redisConn) &#123; util.RespJson(w, 1, \"抢票成功\", nil) LogMsg = LogMsg + \"result:1,localSales:\" + strconv.FormatInt(localSpike.LocalSalesVolume, 10) &#125; else &#123; util.RespJson(w, -1, \"已售罄\", nil) LogMsg = LogMsg + \"result:0,localSales:\" + strconv.FormatInt(localSpike.LocalSalesVolume, 10) &#125; done &lt;- 1 //将抢票状态写入到log中 writeLog(LogMsg, \"./stat.log\")&#125;func writeLog(msg string, logPath string) &#123; fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644) defer fd.Close() content := strings.Join([]string&#123;msg, \"\"&#125;, \"\") buf := []byte(content) fd.Write(buf)&#125; 前边提到我们扣库存时要考虑竞态条件，我们这里是使用 Channel 避免并发的读写，保证了请求的高效顺序执行。我们将接口的返回信息写入到了 .&#x2F;stat.log 文件方便做压测统计。 单机服务压测开启服务，我们使用 AB 压测工具进行测试： 1ab -n 10000 -c 100 http://127.0.0.1:3005/buy/ticket 下面是我本地低配 Mac 的压测信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253This is ApacheBench, Version 2.3 &lt;$Revision: 1826891 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 127.0.0.1 (be patient)Completed 1000 requestsCompleted 2000 requestsCompleted 3000 requestsCompleted 4000 requestsCompleted 5000 requestsCompleted 6000 requestsCompleted 7000 requestsCompleted 8000 requestsCompleted 9000 requestsCompleted 10000 requestsFinished 10000 requestsServer Software:Server Hostname: 127.0.0.1Server Port: 3005Document Path: /buy/ticketDocument Length: 29 bytesConcurrency Level: 100Time taken for tests: 2.339 secondsComplete requests: 10000Failed requests: 0Total transferred: 1370000 bytesHTML transferred: 290000 bytesRequests per second: 4275.96 [#/sec] (mean)Time per request: 23.387 [ms] (mean)Time per request: 0.234 [ms] (mean, across all concurrent requests)Transfer rate: 572.08 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 8 14.7 6 223Processing: 2 15 17.6 11 232Waiting: 1 11 13.5 8 225Total: 7 23 22.8 18 239Percentage of the requests served within a certain time (ms) 50% 18 66% 24 75% 26 80% 28 90% 33 95% 39 98% 45 99% 54 100% 239 (longest request) 根据指标显示，我单机每秒就能处理 4000+ 的请求，正常服务器都是多核配置，处理 1W+ 的请求根本没有问题。 而且查看日志发现整个服务过程中，请求都很正常，流量均匀，Redis 也很正常： 1234567891011121314//stat.log...result:1,localSales:145result:1,localSales:146result:1,localSales:147result:1,localSales:148result:1,localSales:149result:1,localSales:150result:0,localSales:151result:0,localSales:152result:0,localSales:153result:0,localSales:154result:0,localSales:156... 总结回顾总体来说，秒杀系统是非常复杂的。我们这里只是简单介绍模拟了一下单机如何优化到高性能，集群如何避免单点故障，保证订单不超卖、不少卖的一些策略，完整的订单系统还有订单进度的查看，每台服务器上都有一个任务，定时的从总库存同步余票和库存信息展示给用户，还有用户在订单有效期内不支付，释放订单，补充到库存等等。 我们实现了高并发抢票的核心逻辑，可以说系统设计的非常的巧妙，巧妙的避开了对 DB 数据库 IO 的操作。 对 Redis 网络 IO 的高并发请求，几乎所有的计算都是在内存中完成的，而且有效的保证了不超卖、不少卖，还能够容忍部分机器的宕机。 我觉得其中有两点特别值得学习总结： ① 负载均衡，分而治之 通过负载均衡，将不同的流量划分到不同的机器上，每台机器处理好自己的请求，将自己的性能发挥到极致。 这样系统的整体也就能承受极高的并发了，就像工作的一个团队，每个人都将自己的价值发挥到了极致，团队成长自然是很大的。 ② 合理的使用并发和异步 自 Epoll 网络架构模型解决了 c10k 问题以来，异步越来越被服务端开发人员所接受，能够用异步来做的工作，就用异步来做，在功能拆解上能达到意想不到的效果。 这点在 Nginx、Node.JS、Redis 上都能体现，他们处理网络请求使用的 Epoll 模型，用实践告诉了我们单线程依然可以发挥强大的威力。 服务器已经进入了多核时代，Go 语言这种天生为并发而生的语言，完美的发挥了服务器多核优势，很多可以并发处理的任务都可以使用并发来解决，比如 Go 处理 HTTP 请求时每个请求都会在一个 Goroutine 中执行。 总之，怎样合理的压榨 CPU，让其发挥出应有的价值，是我们一直需要探索学习的方向。 “12306”是如何支撑百万 QPS 的？ ，收藏了。 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"12306","slug":"12306","permalink":"https://liangyuanzheng.com/tags/12306/"},{"name":"高并发","slug":"高并发","permalink":"https://liangyuanzheng.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}]},{"title":"PyRadio-用于Ubuntu命令行的网络电台播放器","slug":"PyRadio-用于Ubuntu命令行的网络电台播放器","date":"2019-10-26T19:16:23.000Z","updated":"2025-10-27T00:35:41.791Z","comments":true,"path":"PyRadio-用于Ubuntu命令行的网络电台播放器.html","link":"","permalink":"https://liangyuanzheng.com/PyRadio-%E7%94%A8%E4%BA%8EUbuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E7%94%B5%E5%8F%B0%E6%92%AD%E6%94%BE%E5%99%A8.html","excerpt":"","text":"效果图 快捷键 详细快捷键 我是从这里得知这个工具的：https://www.linuxidc.com/Linux/2018-01/150485.htm hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"pyradio","slug":"pyradio","permalink":"https://liangyuanzheng.com/tags/pyradio/"}]},{"title":"SELECT COUNT 那些事儿","slug":"SELECT-COUNT-那些事儿","date":"2019-10-20T06:58:28.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"SELECT-COUNT-那些事儿.html","link":"","permalink":"https://liangyuanzheng.com/SELECT-COUNT-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html","excerpt":"","text":"123456789101、COUNT有几种用法？2、COUNT(字段名)和COUNT(*)的查询结果有什么不同？3、COUNT(1)和COUNT(*)之间有什么不同？4、COUNT(1)和COUNT(*)之间的效率哪个更高？5、为什么《阿里巴巴Java开发手册》建议使用COUNT(*)6、MySQL的MyISAM引擎对COUNT(*)做了哪些优化？7、MySQL的InnoDB引擎对COUNT(*)做了哪些优化？8、上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？9、SELECT COUNT(*) 的时候，加不加where条件有差别吗？10、COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？ 完整版参考原文：不就是SELECT COUNT语句吗 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"mysql","slug":"mysql","permalink":"https://liangyuanzheng.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://liangyuanzheng.com/tags/mysql/"},{"name":"select count","slug":"select-count","permalink":"https://liangyuanzheng.com/tags/select-count/"}]},{"title":"gcache 源码分析","slug":"gcache-源码分析","date":"2019-10-07T07:02:00.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"gcache-源码分析.html","link":"","permalink":"https://liangyuanzheng.com/gcache-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html","excerpt":"","text":"缓存清除策略FIFOFIFO（First In First Out）是一种先进先出的调度策略。先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。 缺点： 判断一个页面置换算法优劣的指标就是缺页率，而 FIFO 算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为 Belady 现象。产生 Belady 现象现象的原因是，FIFO 置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此 FIFO 算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，FIFO 算法的使用场景较少。 LRULRU（Least Recently Used）是一种最近最少使用策略。最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。 LFULRU（Least Frequency Used）是一种最少使用调度策略。最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。 ARCARC 是为了提高缓存效果介于 LRU 和 LFU 设置的算法。借助 LRU 和 LFU 基本思想实现，以获得可用缓存的最佳使用。 OPTOPT（OPTimal replacement）是一种理论上最佳的页面置换算法。淘汰以后永远用不到的数据项；如果没有，则淘汰最久以后再用到的数据项。属于理想型算法，不可能实现（因为无法知道全局的访问序列）。但是，可以最为评价其他算法优劣的参考标准。 gcache 源码分析概述gcache 是基于 Golang 实现的一个内存级 Cache 基础库，支持带失效时间的 Cache。 在这篇文章里，我们将主要从键值对的读写过程，以及数据变化的角度来阐述 gcache 的基本原理，详细操作可参考源代码。 多种缓存策略gcache 目前包括 Simple，LFU（Least Frequency Used），LRU（Least Recently Used），ARC（Adaptive Replacement Cache）四种缓存策略。 Simple：普通缓存策略，随机淘汰。 LRU：Least Recently Used，优先替换最近最少使用的内容。 LFU：Least Frequently Used，优先替换访问次数最少的内容。 ARC：Adaptive Replacement Cache，ARC介于 LRU 和 LFU 之间。 支持回调策略gcache 的回调函数原型（定制化操作），在 cache.go 中定义： 123456789type (trueLoaderFunc func(interface&#123;&#125;) (interface&#123;&#125;, error) // 自动加载回调函数trueLoaderExpireFunc func(interface&#123;&#125;) (interface&#123;&#125;, *time.Duration, error) // 过期回调函数trueEvictedFunc func(interface&#123;&#125;, interface&#123;&#125;) // 淘汰回调函数truePurgeVisitorFunc func(interface&#123;&#125;, interface&#123;&#125;) // 清除所有 key 回调函数trueAddedFunc func(interface&#123;&#125;, interface&#123;&#125;) // 新增 key 回调函数trueDeserializeFunc func(interface&#123;&#125;, interface&#123;&#125;) (interface&#123;&#125;, error) // 反序列化回调函数trueSerializeFunc func(interface&#123;&#125;, interface&#123;&#125;) (interface&#123;&#125;, error) // 序列化回调函数) 计数统计 HitCount：命中次数 MissCount：未命中次数 LookupCount：查找次数（HitCount + MissCount） HitRate：命中率（HitCount &#x2F; LookupCount） 官方代码注解版代码godoc 文档 基本架构![20191024232913.png](&#x2F;images 接口123456789101112131415type Cache interface &#123;trueSet(key, value interface&#123;&#125;) errortrueSetWithExpire(key, value interface&#123;&#125;, expiration time.Duration) errortrueGet(key interface&#123;&#125;) (interface&#123;&#125;, error)trueGetIFPresent(key interface&#123;&#125;) (interface&#123;&#125;, error)trueGetALL(checkExpired bool) map[interface&#123;&#125;]interface&#123;&#125;trueget(key interface&#123;&#125;, onLoad bool) (interface&#123;&#125;, error)trueRemove(key interface&#123;&#125;) booltruePurge()trueKeys(checkExpired bool) []interface&#123;&#125;trueLen(checkExpired bool) inttrueHas(key interface&#123;&#125;) booltruestatsAccessor&#125; CacheBuilderCacheBuilder 用来构造缓存对象，以及各种个性化化配置、策略。由 cache.go&#x2F;CacheBuilder 结构表示： cache.go 中有详细注解。 12345678910111213141516171819202122232425262728// CacheBuilder 构造缓存对象，以及各种个性化化配置、策略。// 构建 cache 时，会赋值给 baseCache 中对应的字段type CacheBuilder struct &#123;trueclock Clock // cache 时钟truetp string // 缓存类型：TYPE_SIMPLE，TYPE_LRU，TYPE_LFU，TYPE_ARCtruesize int // 缓存大小trueloaderExpireFunc LoaderExpireFunc // key 过期时的回调函数trueevictedFunc EvictedFunc // 淘汰 key 时的回调函数truepurgeVisitorFunc PurgeVisitorFunc // 清空缓存所有 key 时的回调函数trueaddedFunc AddedFunc // 新增 key 时的回调函数trueexpiration *time.Duration // 失效时间truedeserializeFunc DeserializeFunc // 序列化回调函数trueserializeFunc SerializeFunc // 反序列化回调函数&#125;// 构建 cachefunc buildCache(c *baseCache, cb *CacheBuilder) &#123;truec.clock = cb.clocktruec.size = cb.sizetruec.loaderExpireFunc = cb.loaderExpireFunctruec.expiration = cb.expirationtruec.addedFunc = cb.addedFunctruec.deserializeFunc = cb.deserializeFunctruec.serializeFunc = cb.serializeFunctruec.evictedFunc = cb.evictedFunctruec.purgeVisitorFunc = cb.purgeVisitorFunctruec.stats = &amp;stats&#123;&#125;&#125; 设置回调函数这里仅列举了 loaderExpireFunc （key 过期时的回调函数）的具体实现；其他回调（淘汰 key 时的回调、序列化回调、反序列化回调等等）的设置方式相同。 12345678// Set a loader function with expiration.// loaderExpireFunc: create a new value with this function if cached value is expired.// If nil returned instead of time.Duration from loaderExpireFunc than value will never expire.// 设置过期回调函数func (cb *CacheBuilder) LoaderExpireFunc(loaderExpireFunc LoaderExpireFunc) *CacheBuilder &#123;truecb.loaderExpireFunc = loaderExpireFunctruereturn cb&#125; 设置淘汰策略这里仅列举一个 LRU 淘汰策略 的设置（LFU，ARC 的设置方式相同）。 12345678910// 设置淘汰策略func (cb *CacheBuilder) EvictType(tp string) *CacheBuilder &#123;truecb.tp = tptruereturn cb&#125;// 设置淘汰策略func (cb *CacheBuilder) LRU() *CacheBuilder &#123;truereturn cb.EvictType(TYPE_LRU)&#125; baseCachebaseCache 是 gcache 的基础数据结构，包含缓存大小、回调、失效时间、读写锁、命中率等，由 cache.go&#x2F;baseCache 结构表示： 1234567891011121314type baseCache struct &#123;trueclock Clocktruesize inttrueloaderExpireFunc LoaderExpireFunctrueevictedFunc EvictedFunctruepurgeVisitorFunc PurgeVisitorFunctrueaddedFunc AddedFunctruedeserializeFunc DeserializeFunctrueserializeFunc SerializeFunctrueexpiration *time.Durationtruemu sync.RWMutextrueloadGroup Grouptrue*stats&#125; SimpleCachegcache 中 SimpleCache 由 simple.go&#x2F;SimpleCache 结构表示： 12345// SimpleCache has no clear priority for evict cache. It depends on key-value map order.type SimpleCache struct &#123;truebaseCachetrueitems map[interface&#123;&#125;]*simpleItem&#125; SimpleCache 中 simpleItem 由 simple.go&#x2F;simpleItem 结构表示： 12345type simpleItem struct &#123;trueclock Clocktruevalue interface&#123;&#125;trueexpiration *time.Time&#125; 源码参考 simple.go 设置超时时间超时时间的设定方式：在当前时间的基础上加上超时时间 expiration。 12345678910111213// Set a new key-value pair with an expiration timefunc (c *SimpleCache) SetWithExpire(key, value interface&#123;&#125;, expiration time.Duration) error &#123;truec.mu.Lock()truedefer c.mu.Unlock()trueitem, err := c.set(key, value)trueif err != nil &#123;truetruereturn errtrue&#125;truet := c.clock.Now().Add(expiration)trueitem.(*simpleItem).expiration = &amp;ttruereturn nil&#125; 键值对失效判断simpleItem 的超时判断，其他（lruItem，lfuItem，arcItem）超时判断逻辑相同，即检查过期时间 expiration 是否在当前时间 now 之前。 123456789101112// IsExpired returns boolean value whether this item is expired or not.// 键值对是否超时func (si *simpleItem) IsExpired(now *time.Time) bool &#123;trueif si.expiration == nil &#123;truetruereturn falsetrue&#125;trueif now == nil &#123;truetruet := si.clock.Now()truetruenow = &amp;ttrue&#125;truereturn si.expiration.Before(*now)&#125; 设置键值对我们通过 SET 方法为 SimpleCache 设置键值对： 1234567gc := gcache.New(3). Simple(). Build()gc.Set(\"k1\", \"v1\")gc.Set(\"k2\", \"v2\")gc.Set(\"k3\", \"v3\") 如图，展示了设置上述 3 个键值对之后 SimpleCache 的状态（为了在接下来操作中表述简单，此处未设置失效时间）： 读取键值对由于 SimpleCache 没有排序策略，读取操作不会改变键值对的相对排序。 缓存满时增加键值对当 SimpleCache 缓存满时再增加键值对，会先执行淘汰策略。随机淘汰 items 中的键值对（因为 golang 中，map 遍历是随机的）。 1gc.Set(\"k4\", \"v4\") ：如图，展示了随机淘汰 items 中 1 个键值对，并新增键值对过程中，SimpleCache 的变化（为了在接下来操作中表述简单，此处未设置失效时间）： LRUCachegcache 中 LRUCache 由 lru.go&#x2F;LRUCache 结构表示： 123456// Discards the least recently used items first.type LRUCache struct &#123;truebaseCachetrueitems map[interface&#123;&#125;]*list.ElementtrueevictList *list.List&#125; baseCache 为缓存基础数据结构，包含缓存大小以及各种回调函数； items 是一个 map 类型，可以在 O(1) 时间内找到指定键值对，值为 lruItem； evictList 是一个双向链表，用来淘汰最近未使用的键值对，是实现 LRU 策略的关键结构； LRUCache 中 lruItem 由 lru.go&#x2F;lruItem 结构表示： 123456type lruItem struct &#123;trueclock Clocktruekey interface&#123;&#125;truevalue interface&#123;&#125;trueexpiration *time.Time&#125; 设置键值对我们通过 SET 方法为 LRUCache 设置键值对： 1234567gc := gcache.New(3). LRU(). Build()gc.Set(\"k1\", \"v1\")gc.Set(\"k2\", \"v2\")gc.Set(\"k3\", \"v3\") 如图，展示了设置上述 3 个键值对之后 LRUCache 的状态（为了在接下来操作中表述简单，此处未设置失效时间）： 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// set a new key-value pairfunc (c *LRUCache) Set(key, value interface&#123;&#125;) error &#123;truec.mu.Lock()truedefer c.mu.Unlock()true_, err := c.set(key, value)truereturn err&#125;func (c *LRUCache) set(key, value interface&#123;&#125;) (interface&#123;&#125;, error) &#123;truevar err errortrueif c.serializeFunc != nil &#123;truetruevalue, err = c.serializeFunc(key, value)truetrueif err != nil &#123;truetruetruereturn nil, errtruetrue&#125;true&#125;true// Check for existing itemtruevar item *lruItemtrue// 查找 key 是否已经存在，如果存在直接更新对应的 valuetrueif it, ok := c.items[key]; ok &#123;truetruec.evictList.MoveToFront(it)truetrueitem = it.Value.(*lruItem)truetrueitem.value = valuetrue&#125; else &#123;truetrue// Verify size not exceededtruetrue// 判断是否超出缓存大小，如果超出就先删除一个元素truetrueif c.evictList.Len() &gt;= c.size &#123;truetruetruec.evict(1)truetrue&#125;truetrueitem = &amp;lruItem&#123;truetruetrueclock: c.clock,truetruetruekey: key,truetruetruevalue: value,truetrue&#125;truetrue// 新数据加入链表首部truetruec.items[key] = c.evictList.PushFront(item)true&#125;trueif c.expiration != nil &#123;truetruet := c.clock.Now().Add(*c.expiration)truetrueitem.expiration = &amp;ttrue&#125;trueif c.addedFunc != nil &#123;truetruec.addedFunc(key, value)true&#125;truereturn item, nil&#125; 读取键值对我们通过 LRUCache 方法读取 gcache 中的键值对。当 key 存在时，返回对应的键值对；当 key 不存在时返回错误 KeyNotFoundError（如果设置有回调，则为返回回调执行结果）。 会涉及到键值对顺序，hitCount、missCount 的变化。 读取成功执行 GET(&quot;k2&quot;) 读取键值对。缓存命中次数（hitCount）+1，k2 在被移动到淘汰链表首部。读取后成功后 LRUCache 状态（流程）： 读取失败（访问不存在的键）执行 GET(&quot;k4&quot;) 读取键值对。缺失次数（missCount）+1，淘汰链表顺序不变，LRUCache 状态： 关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Get a value from cache pool using key if it exists.// If it dose not exists key and has LoaderFunc,// generate a value using `LoaderFunc` method returns value.// 读取键值对// 如果存在缓存，则返回；// 否则，如果定义了 LoaderFunc 回调，则执行回调。func (c *LRUCache) Get(key interface&#123;&#125;) (interface&#123;&#125;, error) &#123;truev, err := c.get(key, false)trueif err == KeyNotFoundError &#123;truetruereturn c.getWithLoader(key, true)true&#125;truereturn v, err&#125;func (c *LRUCache) get(key interface&#123;&#125;, onLoad bool) (interface&#123;&#125;, error) &#123;truev, err := c.getValue(key, onLoad)trueif err != nil &#123;truetruereturn nil, errtrue&#125;trueif c.deserializeFunc != nil &#123;truetruereturn c.deserializeFunc(key, v)true&#125;truereturn v, nil&#125;func (c *LRUCache) getValue(key interface&#123;&#125;, onLoad bool) (interface&#123;&#125;, error) &#123;truec.mu.Lock()trueitem, ok := c.items[key]true// 命中缓存trueif ok &#123;truetrueit := item.Value.(*lruItem)truetrue// 缓存未过期truetrueif !it.IsExpired(nil) &#123;truetruetruec.evictList.MoveToFront(item)truetruetruev := it.valuetruetruetruec.mu.Unlock()truetruetrueif !onLoad &#123;truetruetruetruec.stats.IncrHitCount()truetruetrue&#125;truetruetruereturn v, niltruetrue&#125;truetruec.removeElement(item)true&#125;truec.mu.Unlock()trueif !onLoad &#123;truetruec.stats.IncrMissCount()true&#125;truereturn nil, KeyNotFoundError&#125; 缓存满时增加键值对当 LRUCache 缓存满时再增加键值对，会先执行淘汰策略。淘汰链表尾部键值对，并删除 items 中对应 key。 1gc.Set(\"k5\", \"v5\") 淘汰链表尾部键值对 和 items 对应元素： 关键代码： 123456789101112131415161718192021// evict removes the oldest item from the cache.func (c *LRUCache) evict(count int) &#123;truefor i := 0; i &lt; count; i++ &#123;truetrueent := c.evictList.Back()truetrueif ent == nil &#123;truetruetruereturntruetrue&#125; else &#123;truetruetruec.removeElement(ent)truetrue&#125;true&#125;&#125;func (c *LRUCache) removeElement(e *list.Element) &#123;truec.evictList.Remove(e)trueentry := e.Value.(*lruItem)truedelete(c.items, entry.key)trueif c.evictedFunc != nil &#123;truetrueentry := e.Value.(*lruItem)truetruec.evictedFunc(entry.key, entry.value)true&#125;&#125; k5 键值对，插入到链表头部位置： LFUCachegcache 中 LFUCache 由 lfu.go&#x2F;LFUCache 结构表示： 1234567// Discards the least frequently used items first.// LFUCache 会优先删除访问频次最少的键值对type LFUCache struct &#123;truebaseCachetrueitems map[interface&#123;&#125;]*lfuItemtruefreqList *list.List // list for freqEntry&#125; baseCache 为缓存基础数据结构，包含缓存大小以及各种回调函数； items 是一个 map 类型，可以在 O(1) 时间内找到指定键值对，值为 lruItem； freqList 是一个双向链表，用来淘汰最近未使用的键值对，是实现 LRU 策略的关键结构； LFUCache 中 freqEntry 由 lfu.go&#x2F;freqEntry 结构表示： 1234type freqEntry struct &#123;truefreq uinttrueitems map[*lfuItem]struct&#123;&#125;&#125; LFUCache 中 lfuItem 由 lfu.go&#x2F;lfuItem 结构表示： 1234567type lfuItem struct &#123;trueclock Clocktruekey interface&#123;&#125;truevalue interface&#123;&#125;truefreqElement *list.Elementtrueexpiration *time.Time&#125; 如图，展示了未设置任何键值对时 LFUCache 的状态： 设置键值对同样，我们通过 SET 方法为 LFUCache 设置键值对： 1234567gc := gcache.New(3). LFU(). Build()gc.Set(\"k1\", \"v1\")gc.Set(\"k2\", \"v2\")gc.Set(\"k3\", \"v3\") 如图，展示了设置上述 3 个键值对之后 LFUCache 的状态（为了在接下来操作中表述简单，此处未设置失效时间）： 读取键值对我们通过 GET 方法读取 LFUCache 中的键值对。当 key 存在时，返回对应的键值对；当 key 不存在时返回错误 KeyNotFoundError（如果设置有回调，则为返回回调执行结果）。 读取操作会改变键值对所在 freqEntry 节点，同时 hitCount、missCount 也会随之变化。读取失败时，与 LRUCache 的逻辑一致，这里不再说明。 以执行 GET(&quot;k1&quot;) 读取键值对为例： 删除 freqEntry(freq &#x3D; 0) 节点 items 中的 key &#x3D; lfuItem1 的键值对： 创建 freqEntry(freq &#x3D; 1) 新节点（插入到 freq &#x3D; 0 节点之后），然后把 key &#x3D; lfuItem1 的键值对添加到节点 items 中，并修改命中次数（hitCount）： 注意：随着读取操作的发生，freqList 会越来越长（如果某个 key 读取次数最多达到 N 次，那么 freqList 长度就等于 N + 1）。这样的话，就可能会带来内存问题。 缓存满时增加键值对当 LFUCache 缓存满时再增加键值对，会先执行淘汰策略。从链表首部（访问频次为 0 的节点）开始删除指定个数（默认 1）的键值对，并删除 items 中对应 key。 1gc.Set(\"k5\", \"v5\") 从链表首部节点开始选择待淘汰键值对： 淘汰 步骤 1 中选定的键值对： 新节点加入到链表首部节点（freq &#x3D; 0）中，并更新 items： ARCCacheARC(Adaptive Replacement Cache) 融合了 LRU 和 LFU 的特点，在二者之间取得一个平衡，同时也使得算法看起来更复杂一些。gcache 中 ARCCache 由 arc.go&#x2F;ARCCache 结构表示： 1234567891011// Constantly balances between LRU and LFU, to improve the combined result.type ARC struct &#123;truebaseCachetrueitems map[interface&#123;&#125;]*arcItemtruepart inttruet1 *arcListtruet2 *arcListtrueb1 *arcListtrueb2 *arcList&#125; 如图，展示了未设置任何键值对时 ARCCache 的状态： 相比 LRUCache，LFUCache 来讲，ARCCache 的逻辑复杂了很多。如图，给出 ARCCache 键值对转移状态图： 键值对状态图与失效时间有关，这里给出键值对的流转图示。 设置键值对同样，我们通过 SET 方法为 ARCCache 设置键值对： 1234567gc := gcache.New(3). ARC(). Build()gc.SetWithExpire(\"k1\", \"v1\", 10 * time.Second)gc.Set(\"k2\", \"v2\")gc.Set(\"k3\", \"v3\") ARCCache 的内部存储就复杂了很多，大致流程参考前面给的【ARCCache 键值对转移状态图】。键值对如下： 关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596func (c *ARC) Set(key, value interface&#123;&#125;) error &#123;truec.mu.Lock()truedefer c.mu.Unlock()true_, err := c.set(key, value)truereturn err&#125;func (c *ARC) set(key, value interface&#123;&#125;) (interface&#123;&#125;, error) &#123;truevar err errortrueif c.serializeFunc != nil &#123;truetruevalue, err = c.serializeFunc(key, value)truetrueif err != nil &#123;truetruetruereturn nil, errtruetrue&#125;true&#125;trueitem, ok := c.items[key]trueif ok &#123;truetrueitem.value = valuetrue&#125; else &#123;truetrueitem = &amp;arcItem&#123;truetruetrueclock: c.clock,truetruetruekey: key,truetruetruevalue: value,truetrue&#125;truetruec.items[key] = itemtrue&#125;trueif c.expiration != nil &#123;truetruet := c.clock.Now().Add(*c.expiration)truetrueitem.expiration = &amp;ttrue&#125;truedefer func() &#123;truetrueif c.addedFunc != nil &#123;truetruetruec.addedFunc(key, value)truetrue&#125;true&#125;()trueif c.t1.Has(key) || c.t2.Has(key) &#123;truetruereturn item, niltrue&#125;true// 高频访问true// 移动键值对 (from b1 to t2)trueif elt := c.b1.Lookup(key); elt != nil &#123;truetruec.setPart(minInt(c.size, c.part+maxInt(c.b2.Len()/c.b1.Len(), 1)))truetruec.replace(key)truetruec.b1.Remove(key, elt)truetruec.t2.PushFront(key)truetruereturn item, niltrue&#125;true// 高频访问true// 移动键值对 (from b2 to t2)trueif elt := c.b2.Lookup(key); elt != nil &#123;truetruec.setPart(maxInt(0, c.part-maxInt(c.b1.Len()/c.b2.Len(), 1)))truetruec.replace(key)truetruec.b2.Remove(key, elt)truetruec.t2.PushFront(key)truetruereturn item, niltrue&#125;true// 缓存满：选择性淘汰 t1，b1，b2trueif c.isCacheFull() &amp;&amp; c.t1.Len()+c.b1.Len() == c.size &#123;truetrueif c.t1.Len() &lt; c.size &#123;truetruetruec.b1.RemoveTail()truetruetruec.replace(key)truetrue&#125; else &#123;truetruetruepop := c.t1.RemoveTail()truetruetrueitem, ok := c.items[pop]truetruetrueif ok &#123;truetruetruetruedelete(c.items, pop)truetruetruetrueif c.evictedFunc != nil &#123;truetruetruetruetruec.evictedFunc(item.key, item.value)truetruetruetrue&#125;truetruetrue&#125;truetrue&#125;true&#125; else &#123;truetruetotal := c.t1.Len() + c.b1.Len() + c.t2.Len() + c.b2.Len()truetrueif total &gt;= c.size &#123;truetruetrueif total == (2 * c.size) &#123;truetruetruetrueif c.b2.Len() &gt; 0 &#123;truetruetruetruetruec.b2.RemoveTail()truetruetruetrue&#125; else &#123;truetruetruetruetruec.b1.RemoveTail()truetruetruetrue&#125;truetruetrue&#125;truetruetruec.replace(key)truetrue&#125;true&#125;true// t1 新增键值对truec.t1.PushFront(key)truereturn item, nil&#125; 读取键值对执行 GET(&quot;k1&quot;) 操作（第 1 次读），ARCCache 会将键值对从 t1 移到 t2。或者从 Ghost list 中捞回。 123gc.Get(\"k1\")gc.Get(\"k2\")gc.Get(\"k3\") 假如在访问的过程中键值对 k1 过期了，则会被移到 b1 中： 可以看到，t1 中的其他键值对，依次被移动到了 t2 中：![20191025003158](&#x2F;images 再次执行 gc.Get(&quot;k2&quot;) 操作时，由于键值已经在 t2 中，会改变键值对的排序： 再次执行 gc.Set(&quot;k1&quot;, &quot;v1&quot;) 操作时，由于键值对已经在 b1 中，则会把 k1 捞出来，并且放到 t2 中（认为是高频访问）： 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Get a value from cache pool using key if it exists. If not exists and it has LoaderFunc, it will generate the value using you have specified LoaderFunc method returns value.func (c *ARC) Get(key interface&#123;&#125;) (interface&#123;&#125;, error) &#123;truev, err := c.get(key, false)trueif err == KeyNotFoundError &#123;truetruereturn c.getWithLoader(key, true)true&#125;truereturn v, err&#125;func (c *ARC) get(key interface&#123;&#125;, onLoad bool) (interface&#123;&#125;, error) &#123;truev, err := c.getValue(key, onLoad)trueif err != nil &#123;truetruereturn nil, errtrue&#125;trueif c.deserializeFunc != nil &#123;truetruereturn c.deserializeFunc(key, v)true&#125;truereturn v, nil&#125;func (c *ARC) getValue(key interface&#123;&#125;, onLoad bool) (interface&#123;&#125;, error) &#123;truec.mu.Lock()truedefer c.mu.Unlock()trueif elt := c.t1.Lookup(key); elt != nil &#123;truetruec.t1.Remove(key, elt)truetrueitem := c.items[key]truetrueif !item.IsExpired(nil) &#123;truetruetruec.t2.PushFront(key)truetruetrueif !onLoad &#123;truetruetruetruec.stats.IncrHitCount()truetruetrue&#125;truetruetruereturn item.value, niltruetrue&#125; else &#123;truetruetrue// TODO else 可以去掉truetruetruedelete(c.items, key)truetruetruec.b1.PushFront(key)truetruetrueif c.evictedFunc != nil &#123;truetruetruetruec.evictedFunc(item.key, item.value)truetruetrue&#125;truetrue&#125;true&#125;trueif elt := c.t2.Lookup(key); elt != nil &#123;truetrueitem := c.items[key]truetrueif !item.IsExpired(nil) &#123;truetruetruec.t2.MoveToFront(elt)truetruetrueif !onLoad &#123;truetruetruetruec.stats.IncrHitCount()truetruetrue&#125;truetruetruereturn item.value, niltruetrue&#125; else &#123;truetruetrue// TODO else 可以去掉truetruetruedelete(c.items, key)truetruetruec.t2.Remove(key, elt)truetruetruec.b2.PushFront(key)truetruetrueif c.evictedFunc != nil &#123;truetruetruetruec.evictedFunc(item.key, item.value)truetruetrue&#125;truetrue&#125;true&#125;trueif !onLoad &#123;truetruec.stats.IncrMissCount()true&#125;truereturn nil, KeyNotFoundError&#125; 缓存满时增加键值对当缓存满时新增键值对，ARCCache 会淘汰 t1，b1，b2 中的数据（参考 SET 方法）。 图略 淘汰策略： 123456789101112131415161718192021222324252627282930// replace// 1. 淘汰数据 t1, t2 数据到 b1 b2// 2. 从 items 中删除键值对func (c *ARC) replace(key interface&#123;&#125;) &#123;trueif !c.isCacheFull() &#123;truetruereturntrue&#125;truevar old interface&#123;&#125;trueif c.t1.Len() &gt; 0 &amp;&amp; ((c.b2.Has(key) &amp;&amp; c.t1.Len() == c.part) || (c.t1.Len() &gt; c.part)) &#123;truetrue// t1 淘汰到 b1truetrueold = c.t1.RemoveTail()truetruec.b1.PushFront(old)true&#125; else if c.t2.Len() &gt; 0 &#123;truetrue// t2 淘汰到 b2truetrueold = c.t2.RemoveTail()truetruec.b2.PushFront(old)true&#125; else &#123;truetrue// t1 淘汰到 b1truetrueold = c.t1.RemoveTail()truetruec.b1.PushFront(old)true&#125;trueitem, ok := c.items[old]trueif ok &#123;truetrue// 删除已淘汰的数据truetruedelete(c.items, old)truetrueif c.evictedFunc != nil &#123;truetruetruec.evictedFunc(item.key, item.value)truetrue&#125;true&#125;&#125; 引用操作系统之页面置换算法谈谈缓存和基本的缓存算法缓存算法（FIFO 、LRU、LFU三种算法的区别）Go gcache 源码分析（图解）常用缓存淘汰算法（LFU、LRU、ARC、FIFO、MRU）缓存机制Cache ARC算法（一）gcache 源码分析阿里P8架构师谈：详解Memcached、Redis等缓存的特征、原理、应用一文深入了解：分布式系统中的缓存架构Ristretto is a fast, concurrent cache library built with a focus on performance and correctness.Caffeine Cache-高性能Java本地缓存组件 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"源码","slug":"源码","permalink":"https://liangyuanzheng.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"gcache","slug":"gcache","permalink":"https://liangyuanzheng.com/tags/gcache/"}]},{"title":"npm 一键更新 package.json 依赖模块版本","slug":"npm-一键更新-package-json-依赖模块版本","date":"2019-10-07T01:56:53.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"npm-一键更新-package-json-依赖模块版本.html","link":"","permalink":"https://liangyuanzheng.com/npm-%E4%B8%80%E9%94%AE%E6%9B%B4%E6%96%B0-package-json-%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97%E7%89%88%E6%9C%AC.html","excerpt":"","text":"github 提示： 安装 npm-check-updatesstep 1： 执行 npm install -g npm-check-updates 安装升级工具。 检查更新step 2： 执行 npm-check-updates -u 检查是否有更新。 升级更新step 3： 执行 npm-check-updates -u 进行升级。 再次执行 npm-check-updates -u 会发现已更新到最新版本：","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://liangyuanzheng.com/tags/npm/"},{"name":"版本升级","slug":"版本升级","permalink":"https://liangyuanzheng.com/tags/%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7/"}]},{"title":"Golang 配置文件热加载","slug":"Golang-配置文件热加载","date":"2019-10-06T08:13:27.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"Golang-配置文件热加载.html","link":"","permalink":"https://liangyuanzheng.com/Golang-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%83%AD%E5%8A%A0%E8%BD%BD.html","excerpt":"使用 github.com/fsnotify/fsnotify，监听 Create、Remove、Write、Chmod、Rename 等事件，实现对文件状态的实时监听，当文件有变化时执行已注册的回调函数（如下），实现对配置的重新加载。","text":"使用 github.com/fsnotify/fsnotify，监听 Create、Remove、Write、Chmod、Rename 等事件，实现对文件状态的实时监听，当文件有变化时执行已注册的回调函数（如下），实现对配置的重新加载。 123// CallbackFunc 配置回调函数// filename：文件相对路径type CallbackFunc func(filename string) error 以读取配置为例，来说明如何实现热加载： 定义配置文件对应结构体配置文件 config.json 内容： 123&#123; \"model\":\"aaaaa\"&#125; 为配置文件定义结构： 123type Config struct &#123;trueModel string `json:\"model\"`&#125; 定义读取配置文件的方法1234567891011121314151617var cnf Configfunc loadConfig(filename string) error &#123;truefile, err := ioutil.ReadFile(filename)trueif err != nil &#123;truetruelog.Fatalln(err)true&#125;trueerr = jsoniter.Unmarshal(file, &amp;cnf)trueif err != nil &#123;truetruelog.Fatalln(err)true&#125;truefmt.Printf(\"config:%+v\\n\", cnf)truereturn nil&#125; 注册回调12// 1. 注册配置文件监听及回调hotreload.Register(\"conf/config.json\", loadConfig) 启动监听12// 2. 启动监听hotreload.Watcher() 完整 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport (true\"fmt\"true\"io/ioutil\"true\"log\"true\"github.com/LeungGeorge/grit/lib/hotreload\"true\"github.com/gin-gonic/gin\"true\"github.com/json-iterator/go\")type Config struct &#123;trueModel string `json:\"model\"`&#125;var cnf Configfunc loadConfig(filename string) error &#123;truefile, err := ioutil.ReadFile(filename)trueif err != nil &#123;truetruelog.Fatalln(err)true&#125;trueerr = jsoniter.Unmarshal(file, &amp;cnf)trueif err != nil &#123;truetruelog.Fatalln(err)true&#125;truefmt.Printf(\"config:%+v\\n\", cnf)truereturn nil&#125;func main() &#123;truer := gin.Default() // 1. 注册配置文件监听及回调truehotreload.Register(\"conf/config.json\", loadConfig) // 2. 启动监听truehotreload.Watcher()truer.Run()&#125; 输出（可以看到 demo 读取到 conf/config.json 的内容）： 1config:&#123;Model:aaaaa&#125; Golang 配置文件热加载 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"热加载","slug":"热加载","permalink":"https://liangyuanzheng.com/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"}]},{"title":"golang 设计与实现 slice","slug":"golang-设计与实现-slice","date":"2019-10-04T13:02:51.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"golang-设计与实现-slice.html","link":"","permalink":"https://liangyuanzheng.com/golang-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-slice.html","excerpt":"Golang 动态数组 slice。","text":"Golang 动态数组 slice。 定义12345type slice struct &#123;truearray unsafe.Pointer // 数据truelen int // 长度（元素个数）truecap int // 容量&#125; 创建 slice采用 mallocgc 分配内存。 123456789101112131415161718// 创建 slicefunc makeslice(et *_type, len, cap int) unsafe.Pointer &#123;truemem, overflow := math.MulUintptr(et.size, uintptr(cap))trueif overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap &#123;truetrue// NOTE: Produce a 'len out of range' error instead of atruetrue// 'cap out of range' error when someone does make([]T, bignumber).truetrue// 'cap out of range' is true too, but since the cap is only beingtruetrue// supplied implicitly, saying len is clearer.truetrue// See golang.org/issue/4085.truetruemem, overflow := math.MulUintptr(et.size, uintptr(len))truetrueif overflow || mem &gt; maxAlloc || len &lt; 0 &#123;truetruetruepanicmakeslicelen()truetrue&#125;truetruepanicmakeslicecap()true&#125;truereturn mallocgc(mem, et, true)&#125; 容量扩容策略 总结： 新容量 cap 大于旧容量 old.cap 的 2 倍时，直接采用 cap； 旧容量 old.cap 小于 1024 时，扩容为旧容量 old.cap 的 2 倍； 旧容量 old.cap 大于等于 1024 时，按照旧容量 old.cap 的 1.25 倍指数幂增长； 当步骤 3 溢出时，直接采用新容量 cap 的值； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// growslice handles slice growth during append.// It is passed the slice element type, the old slice, and the desired new minimum capacity,// and it returns a new slice with at least that capacity, with the old data// copied into it.// The new slice's length is set to the old slice's length,// NOT to the new requested capacity.// This is for codegen convenience. The old slice's length is used immediately// to calculate where to write new values during an append.// When the old backend is gone, reconsider this decision.// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.//// slice 在追加数据时使用 growslice 处理容量增长// 入参：slice 元素类型，旧 slice，期望容量// 返回：新 slicefunc growslice(et *_type, old slice, cap int) slice &#123;trueif raceenabled &#123;truetruecallerpc := getcallerpc()truetrueracereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))true&#125;trueif msanenabled &#123;truetruemsanread(old.array, uintptr(old.len*int(et.size)))true&#125;trueif cap &lt; old.cap &#123;truetruepanic(errorString(\"growslice: cap out of range\"))true&#125;trueif et.size == 0 &#123;truetrue// append should not create a slice with nil pointer but non-zero len.truetrue// We assume that append doesn't need to preserve old.array in this case.truetruereturn slice&#123;unsafe.Pointer(&amp;zerobase), old.len, cap&#125;true&#125;truenewcap := old.captruedoublecap := newcap + newcaptrue// 期望容量 cap 超过旧容量 2 倍时，直接使用 cap 作为新 slice 的容量trueif cap &gt; doublecap &#123;truetruenewcap = captrue&#125; else &#123;truetrue// 就容量小于 1024 时，空间按 2 倍增长truetrueif old.len &lt; 1024 &#123;truetruetruenewcap = doublecaptruetrue&#125; else &#123;truetruetrue// Check 0 &lt; newcap to detect overflowtruetruetrue// and prevent an infinite loop.truetruetrue// 新容量以 (1 + 1 / 4) 倍率增加，直到大于期望容量truetruetruefor 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;truetruetruetruenewcap += newcap / 4truetruetrue&#125;truetruetrue// Set newcap to the requested cap whentruetruetrue// the newcap calculation overflowed.truetruetrue// 防止溢出truetruetrueif newcap &lt;= 0 &#123;truetruetruetruenewcap = captruetruetrue&#125;truetrue&#125;true&#125;truevar overflow booltruevar lenmem, newlenmem, capmem uintptrtrue// Specialize for common values of et.size.true// For 1 we don't need any division/multiplication.true// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.true// For powers of 2, use a variable shift.true// 计算新容量trueswitch &#123;truecase et.size == 1:truetruelenmem = uintptr(old.len)truetruenewlenmem = uintptr(cap)truetruecapmem = roundupsize(uintptr(newcap))truetrueoverflow = uintptr(newcap) &gt; maxAlloctruetruenewcap = int(capmem)truecase et.size == sys.PtrSize:truetruelenmem = uintptr(old.len) * sys.PtrSizetruetruenewlenmem = uintptr(cap) * sys.PtrSizetruetruecapmem = roundupsize(uintptr(newcap) * sys.PtrSize)truetrueoverflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSizetruetruenewcap = int(capmem / sys.PtrSize)truecase isPowerOfTwo(et.size):truetruevar shift uintptrtruetrueif sys.PtrSize == 8 &#123;truetruetrue// Mask shift for better code generation.truetruetrueshift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63truetrue&#125; else &#123;truetruetrueshift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31truetrue&#125;truetruelenmem = uintptr(old.len) &lt;&lt; shifttruetruenewlenmem = uintptr(cap) &lt;&lt; shifttruetruecapmem = roundupsize(uintptr(newcap) &lt;&lt; shift)truetrueoverflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)truetruenewcap = int(capmem &gt;&gt; shift)truedefault:truetruelenmem = uintptr(old.len) * et.sizetruetruenewlenmem = uintptr(cap) * et.sizetruetruecapmem, overflow = math.MulUintptr(et.size, uintptr(newcap))truetruecapmem = roundupsize(capmem)truetruenewcap = int(capmem / et.size)true&#125;true// The check of overflow in addition to capmem &gt; maxAlloc is neededtrue// to prevent an overflow which can be used to trigger a segfaulttrue// on 32bit architectures with this example program:true//true// type T [1&lt;&lt;27 + 1]int64true//true// var d Ttrue// var s []Ttrue//true// func main() &#123;true// s = append(s, d, d, d, d)true// print(len(s), \"\\n\")true// &#125;trueif overflow || capmem &gt; maxAlloc &#123;truetruepanic(errorString(\"growslice: cap out of range\"))true&#125;truevar p unsafe.Pointertrueif et.ptrdata == 0 &#123;truetruep = mallocgc(capmem, nil, false)truetrue// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).truetrue// Only clear the part that will not be overwritten.truetruememclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)true&#125; else &#123;truetrue// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.truetruep = mallocgc(capmem, et, true)truetrueif lenmem &gt; 0 &amp;&amp; writeBarrier.enabled &#123;truetruetrue// Only shade the pointers in old.array since we know the destination slice ptruetruetrue// only contains nil pointers because it has been cleared during alloc.truetruetruebulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)truetrue&#125;true&#125;true// 复制旧数据truememmove(p, old.array, lenmem)truereturn slice&#123;p, old.len, newcap&#125;&#125; hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"设计与实现","slug":"设计与实现","permalink":"https://liangyuanzheng.com/tags/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"name":"源码","slug":"源码","permalink":"https://liangyuanzheng.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"slice","slug":"slice","permalink":"https://liangyuanzheng.com/tags/slice/"}]},{"title":"Go 开发者路线图","slug":"Go-开发者路线图","date":"2019-10-03T08:34:06.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"Go-开发者路线图.html","link":"","permalink":"https://liangyuanzheng.com/Go-%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE.html","excerpt":"在 2019 成为一名 Go 开发者的路线图：","text":"在 2019 成为一名 Go 开发者的路线图： 在下边有一个图表，如果你想要成为一名 Go 的开发者的话，里面记录了一条成长路线以及一些你也许可以用得上的库。这是我为每一个想要问我：”我该怎么才能成为 Go 的开发者？“的人而准备的。 免责声明 本路线图的目的是让您了解大致的学习内容。路线图会在您对接下来要学习什么感到困惑的时候给您适当的指导，而不是让您选择时髦的东西。你应该逐渐了解为什么一个工具比另一个工具更适合某些情况。记住，时髦的东西不一定最适合某个情况 给我一个 Star！ :star:如果您喜欢或者打算使用这个项目来学习或者来开始你的设计，给我一个 Star，谢谢！ 路线图 资源 先决条件 Go Go Modules SQL 通用开发技能 学习 GIT，在 GitHub 上建立一些仓库，与其它人分享你的代码 了解 HTTP(S) 协议，request 方法（GET, POST, PUT, PATCH, DELETE, OPTIONS） 不要害怕使用 Google，Google 搜索的力量 看一些和数据结构以及算法有关的书籍 学习关于认证的基础实现 面向对象原则等等 命令行工具 cobra urfave&#x2F;cli 网页框架 + 路由 Echo Beego Gin Revel Chi 数据库 关系型 SQL Server PostgreSQL MariaDB MySQL CockroachDB 云数据库 CosmosDB DynamoDB 搜索引擎 ElasticSearch Solr Sphinx NoSQL MongoDB Redis Apache Cassandra LiteDB RavenDB CouchDB 对象关系映射框架 Gorm Xorm 高速缓存 GCache 分布式缓存 Go-Redis GoMemcached 日志 日志框架 Zap ZeroLog Logrus 日志管理系统 Sentry.io Loggly.com 实时通讯 Socket.IO API 客户端 REST Gentleman GRequests heimdall GraphQL gqlgen graphql-go 最好知道 Validator Glow GJson Authboss Go-Underscore 测试 单元，行为，集成测试 GoMock Testify GinkGo GoMega GoCheck GoDog GoConvey 端对端测试 Selenium Endly 任务调度 Gron JobRunner 微服务 消息代理 RabbitMQ Apache Kafka ActiveMQ Azure Service Bus 消息总线 Message-Bus 框架 GoKit Micro rpcx istio RPC Protocol Buffers gRPC-Go gRPC-Gateway Twirp Go-模式 最后如果您认为该路线图可以改进，请务必提交PR或者发Issue。当然，我也会持续地改进它，所以你也许想要给这个仓库来个 Star 从而再次访问。 想法来源于 : ASP.NET Core Developer Roadmap 贡献这个路线图是用 Draw.io 做的。项目文件为该仓库下的 golang-developer-roadmap.xml 文件。 您如果想要修改它，您可以进入 Draw.io 点击打开已有图表并且选择这个 xml 文件。它会为您打开这个路线图。改进它，并且上传，以及更新该 ReadMe 中的对应图片，然后提交 PR（以 400% 的缩放导出 PNG 以及使用 Compressor.io 来压缩它）。 用 PR 提交改进 在 Issue 中交流想法 传播这个图表 License 原文 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"文摘","slug":"文摘","permalink":"https://liangyuanzheng.com/tags/%E6%96%87%E6%91%98/"},{"name":"学习路线","slug":"学习路线","permalink":"https://liangyuanzheng.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]},{"title":"TCP 与 UDP","slug":"TCP-与-UDP","date":"2019-10-03T01:49:58.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"TCP-与-UDP.html","link":"","permalink":"https://liangyuanzheng.com/TCP-%E4%B8%8E-UDP.html","excerpt":"第 6 章 TCP 与 UDP在 TCP&#x2F;IP 中能够实现传输层功能的，具有代表性的协议是 TCP 和 UDP。 TCP （Transmission Control Protocol）是面向连接的、可靠的流协议。具有顺序控制、重发控制、流量控制、拥塞控制。 UDP （User Datagram Protocol）是不具备可靠性的数据报协议。","text":"第 6 章 TCP 与 UDP在 TCP&#x2F;IP 中能够实现传输层功能的，具有代表性的协议是 TCP 和 UDP。 TCP （Transmission Control Protocol）是面向连接的、可靠的流协议。具有顺序控制、重发控制、流量控制、拥塞控制。 UDP （User Datagram Protocol）是不具备可靠性的数据报协议。 TCP提供丢包重发，以及顺序控制。 TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。 通过序列号与确认应答提高可靠性； 略大于一个 RTT ，进行超时重发； 使用 TCP 首部控制字段，进行三次握手（四次挥手），进行连接管理； TCP 以段为单位发送数据（MSS：Maximum Segment Size）； 使用窗口控制（滑动窗口）提高发送速度；同时发送端根据窗口大小对发送数据的量进行流量， 使用重发控制，解决丢包问题。 使用拥塞控制，避免通信开始时连续发包导致的网络拥堵，避免网络拥塞情况的发生。 提高网络利用率的规范； Nagle 算法：当发送端数据很少时进行延迟发送的一种处理机制。会发生某种程度的延迟。延迟确认应答：延迟一段时间，再发送确认（一定程度可以减少确认次数）。（可提高网络利用率从而降低计算机处理负荷）捎带应答（PiggyBack Acknowledge）：TCP 的确认应答和回执数据通过一个包发送。（需启动延迟确认应答才能实现捎带应答） UDPUDP 不提供复杂的而控制机制，利用 IP 提供面向无连接的通信服务。收到数据即原样发送。 UDP 主要应用于那些对高速传输和实时性有较高要求的通信和广播通信。UDP 无重发机制，从而也就不会有声音大幅度延迟到达的问题。 应用：包总量较小的通信（DNS、SNMP等）音视频等多媒体通信（即时通信）限定于 LAN 等特定网络的应用通信广播通信（广播、多播） hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"网络","slug":"网络","permalink":"https://liangyuanzheng.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://liangyuanzheng.com/tags/tcp/"},{"name":"udp","slug":"udp","permalink":"https://liangyuanzheng.com/tags/udp/"}]},{"title":"Golang 速查表","slug":"Golang-速查表","date":"2019-09-15T13:15:03.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"Golang-速查表.html","link":"","permalink":"https://liangyuanzheng.com/Golang-%E9%80%9F%E6%9F%A5%E8%A1%A8.html","excerpt":"简要介绍 Go 语法及特性。原文：go-lang-cheat-sheet","text":"简要介绍 Go 语法及特性。原文：go-lang-cheat-sheet 目录 基础语法 运算符 算术运算符 比较运算符 逻辑运算符 其他 声明 函数 函数作为值和回调使用 可变参数函数 内置类型 类型转换 package 流程控制结构 条件判断（if） 循环（for） 多条件分支（switch） array, slice, range array slice array 和 slice 的操作函数 map 结构体 指针 接口 结构体和接口的组合嵌入 Errors 并发 goroutine channel channel 开发原则 输出 代码片段 Http-Server 前言参考文中大部分代码都摘抄自 A Tour of Go，对新手来说是很好的参考资料。 Go 特性 命令式编程 静态类型 类 C 语法（括号使用频率更少 &amp; 无需分号），类 Oberon-2 的语法结构 代码能编译为本地可执行文件（无需 JVM 类的虚拟机） struct 和 method 取代类的概念 接口 类型组合 取代显式继承 有头等函数 有回调函数 函数可有多个返回值 保留指针，但不能直接参与算术运算 内置并发原语：goroutine 和 channel 基础语法Hello World文件 hello.go： 1234567package mainimport \"fmt\"func main() &#123;truefmt.Println(\"Hello Go\")&#125; 运行：$ go run hello.go 运算符算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取余 &amp; 按位与 &#96; &#96; ^ 按位异或 &amp;^ 按位清除（AND NOT） &lt;&lt; 左移 &gt;&gt; 右移 &amp;^ 即是 AND NOT(x, y) = AND(x, NOT(Y))，如： 12345678910package mainimport \"fmt\"func main() &#123;truex := 0xDC // 11011100truey := 0xF0 // 11110000truez := x &amp;^ y // 00001100 // y 中为 1 的位全部被清除为 0truefmt.Printf(\"%08b\", z)&#125; 比较运算符 运算符 描述 == 相等 != 不等 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 &#166;&#166; 逻辑或 ! 取反 其他 运算符 描述 &amp; 寻址（生成指针） * 获取指针指向的数据 &lt;- 向 channel 中发送 &#x2F; 接收数据 声明与 C 不同，类型放在标识符后面： 123456var foo int // 无初值的声明var foo int = 42 // 带初值的声明var foo, bar int = 42, 1302 // 一次性声明并初始化多个变量var foo = 42 // 类型推断，由使用的上下文决定foo := 42 // 简短声明，只能用在函数内部const constant = \"This is a constant\" 函数12345678910111213141516171819202122232425262728// 最简单的函数func functionName() &#123;&#125;// 带参数的函数(注意类型也是放在标识符之后的)func functionName(param1 string, param2 int) &#123;&#125;// 类型相同的多个参数func functionName(param1, param2 int) &#123;&#125;// 声明返回值的类型func functionName() int &#123; return 42&#125;// 一次返回多个值func returnMulti() (int, string) &#123; return 42, \"foobar\"&#125;var x, str = returnMulti()// 只使用 return 返回多个命名返回值func returnMulti2() (n int, s string) &#123; n = 42 s = \"foobar\" // n 和 s 会被返回 return&#125;var x, str = returnMulti2() 函数作为值和回调使用123456789101112131415161718192021222324252627282930313233343536func main() &#123; // 将函数作为值，赋给变量 add := func(a, b int) int &#123; return a + b &#125; // 使用变量直接调用函数 fmt.Println(add(3, 4))&#125;// 回调函数作用域：在定义回调函数时能访问外部函数的值func scope() func() int&#123; outer_var := 2 foo := func() int &#123; return outer_var&#125; return foo&#125;func another_scope() func() int&#123; // 编译错误，两个变量不在此函数作用域内 // undefined: outer_var outer_var = 444 return foo&#125;// 回调函数不会修改外部作用域的数据func outer() (func() int, int) &#123; outer_var := 2 inner := func() int &#123; outer_var += 99 // 试着使用外部作用域的 outer_var 变量 return outer_var // 返回值是 101，但只在 inner() 内部有效 &#125; return inner, outer_var // 返回值是 inner, 2 (outer_var 仍是 2）&#125;inner, outer_var := outer(); // inner, 2inner(); // 返回 101inner(); // 返回 200 // 回调函数的特性 可变参数函数1234567891011121314151617func main() &#123;truefmt.Println(adder(1, 2, 3)) // 6truefmt.Println(adder(9, 9)) // 18truetruenums := []int&#123;10, 20, 30&#125;truefmt.Println(adder(nums...)) // 60&#125;// 在函数的最后一个参数类型前，使用 ... 可表明函数还能接收 0 到多个此种类型的参数// 下边的函数在调用时传多少个参数都可以func adder(args ...int) int &#123;truetotal := 0truefor _, v := range args &#123; // 使用迭代器逐个访问参数truetruetotal += vtrue&#125;truereturn total&#125; 内置类型1234567891011121314boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 类型的别名 // 存储 raw datarune // int32 类型的别名 // 一个 Unicode code point 字符float32 float64complex64 complex128 类型转换12345678var i int = 42var f float64 = float64(i)var u uint = uint(f)// 简化语法i := 42f := float64(i)u := uint(f) package package 在源文件开头声明 main package 才是可执行文件 约定：package 名字与 import 路径的最后一个单词一致（如导入 math&#x2F;rand 则 package 叫 rand） 大写开头的标识符（变量名、函数名…）：对其他 package 是可访问的 小写开头的标识符：对其他 package 是不可见的 流程控制结构if12345678910111213141516171819202122func main() &#123;true// 一般的条件判断trueif x &gt; 0 &#123;truetruereturn xtrue&#125; else &#123;truetruereturn -xtrue&#125; true// 在条件判断语句前可塞一条语句，使代码更简洁trueif a := b + c; a &lt; 42 &#123;truetruereturn atrue&#125; else &#123;truetruereturn a - 42true&#125; true// 使用 if 做类型断言truevar val interface&#123;&#125;trueval = \"foo\"trueif str, ok := val.(string); ok &#123;truetruefmt.Println(str)true&#125;&#125; Loops123456789// Go 语言中循环结构只有 for，没有 do、while、until、foreach 等等for i := 1; i &lt; 10; i++ &#123;&#125;for ; i &lt; 10; &#123; // 等效于 while 循环&#125;for i &lt; 10 &#123; // 只有一个判断条件时可省去分号&#125;for &#123; // 无条件循环时，等效于 while(true)&#125; switch12345678910111213141516171819202122232425262728293031323334// switch 分支语句switch operatingSystem &#123; case \"darwin\": fmt.Println(\"Mac OS Hipster\") // case 语句自带 break，想执行所有 case 需要手动 fallthrough case \"linux\": fmt.Println(\"Linux Geek\") default: // Windows, BSD, ... fmt.Println(\"Other\")&#125;// 和 if、for 语句一样，可在判断变量之前加入一条赋值语句switch os := runtime.GOOS; os &#123; case \"darwin\": ...&#125;// 在 switch 中还能做比较，相当于 switch (true) &#123;...&#125;number := 42switch &#123; case number &lt; 42: fmt.Println(\"Smaller\") case number == 42: fmt.Println(\"Equal\") case number &gt; 42: fmt.Println(\"Greater\")&#125;// 多个 case 可使用逗号分隔统一处理var char byte = '?'switch char &#123; case ' ', '?', '&amp;', '=', '#', '+', '%': fmt.Println(\"Should escape\")&#125; Arrays, Slices, RangesArrays12345678var a [10]int // 声明长度为 10 的 int 型数组，注意数组类型 = （元素类型 int，元素个数 10）a[3] = 42 // 设置元素值i := a[3] // 读取元素值// 声明并初始化数组var a = [2]int&#123;1, 2&#125;a := [2]int&#123;1, 2&#125; // 简短声明a := [...]int&#123;1, 2&#125; // 数组长度使用 ... 代替，编译器会自动计算元素个数 slices12345678910111213141516171819var a []int // 声明 slice，相当于声明未指定长度的数组var a = []int &#123;1, 2, 3, 4&#125; // 声明并初始化 slice (基于 &#123;&#125; 中给出的底层数组)a := []int&#123;1, 2, 3, 4&#125; // 简短声明chars := []string&#123;0:\"a\", 2:\"c\", 1: \"b\"&#125; // [\"a\", \"b\", \"c\"]var b = a[lo:hi] // 创建从 lo 到 hi-1 的 slice var b = a[1:4] // 创建从 1 到 3 的 slicevar b = a[:3] // 缺省 start index 则默认为 0 var b = a[3:] // 缺省 end index 则默认为 len(a)a = append(a,17,3) // 向 slice a 中追加 17 和 3c := append(a,b...) // 合并两个 slice// 使用 make 创建 slicea = make([]byte, 5, 5) // 第一个参数是长度，第二个参数是容量a = make([]byte, 5) // 容量参数是可选的// 从数组创建 slicex := [3]string&#123;\"Лайка\", \"Белка\", \"Стрелка\"&#125;s := x[:] // slice s 指向底层数组 x 数组和 slice 的操作函数123456789101112131415161718// 迭代数组或 slicefor i, e := range a &#123; // i 是索引 // e 是元素值&#125;// 如果你只要值，可用 _ 来丢弃返回的索引for _, e := range a &#123;&#125;// 如果你只要索引for i := range a &#123;&#125;// 在 Go 1.4 以前的版本，如果 i 和 e 你都不用，直接 range 编译器会报错for range time.Tick(time.Second) &#123; // 每隔 1s 执行一次&#125; map1234567891011121314var m map[string]intm = make(map[string]int)m[\"key\"] = 42fmt.Println(m[\"key\"])delete(m, \"key\")elem, ok := m[\"key\"] // 检查 m 中是否键为 key 的元素，如果有 ok 才为 true// 使用键值对的形式来初始化 mapvar m = map[string]Vertex&#123; \"Bell Labs\": &#123;40.68433, -74.39967&#125;, \"Google\": &#123;37.42202, -122.08408&#125;,&#125; 结构体Go 语言中没有 class 类的概念，取而代之的是 struct，struct 的方法对应到类的成员函数。 123456789101112131415161718192021222324252627282930// struct 是一种类型，也是字段成员的集合体// 声明 structtype Vertex struct &#123; X, Y int&#125;// 初始化 structvar v = Vertex&#123;1, 2&#125; // 字段名有序对应值var v = Vertex&#123;X: 1, Y: 2&#125; // 字段名对应值var v = []Vertex&#123;&#123;1,2&#125;,&#123;5,2&#125;,&#123;5,5&#125;&#125; // 初始化多个 struct 组成的 slice// 访问成员v.X = 4// 在 func 关键字和函数名之间，声明接收者是 struct// 在方法内部，struct 实例被复制，传值引用func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;// 调用方法(有接收者的函数)v.Abs()// 有的方法接收者是指向 struct 的指针// 此时在方法内调用实例，将是传址引用func (v *Vertex) add(n float64) &#123; v.X += n v.Y += n&#125; 匿名结构体使用 map[string]interface{} 开销更小且更为安全。 123point := struct &#123;trueX, Y int&#125;&#123;1, 2&#125; 指针12345p := Vertex&#123;1, 2&#125; // p 是一个 Vertexq := &amp;p // q 是指向 Vertex 的指针r := &amp;Vertex&#123;1, 2&#125; // r 也是指向 Vertex 的指针var s *Vertex = new(Vertex) // new 返回的指向该实例指针 接口123456789101112// 声明接口type Awesomizer interface &#123; Awesomize() string&#125;// 无需手动声明 implement 接口type Foo struct &#123;&#125;// 自定义类型如果实现了接口的所有方法，那它就自动实现了该接口func (foo Foo) Awesomize() string &#123; return \"Awesome!\"&#125; 结构体和接口的组合嵌入123456789101112131415161718192021// 实现 ReadWriter 的类型要同时实现了 Reader 和 Writer 两个接口type ReadWriter interface &#123; Reader Writer&#125;// Server 暴露出 Logger 所有开放的方法type Server struct &#123; Host string Port int *log.Logger&#125;// 初始化自定义的组合类型server := &amp;Server&#123;\"localhost\", 80, log.New(...)&#125;// 组合的结构体能直接跨节点调用方法server.Log(...) // 等同于调用 server.Logger.Log(...)// 字段同理var logger *log.Logger = server.Logger ErrorsGo 中没有异常处理机制，函数在调用时在有可能会产生错误，可返回一个 Error 类型的值，Error 接口： 123type error interface &#123; Error() string&#125; 一个可能产生错误的函数： 12345678910func doStuff() (int, error) &#123;&#125;func main() &#123; result, err := doStuff() if err != nil &#123; // 错误处理 &#125; // 使用 result 处理正常逻辑&#125; 并发goroutinegoroutine（协程）是轻量级的线程（Go runtime 自行管理，而不是操作系统），代码 go f(a, b) 就开了一个运行 f 函数的协程。 123456789101112func doStuff(s string) &#123;&#125;func main() &#123; // 在协程中执行函数 go doStuff(\"foobar\") // 在协程中执行匿名函数 go func (x int) &#123; // 函数实现 &#125;(42)&#125; Channels1234567891011121314151617181920212223242526272829303132ch := make(chan int) // 创建类型为 int 的 channelch &lt;- 42 // 向 channel ch 写数据 42v := &lt;-ch // 从 channel ch 读数据，此时 v 的值为 42truetruetrue// 无缓冲的 channel 此时会阻塞truetruetrue// 如果 channel 中无数据，则读操作会被阻塞，直到有数据可读// 创建带缓冲的 channel// 向带缓冲的 channel 写数据不会被阻塞，除非该缓冲区已满ch := make(chan int, 100)close(ch) // 发送者主动关闭 channel// 在从 channel 读数据的同时检测其是否已关闭// 如果 ok 为 false，则 ch 已被关闭v, ok := &lt;-ch // 从 channel 中读数据直到它被关闭for i := range ch &#123; fmt.Println(i)&#125;// select 语句中 任一 channel 不阻塞则自动执行对应的 casefunc doStuff(channelOut, channelIn chan int) &#123; select &#123; case channelOut &lt;- 42: fmt.Println(\"We could write to channelOut!\") case x := &lt;- channelIn: fmt.Println(\"We could read from channelIn\") case &lt;-time.After(time.Second * 1): fmt.Println(\"timeout\") &#125;&#125; channel 开发原则 向 nil channel 写数据将卡死，一直阻塞 从 nil channel 读数据将卡死，一直阻塞 向已关闭的 channel 写数据将造成 panic 12345678package mainfunc main() &#123;truevar c = make(chan string, 1)truec &lt;- \"Hello, World!\"trueclose(c)truec &lt;- \"Hello, Panic!\"&#125; 运行： 从已关闭的 channel 读数据将返回零值 1234567891011package mainfunc main() &#123;truevar c = make(chan int, 2)truec &lt;- 1truec &lt;- 2trueclose(c)truefor i := 0; i &lt; 3; i++ &#123;truetrueprintln(&lt;-c)true&#125;&#125; 运行： 输出12345678910111213fmt.Println(\"Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ\") // 最基本的输出，会自动加一个换行p := struct &#123; X, Y int &#125;&#123; 17, 2 &#125;fmt.Println( \"My point:\", p, \"x coord=\", p.X ) // 输出结构体字段等s := fmt.Sprintln( \"My point:\", p, \"x coord=\", p.X ) // 组合字符串并返回fmt.Printf(\"%d hex:%x bin:%b fp:%f sci:%e\",17,17,17,17.0,17.0) // 类 C 的格式化输出s2 := fmt.Sprintf( \"%d %f\", 17, 17.0 ) // 格式化字符串并返回hellomsg := ` \"Hello\" in Chinese is 你好 ('Ni Hao') \"Hello\" in Hindi is नमस्ते ('Namaste')` // 声明多行字符串，在前后均使用反引号 ` 代码片段HTTP Server123456789101112131415161718192021222324package mainimport ( \"fmt\" \"net/http\")// 定义响应的数据结构type Hello struct&#123;&#125;// Hello 实现 http.Handler 中定义的 ServeHTTP 方法func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, \"Hello!\")&#125;func main() &#123; var h Hello http.ListenAndServe(\"localhost:4000\", h)&#125;// http.ServeHTTP 在接口内的定义如下：// type Handler interface &#123;// ServeHTTP(w http.ResponseWriter, r *http.Request)// &#125; 运行： 总结上边十七个知识点简要概括了常见语法，可复习使用，但涉及到的细节不多，细读《Go 程序设计语言》 才是。 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"必知必会","slug":"必知必会","permalink":"https://liangyuanzheng.com/tags/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"name":"速查表","slug":"速查表","permalink":"https://liangyuanzheng.com/tags/%E9%80%9F%E6%9F%A5%E8%A1%A8/"}]},{"title":"Golang 新手可能会踩的坑","slug":"Golang-新手可能会踩的坑","date":"2019-09-15T12:40:09.000Z","updated":"2025-10-27T00:35:41.790Z","comments":true,"path":"Golang-新手可能会踩的坑.html","link":"","permalink":"https://liangyuanzheng.com/Golang-%E6%96%B0%E6%89%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%B8%A9%E7%9A%84%E5%9D%91.html","excerpt":"","text":"原文：50 Shades of Go: Traps, Gotchas, and Common Mistakes，翻译已获作者 kcqon 授权。 不久前发现在知乎这篇质量很高的文章，打算加上自己的理解翻译一遍。文章分为三部分：初级篇 1-34，中级篇 35-50，高级篇 51-57 前言Go 是一门简单有趣的编程语言，与其他语言一样，在使用时不免会遇到很多坑，不过它们大多不是 Go 本身的设计缺陷。如果你刚从其他语言转到 Go，那这篇文章里的坑多半会踩到。 如果花时间学习官方 doc、wiki、讨论邮件列表、 Rob Pike 的大量文章以及 Go 的源码，会发现这篇文章中的坑是很常见的，新手跳过这些坑，能减少大量调试代码的时间。 初级篇：1-341. 左大括号 { 一般不能单独放一行在其他大多数语言中，{ 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 ; 来分隔多条语句，比如会在 ) 后加分号： 1234567891011// 错误示例func main() &#123;trueprintln(\"hello world\")&#125;// 等效于func main(); // 无函数体 &#123;trueprintln(\"hello world\")&#125; .&#x2F;main.go: missing function body.&#x2F;main.go: syntax error: unexpected semicolon or newline before { 1234// 正确示例func main() &#123;trueprintln(\"hello world\")&#125; 注意代码块等特殊情况： 123456// &#123; 并不遵守分号注入规则，不会在其后边自动加分，此时可换行func main() &#123;true&#123;truetrueprintln(\"hello world\")true&#125;&#125; 参考：Golang中自动加分号的特殊分隔符 2. 未使用的变量如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。 即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它： 1234567891011121314151617181920212223242526// 错误示例var gvar int // 全局变量，声明不使用也可以func main() &#123;truevar one int // error: one declared and not usedtruetwo := 2 // error: two declared and not usedtruevar three int // error: three declared and not usedtruethree = 3 &#125;// 正确示例// 可以直接注释或移除未使用的变量func main() &#123;truevar one inttrue_ = onetruetruetwo := 2trueprintln(two)truetruevar three inttrueone = threetruevar four inttruefour = four&#125; 3. 未使用的 import如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。 可以使用 _ 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 init() 1234567891011121314151617181920212223// 错误示例import (true\"fmt\" // imported and not used: \"fmt\"true\"log\" // imported and not used: \"log\"true\"time\" // imported and not used: \"time\")func main() &#123;&#125;// 正确示例// 可以使用 goimports 工具来注释或移除未使用到的包import (true_ \"fmt\"true\"log\"true\"time\")func main() &#123;true_ = log.Printlntrue_ = time.Now&#125; 4. 简短声明的变量只能在函数内部使用12345678910// 错误示例myvar := 1 // syntax error: non-declaration statement outside function bodyfunc main() &#123;&#125;// 正确示例var myvar = 1func main() &#123;&#125; 5. 使用简短声明来重复声明变量不能用简短声明方式来单独为一个变量重复声明， := 左侧至少有一个新变量，才允许多变量的重复声明： 12345678910111213// 错误示例func main() &#123; one := 0 one := 1 // error: no new variables on left side of :=&#125;// 正确示例func main() &#123;trueone := 0trueone, two := 1, 2 // two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 errtrueone, two = two, one // 交换两个变量值的简写&#125; 6. 不能使用简短声明来设置字段的值struct 的变量字段不能使用 := 来赋值以使用预定义的变量来避免解决： 1234567891011121314151617181920212223242526272829// 错误示例type info struct &#123;trueresult int&#125;func work() (int, error) &#123;truereturn 3, nil&#125;func main() &#123;truevar data infotruedata.result, err := work() // error: non-name data.result on left side of :=truefmt.Printf(\"info: %+v\\n\", data)&#125;// 正确示例func main() &#123;truevar data infotruevar err error // err 需要预声明truedata.result, err = work()trueif err != nil &#123;truetruefmt.Println(err)truetruereturntrue&#125;truefmt.Printf(\"info: %+v\\n\", data)&#125; 7. 不小心覆盖了变量对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 := 是一个赋值操作符。 如果你在新的代码块中像下边这样误用了 :=，编译不会报错，但是变量不会按你的预期工作： 12345678910func main() &#123;truex := 1trueprintln(x) // 1true&#123;truetrueprintln(x) // 1truetruex := 2truetrueprintln(x) // 2 // 新的 x 变量的作用域只在代码块内部true&#125;trueprintln(x) // 1&#125; 这是 Go 开发者常犯的错，而且不易被发现。 可使用 vet 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 -shadow 选项来启用： 12&gt; go tool vet -shadow main.gomain.go:9: declaration of \"x\" shadows declaration at main.go:5 注意 vet 不会报告全部被覆盖的变量，可以使用 go-nyet 来做进一步的检测： 12&gt; $GOPATH/bin/go-nyet main.gomain.go:10:3:Shadowing variable `x` 8. 显式类型的变量无法使用 nil 来初始化nil 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。 123456789101112// 错误示例func main() &#123; var x = nil // error: use of untyped niltrue_ = x&#125;// 正确示例func main() &#123;truevar x interface&#123;&#125; = niltrue_ = x&#125; 9. 直接使用值为 nil 的 slice、map允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic 12345678910111213// map 错误示例func main() &#123; var m map[string]int m[\"one\"] = 1 // error: panic: assignment to entry in nil map // m := make(map[string]int)// map 的正确声明，分配了实际的内存&#125; // slice 正确示例func main() &#123;truevar s []inttrues = append(s, 1)&#125; 10. map 容量在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 cap() 来检测分配空间的大小： 12345// 错误示例func main() &#123;truem := make(map[string]int, 99)trueprintln(cap(m)) // error: invalid argument m1 (type map[string]int) for cap &#125; 11. string 类型的变量值不能为 nil对那些喜欢用 nil 初始化字符串的人来说，这就是坑： 12345678910111213141516// 错误示例func main() &#123;truevar s string = nil // cannot use nil as type string in assignmenttrueif s == nil &#123; // invalid operation: s == nil (mismatched types string and nil)truetrues = \"default\"true&#125;&#125;// 正确示例func main() &#123;truevar s string // 字符串类型的零值是空串 \"\"trueif s == \"\" &#123;truetrues = \"default\"true&#125;&#125; 12. Array 类型的值作为函数参数在 C&#x2F;C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。 在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的： 12345678910// 数组使用值拷贝传参func main() &#123;truex := [3]int&#123;1,2,3&#125;truefunc(arr [3]int) &#123;truetruearr[0] = 7truetruefmt.Println(arr) // [7 2 3]true&#125;(x)truefmt.Println(x) // [1 2 3] // 并不是你以为的 [7 2 3]&#125; 如果想修改参数数组： 直接传递指向这个数组的指针类型： 12345678910// 传址会修改原数据func main() &#123;truex := [3]int&#123;1,2,3&#125;truefunc(arr *[3]int) &#123;truetrue(*arr)[0] = 7 truetruefmt.Println(arr) // &amp;[7 2 3]true&#125;(&amp;x)truefmt.Println(x) // [7 2 3]&#125; 直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array） 123456789// 会修改 slice 的底层 array，从而修改 slicefunc main() &#123;truex := []int&#123;1, 2, 3&#125;truefunc(arr []int) &#123;truetruearr[0] = 7truetruefmt.Println(x) // [7 2 3]true&#125;(x)truefmt.Println(x) // [7 2 3]&#125; 13. range 遍历 slice 和 array 时混淆了返回值与其他编程语言中的 for-in 、foreach 遍历语句不同，Go 中的 range 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值： 12345678910111213141516// 错误示例func main() &#123;truex := []string&#123;\"a\", \"b\", \"c\"&#125;truefor v := range x &#123;truetruefmt.Println(v) // 1 2 3true&#125;&#125;// 正确示例func main() &#123;truex := []string&#123;\"a\", \"b\", \"c\"&#125;truefor _, v := range x &#123; // 使用 _ 丢弃索引truetruefmt.Println(v)true&#125;&#125; 14. slice 和 array 其实是一维数据看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。 对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。 可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。 使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。 使用“独立”的切片分两步： 创建外部 slice 对每个内部 slice 进行内存分配 注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice 12345678910// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组func main() &#123;truex := 2truey := 4truetruetable := make([][]int, x)truefor i := range table &#123;truetruetable[i] = make([]int, y)true&#125;&#125; 使用“共享底层数组”的切片 创建一个存放原始数据的容器 slice 创建其他的 slice 切割原始 slice 来初始化其他的 slice 12345678910111213141516171819202122func main() &#123;trueh, w := 2, 4trueraw := make([]int, h*w)truefor i := range raw &#123;truetrueraw[i] = itrue&#125;true// 初始化原始 slicetruefmt.Println(raw, &amp;raw[4]) // [0 1 2 3 4 5 6 7] 0xc420012120 truetable := make([][]int, h)truefor i := range table &#123; // 等间距切割原始 slice，创建动态多维数组 table // 0: raw[0*4: 0*4 + 4] // 1: raw[1*4: 1*4 + 4]truetruetable[i] = raw[i*w : i*w + w]true&#125;truefmt.Println(table, &amp;table[1][0]) // [[0 1 2 3] [4 5 6 7]] 0xc420012120&#125; 更多关于多维数组的参考 go-how-is-two-dimensional-arrays-memory-representation what-is-a-concise-way-to-create-a-2d-slice-in-go 15. 访问 map 中不存在的 key和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中： 12&gt; php -r '$v = [\"x\"=&gt;1, \"y\"=&gt;2]; @var_dump($v[\"z\"]);'NULL Go 则会返回元素对应数据类型的零值，比如 nil、&#39;&#39; 、false 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。 检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可： 123456789101112131415// 错误的 key 检测方式func main() &#123;truex := map[string]string&#123;\"one\": \"2\", \"two\": \"\", \"three\": \"3\"&#125;trueif v := x[\"two\"]; v == \"\" &#123;truetruefmt.Println(\"key two is no entry\") // 键 two 存不存在都会返回的空字符串true&#125;&#125;// 正确示例func main() &#123;truex := map[string]string&#123;\"one\": \"2\", \"two\": \"\", \"three\": \"3\"&#125;trueif _, ok := x[\"two\"]; !ok &#123;truetruefmt.Println(\"key two is no entry\")true&#125;&#125; 16. string 类型的值是常量，不可更改尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。 string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可： 12345678910111213141516// 修改字符串的错误示例func main() &#123;truex := \"text\"truex[0] = \"T\" // error: cannot assign to x[0]truefmt.Println(x)&#125;// 修改示例func main() &#123;truex := \"text\"truexBytes := []byte(x)truexBytes[0] = 'T' // 注意此时的 T 是 rune 类型truex = string(xBytes)truefmt.Println(x) // Text&#125; 注意： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。 更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符 1234567func main() &#123;truex := \"text\"truexRunes := []rune(x)truexRunes[0] = '我'truex = string(xRunes)truefmt.Println(x) // 我ext&#125; 17. string 与 byte slice 之间的转换当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语言的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。 Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配： 在 map[string] 中查找 key 时，使用了对应的 []byte，避免做 m[string(key)] 的内存分配 使用 for range 迭代 string 转换为 []byte 的迭代：for i,v := range []byte(str) {...} 雾：参考原文 18. string 与索引操作符对字符串用索引访问返回的不是字符，而是一个 byte 值。 这种处理方式和其他语言一样，比如 PHP 中： 12345678&gt; php -r '$name=\"中文\"; var_dump($name);' # \"中文\" 占用 6 个字节string(6) \"中文\"&gt; php -r '$name=\"中文\"; var_dump($name[0]);' # 把第一个字节当做 Unicode 字符读取，显示 U+FFFDstring(1) \"�\" &gt; php -r '$name=\"中文\"; var_dump($name[0].$name[1].$name[2]);'string(3) \"中\" 12345func main() &#123;truex := \"ascii\"truefmt.Println(x[0]) // 97truefmt.Printf(\"%T\\n\", x[0])// uint8&#125; 如果需要使用 for range 迭代访问字符串中的字符（unicode code point &#x2F; rune），标准库中有 &quot;unicode/utf8&quot; 包来做 UTF8 的相关解码编码。另外 utf8string 也有像 func (s *String) At(i int) rune 等很方便的库函数。 19. 字符串并不都是 UTF8 文本string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。 判断字符串是否是 UTF8 文本，可使用 “unicode&#x2F;utf8” 包中的 ValidString() 函数： 12345678910func main() &#123;truestr1 := \"ABC\"truefmt.Println(utf8.ValidString(str1)) // truetruestr2 := \"A\\xfeC\"truefmt.Println(utf8.ValidString(str2)) // falsetruestr3 := \"A\\\\xfeC\"truefmt.Println(utf8.ValidString(str3)) // true // 把转义字符转义成字面值&#125; 20. 字符串的长度在 Python 中： 12data = u'♥' print(len(data)) # 1 然而在 Go 中： 1234func main() &#123;truechar := \"♥\"truefmt.Println(len(char)) // 3&#125; Go 的内建函数 len() 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。 如果要得到字符串的字符数，可使用 “unicode&#x2F;utf8” 包中的 RuneCountInString(str string) (n int) 1234func main() &#123;truechar := \"♥\"truefmt.Println(utf8.RuneCountInString(char)) // 1&#125; 注意： RuneCountInString 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune： 123456func main() &#123;truechar := \"é\"truefmt.Println(len(char)) // 3truefmt.Println(utf8.RuneCountInString(char)) // 2truefmt.Println(\"cafe\\u0301\") // café // 法文的 cafe，实际上是两个 rune 的组合&#125; 参考：normalization 21. 在多行 array、slice、map 语句中缺少 , 号123456789func main() &#123;truex := []int &#123;truetrue1,truetrue2 // syntax error: unexpected newline, expecting comma or &#125;true&#125;truey := []int&#123;1,2,&#125; truez := []int&#123;1,2&#125; true// ...&#125; 声明语句中 } 折叠到单行后，尾部的 , 不是必需的。 22. log.Fatal 和 log.Panic 不只是 loglog 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal*()、Panic*() 时能做更多日志外的事，如中断程序的执行等： 1234func main() &#123;truelog.Fatal(\"Fatal level log: log entry\") // 输出信息后，程序终止执行truelog.Println(\"Nomal level log: log entry\")&#125; 23. 对内建数据结构的操作并不是同步的尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。 goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。 24. range 迭代 string 得到的值range 得到的索引是字符值（Unicode point &#x2F; rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。 注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用norm 包。 for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。 12345678910func main() &#123;truedata := \"A\\xfe\\x02\\xff\\x04\"truefor _, v := range data &#123;truetruefmt.Printf(\"%#x \", v) // 0x41 0xfffd 0x2 0xfffd 0x4 // 错误true&#125;truefor _, v := range []byte(data) &#123;truetruefmt.Printf(\"%#x \", v) // 0x41 0xfe 0x2 0xff 0x4 // 正确true&#125;&#125; 25. range 迭代 map如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。 Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如： 123456func main() &#123;truem := map[string]int&#123;\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4&#125;truefor k, v := range m &#123;truetruefmt.Println(k, v)true&#125;&#125; 如果你去 Go Playground 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的： 26. switch 中的 fallthrough 语句switch 语句中的 case 代码块会默认带上 break，但可以使用 fallthrough 来强制执行下一个 case 代码块。 12345678910111213func main() &#123;trueisSpace := func(char byte) bool &#123;truetrueswitch char &#123;truetruecase ' ': // 空格符会直接 break，返回 false // 和其他语言不一样truetrue// fallthrough // 返回 truetruetruecase '\\t':truetruetruereturn truetruetrue&#125;truetruereturn falsetrue&#125;truefmt.Println(isSpace('\\t')) // truetruefmt.Println(isSpace(' ')) // false&#125; 不过你可以在 case 代码块末尾使用 fallthrough，强制执行下一个 case 代码块。 也可以改写 case 为多条件判断： 1234567891011func main() &#123;trueisSpace := func(char byte) bool &#123;truetrueswitch char &#123;truetruecase ' ', '\\t':truetruetruereturn truetruetrue&#125;truetruereturn falsetrue&#125;truefmt.Println(isSpace('\\t')) // truetruefmt.Println(isSpace(' ')) // true&#125; 27. 自增和自减运算很多编程语言都自带前置后置的 ++、-- 运算。但 Go 特立独行，去掉了前置操作，同时 ++、— 只作为运算符而非表达式。 12345678910111213141516// 错误示例func main() &#123;truedata := []int&#123;1, 2, 3&#125;truei := 0true++i // syntax error: unexpected ++, expecting &#125;truefmt.Println(data[i++]) // syntax error: unexpected ++, expecting :&#125;// 正确示例func main() &#123;truedata := []int&#123;1, 2, 3&#125;truei := 0truei++truefmt.Println(data[i]) // 2&#125; 28. 按位取反很多编程语言使用 ~ 作为一元按位取反（NOT）操作符，Go 重用 ^ XOR 操作符来按位取反： 123456789101112// 错误的取反操作func main() &#123;truefmt.Println(~2) // bitwise complement operator is ^&#125;// 正确示例func main() &#123;truevar d uint8 = 2truefmt.Printf(\"%08b\\n\", d) // 00000010truefmt.Printf(\"%08b\\n\", ^d) // 11111101&#125; 同时 ^ 也是按位异或（XOR）操作符。 一个操作符能重用两次，是因为一元的 NOT 操作 NOT 0x02，与二元的 XOR 操作 0x22 XOR 0xff 是一致的。 Go 也有特殊的操作符 AND NOT &amp;^ 操作符，不同位才取1。 1234567891011121314func main() &#123;truevar a uint8 = 0x82truevar b uint8 = 0x02truefmt.Printf(\"%08b [A]\\n\", a)truefmt.Printf(\"%08b [B]\\n\", b)truefmt.Printf(\"%08b (NOT B)\\n\", ^b)truefmt.Printf(\"%08b ^ %08b = %08b [B XOR 0xff]\\n\", b, 0xff, b^0xff)truefmt.Printf(\"%08b ^ %08b = %08b [A XOR B]\\n\", a, b, a^b)truefmt.Printf(\"%08b &amp; %08b = %08b [A AND B]\\n\", a, b, a&amp;b)truefmt.Printf(\"%08b &amp;^%08b = %08b [A 'AND NOT' B]\\n\", a, b, a&amp;^b)truefmt.Printf(\"%08b&amp;(^%08b)= %08b [A AND (NOT B)]\\n\", a, b, a&amp;(^b))&#125; 1234567810000010 [A]00000010 [B]11111101 (NOT B)00000010 ^ 11111111 = 11111101 [B XOR 0xff]10000010 ^ 00000010 = 10000000 [A XOR B]10000010 &amp; 00000010 = 00000010 [A AND B]10000010 &amp;^00000010 = 10000000 [A 'AND NOT' B]10000010&amp;(^00000010)= 10000000 [A AND (NOT B)] 29. 运算符的优先级除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。 12345678910111213141516func main() &#123;truefmt.Printf(\"0x2 &amp; 0x2 + 0x4 -&gt; %#x\\n\", 0x2&amp;0x2+0x4) // &amp; 优先 +true//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6true//Go: (0x2 &amp; 0x2) + 0x4true//C++: 0x2 &amp; (0x2 + 0x4) -&gt; 0x2truefmt.Printf(\"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\\n\", 0x2+0x2&lt;&lt;0x1) // &lt;&lt; 优先 +true//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6true//Go: 0x2 + (0x2 &lt;&lt; 0x1)true//C++: (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8truefmt.Printf(\"0xf | 0x2 ^ 0x2 -&gt; %#x\\n\", 0xf|0x2^0x2) // | 优先 ^true//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xdtrue//Go: (0xf | 0x2) ^ 0x2true//C++: 0xf | (0x2 ^ 0x2) -&gt; 0xf&#125; 优先级列表： 123456Precedence Operator 5 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 4 + - | ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 || 30. 不导出的 struct 字段无法被 encode以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值： 1234567891011func main() &#123;truein := MyData&#123;1, \"two\"&#125;truefmt.Printf(\"%#v\\n\", in) // main.MyData&#123;One:1, two:\"two\"&#125;trueencoded, _ := json.Marshal(in)truefmt.Println(string(encoded)) // &#123;\"One\":1&#125; // 私有字段 two 被忽略了truevar out MyDatatruejson.Unmarshal(encoded, &amp;out)truefmt.Printf(\"%#v\\n\", out) // main.MyData&#123;One:1, two:\"\"&#125;&#125; 31. 程序退出时还有 goroutine 在执行程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意： 123456789101112131415// 主程序会直接退出func main() &#123;trueworkerCount := 2truefor i := 0; i &lt; workerCount; i++ &#123;truetruego doIt(i)true&#125;truetime.Sleep(1 * time.Second)truefmt.Println(\"all done!\")&#125;func doIt(workerID int) &#123;truefmt.Printf(\"[%v] is running\\n\", workerID)truetime.Sleep(3 * time.Second) // 模拟 goroutine 正在执行 truefmt.Printf(\"[%v] is done\\n\", workerID)&#125; 如下，main() 主程序不等两个 goroutine 执行完就直接退出了： 常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。 如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 kill 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel： 1234567891011121314151617181920212223// 等待所有 goroutine 执行完毕// 进入死锁func main() &#123;truevar wg sync.WaitGrouptruedone := make(chan struct&#123;&#125;)trueworkerCount := 2truefor i := 0; i &lt; workerCount; i++ &#123;truetruewg.Add(1)truetruego doIt(i, done, wg)true&#125;trueclose(done)truewg.Wait()truefmt.Println(\"all done!\")&#125;func doIt(workerID int, done &lt;-chan struct&#123;&#125;, wg sync.WaitGroup) &#123;truefmt.Printf(\"[%v] is running\\n\", workerID)truedefer wg.Done()true&lt;-donetruefmt.Printf(\"[%v] is done\\n\", workerID)&#125; 执行结果： 看起来好像 goroutine 都执行完了，然而报错： fatal error: all goroutines are asleep - deadlock! 为什么会发生死锁？goroutine 在退出前调用了 wg.Done() ，程序应该正常退出的。 原因是 goroutine 得到的 “WaitGroup” 变量是 var wg WaitGroup 的一份拷贝值，即 doIt() 传参只传值。所以哪怕在每个 goroutine 中都调用了 wg.Done()， 主程序中的 wg 变量并不会受到影响。 1234567891011121314151617181920212223242526272829303132333435363738// 等待所有 goroutine 执行完毕// 使用传址方式为 WaitGroup 变量传参// 使用 channel 关闭 goroutinefunc main() &#123;truevar wg sync.WaitGrouptruedone := make(chan struct&#123;&#125;)truech := make(chan interface&#123;&#125;)trueworkerCount := 2truefor i := 0; i &lt; workerCount; i++ &#123;truetruewg.Add(1) go doIt(i, ch, done, &amp;wg) // wg 传指针，doIt() 内部会改变 wg 的值true&#125;truefor i := 0; i &lt; workerCount; i++ &#123; // 向 ch 中发送数据，关闭 goroutinetruetruech &lt;- itrue&#125;trueclose(done)truewg.Wait()trueclose(ch)truefmt.Println(\"all done!\")&#125;func doIt(workerID int, ch &lt;-chan interface&#123;&#125;, done &lt;-chan struct&#123;&#125;, wg *sync.WaitGroup) &#123;truefmt.Printf(\"[%v] is running\\n\", workerID)truedefer wg.Done()truefor &#123;truetrueselect &#123;truetruecase m := &lt;-ch:truetruetruefmt.Printf(\"[%v] m =&gt; %v\\n\", workerID, m)truetruecase &lt;-done:truetruetruefmt.Printf(\"[%v] is done\\n\", workerID)truetruetruereturntruetrue&#125;true&#125;&#125; 运行效果： 32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如： 12345678910111213func main() &#123;truech := make(chan string)truego func() &#123;truetruefor m := range ch &#123;truetruetruefmt.Println(\"Processed:\", m)truetruetruetime.Sleep(1 * time.Second) // 模拟需要长时间运行的操作truetrue&#125;true&#125;()truech &lt;- \"cmd.1\"truech &lt;- \"cmd.2\" // 不会被接收处理&#125; 运行效果： 33. 向已关闭的 channel 发送数据会造成 panic从已关闭的 channel 接收数据是安全的： 接收状态值 ok 是 false 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 false 向已关闭的 channel 中发送数据会造成 panic： 123456789101112func main() &#123;truech := make(chan int)truefor i := 0; i &lt; 3; i++ &#123;truetruego func(idx int) &#123;truetruetruech &lt;- idxtruetrue&#125;(i)true&#125;truefmt.Println(&lt;-ch) // 输出第一个发送的值trueclose(ch) // 不能关闭，还有其他的 sendertruetime.Sleep(2 * time.Second) // 模拟做其他的操作&#125; 运行结果： 针对上边有 bug 的这个例子，可使用一个废弃 channel done 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 &lt;- done 的结果是 {}： 12345678910111213141516171819func main() &#123;truech := make(chan int)truedone := make(chan struct&#123;&#125;)truefor i := 0; i &lt; 3; i++ &#123;truetruego func(idx int) &#123;truetruetrueselect &#123;truetruetruecase ch &lt;- (idx + 1) * 2:truetruetruetruefmt.Println(idx, \"Send result\")truetruetruecase &lt;-done:truetruetruetruefmt.Println(idx, \"Exiting\")truetruetrue&#125;truetrue&#125;(i)true&#125;truefmt.Println(\"Result: \", &lt;-ch)trueclose(done)truetime.Sleep(3 * time.Second)&#125; 运行效果： 34. 使用了值为 nil 的 channel在一个值为 nil 的 channel 上发送和接收数据将永久阻塞： 1234567891011func main() &#123;truevar ch chan int // 未初始化，值为 niltruefor i := 0; i &lt; 3; i++ &#123;truetruego func(i int) &#123;truetruetruech &lt;- itruetrue&#125;(i)true&#125;truefmt.Println(\"Result: \", &lt;-ch)truetime.Sleep(2 * time.Second)&#125; runtime 死锁错误： fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive (nil chan)] 利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块： 12345678910111213141516171819202122232425262728293031323334func main() &#123;trueinCh := make(chan int)trueoutCh := make(chan int)truego func() &#123;truetruevar in &lt;-chan int = inChtruetruevar out chan&lt;- inttruetruevar val inttruetruefor &#123;truetruetrueselect &#123;truetruetruecase out &lt;- val:truetruetruetrueprintln(\"--------\")truetruetruetrueout = niltruetruetruetruein = inChtruetruetruecase val = &lt;-in:truetruetruetrueprintln(\"++++++++++\")truetruetruetrueout = outChtruetruetruetruein = niltruetruetrue&#125;truetrue&#125;true&#125;()truego func() &#123;truetruefor r := range outCh &#123;truetruetruefmt.Println(\"Result: \", r)truetrue&#125;true&#125;()truetime.Sleep(0)trueinCh &lt;- 1trueinCh &lt;- 2truetime.Sleep(3 * time.Second)&#125; 运行效果： 34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。 除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值: 12345678910111213141516171819202122232425262728type data struct &#123;truenum inttruekey *stringtrueitems map[string]bool&#125;func (this *data) pointerFunc() &#123;truethis.num = 7&#125;func (this data) valueFunc() &#123;truethis.num = 8true*this.key = \"valueFunc.key\"truethis.items[\"valueFunc\"] = true&#125;func main() &#123;truekey := \"key1\"trued := data&#123;1, &amp;key, make(map[string]bool)&#125;truefmt.Printf(\"num=%v key=%v items=%v\\n\", d.num, *d.key, d.items)trued.pointerFunc() // 修改 num 的值为 7truefmt.Printf(\"num=%v key=%v items=%v\\n\", d.num, *d.key, d.items)trued.valueFunc() // 修改 key 和 items 的值truefmt.Printf(\"num=%v key=%v items=%v\\n\", d.num, *d.key, d.items)&#125; 运行结果： 中级篇：35-5035. 关闭 HTTP 的响应体使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置： 1234567891011121314151617181920// 请求失败造成 panicfunc main() &#123;trueresp, err := http.Get(\"https://api.ipify.org?format=json\")truedefer resp.Body.Close() // resp 可能为 nil，不能读取 Bodytrueif err != nil &#123;truetruefmt.Println(err)truetruereturntrue&#125;truebody, err := ioutil.ReadAll(resp.Body)truecheckError(err)truefmt.Println(string(body))&#125;func checkError(err error) &#123;trueif err != nil&#123;truetruelog.Fatalln(err)true&#125;&#125; 上边的代码能正确发起请求，但是一旦请求失败，变量 resp 值为 nil，造成 panic： panic: runtime error: invalid memory address or nil pointer dereference 应该先检查 HTTP 响应错误为 nil，再调用 resp.Body.Close() 来关闭响应体： 1234567891011// 大多数情况正确的示例func main() &#123;trueresp, err := http.Get(\"https://api.ipify.org?format=json\")truecheckError(err) truedefer resp.Body.Close() // 绝大多数情况下的正确关闭方式truebody, err := ioutil.ReadAll(resp.Body)truecheckError(err)truefmt.Println(string(body))&#125; 输出： Get https://api.ipify.org?format=json: x509: certificate signed by unknown authority 绝大多数请求失败的情况下，resp 的值为 nil 且 err 为 non-nil。但如果你得到的是重定向错误，那它俩的值都是 non-nil，最后依旧可能发生内存泄露。2 个解决办法： 可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。 手动调用 defer 来关闭响应体： 12345678910111213141516// 正确示例func main() &#123;trueresp, err := http.Get(\"http://www.baidu.com\")true // 关闭 resp.Body 的正确姿势 if resp != nil &#123;truetruedefer resp.Body.Close()true&#125;truecheckError(err)truebody, err := ioutil.ReadAll(resp.Body)truecheckError(err)truefmt.Println(string(body))&#125; resp.Body.Close() 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。 如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入： 1_, err = io.Copy(ioutil.Discard, resp.Body) // 手动丢弃读取完毕的数据 如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据： 1json.NewDecoder(resp.Body).Decode(&amp;data) 36. 关闭 HTTP 连接一些支持 HTTP1.1 或 HTTP1.0 配置了 connection: keep-alive 选项的服务器会保持一段时间的长连接。但标准库 “net&#x2F;http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后： 直接设置请求变量的 Close 字段值为 true，每次请求结束后就会主动关闭连接。 设置 Header 请求头部选项 Connection: close，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。 12345678910111213141516171819// 主动关闭连接func main() &#123;truereq, err := http.NewRequest(\"GET\", \"http://golang.org\", nil)truecheckError(err)truereq.Close = truetrue//req.Header.Add(\"Connection\", \"close\") // 等效的关闭方式trueresp, err := http.DefaultClient.Do(req)trueif resp != nil &#123;truetruedefer resp.Body.Close()true&#125;truecheckError(err)truebody, err := ioutil.ReadAll(resp.Body)truecheckError(err)truefmt.Println(string(body))&#125; 你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接： 1234567891011121314151617func main() &#123;truetr := http.Transport&#123;DisableKeepAlives: true&#125;trueclient := http.Client&#123;Transport: &amp;tr&#125;trueresp, err := client.Get(\"https://golang.google.cn/\")trueif resp != nil &#123;truetruedefer resp.Body.Close()true&#125;truecheckError(err)truefmt.Println(resp.StatusCode) // 200truebody, err := ioutil.ReadAll(resp.Body)truecheckError(err)truefmt.Println(len(string(body)))&#125; 根据需求选择使用场景： 若你的程序要向同一服务器发大量请求，使用默认的保持长连接。 若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 fs.file-max 的值。 37. 将 JSON 中的数字解码为 interface 类型在 encode&#x2F;decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic： 123456789101112func main() &#123;truevar data = []byte(`&#123;\"status\": 200&#125;`)truevar result map[string]interface&#123;&#125;trueif err := json.Unmarshal(data, &amp;result); err != nil &#123;truetruelog.Fatalln(err)true&#125;truefmt.Printf(\"%T\\n\", result[\"status\"]) // float64truevar status = result[\"status\"].(int) // 类型断言错误truefmt.Println(\"Status value: \", status)&#125; panic: interface conversion: interface {} is float64, not int 如果你尝试 decode 的 JSON 字段是整型，你可以： 将 int 值转为 float 统一使用 将 decode 后需要的 float 值转为 int 使用 123456789101112// 将 decode 的值转为 int 使用func main() &#123; var data = []byte(`&#123;\"status\": 200&#125;`) var result map[string]interface&#123;&#125; if err := json.Unmarshal(data, &amp;result); err != nil &#123; log.Fatalln(err) &#125; var status = uint64(result[\"status\"].(float64)) fmt.Println(\"Status value: \", status)&#125; 使用 Decoder 类型来 decode JSON 数据，明确表示字段的值类型 12345678910111213141516171819202122232425262728293031// 指定字段类型func main() &#123;truevar data = []byte(`&#123;\"status\": 200&#125;`)truevar result map[string]interface&#123;&#125; truevar decoder = json.NewDecoder(bytes.NewReader(data))truedecoder.UseNumber()trueif err := decoder.Decode(&amp;result); err != nil &#123;truetruelog.Fatalln(err)true&#125;truevar status, _ = result[\"status\"].(json.Number).Int64()truefmt.Println(\"Status value: \", status)&#125; // 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用 // 将数据转为 decode 为 string func main() &#123; var data = []byte(&#123;\"status\": 200&#125;) var result map[string]interface&#123;&#125; var decoder = json.NewDecoder(bytes.NewReader(data)) decoder.UseNumber() if err := decoder.Decode(&amp;result); err != nil &#123; log.Fatalln(err) &#125; var status uint64 err := json.Unmarshal([]byte(result[\"status\"].(json.Number).String()), &amp;status);truecheckError(err) fmt.Println(\"Status value: \", status)&#125; ​- 使用 struct 类型将你需要的数据映射为数值型 1234567891011// struct 中指定字段类型func main() &#123; var data = []byte(`&#123;\"status\": 200&#125;`) var result struct &#123; Status uint64 `json:\"status\"` &#125; err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result) checkError(err)truefmt.Printf(\"Result: %+v\", result)&#125; 可以使用 struct 将数值类型映射为 json.RawMessage 原生数据类型 适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况： 123456789101112131415161718192021222324252627282930313233// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型func main() &#123;truerecords := [][]byte&#123;truetrue[]byte(`&#123;\"status\":200, \"tag\":\"one\"&#125;`),truetrue[]byte(`&#123;\"status\":\"ok\", \"tag\":\"two\"&#125;`),true&#125;truefor idx, record := range records &#123;truetruevar result struct &#123;truetruetrueStatusCode uint64truetruetrueStatusName stringtruetruetrueStatus json.RawMessage `json:\"status\"`truetruetrueTag string `json:\"tag\"`truetrue&#125;truetrueerr := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)truetruecheckError(err)truetruevar name stringtruetrueerr = json.Unmarshal(result.Status, &amp;name)truetrueif err == nil &#123;truetruetrueresult.StatusName = nametruetrue&#125;truetruevar code uint64truetrueerr = json.Unmarshal(result.Status, &amp;code)truetrueif err == nil &#123;truetruetrueresult.StatusCode = codetruetrue&#125;truetruefmt.Printf(\"[%v] result =&gt; %+v\\n\", idx, result)true&#125;&#125; ​ 38. struct、array、slice 和 map 的值比较可以使用相等运算符 == 来比较结构体变量，前提是两个结构体的成员都是可比较的类型： 123456789101112131415161718type data struct &#123;truenum inttruefp float32truecomplex complex64truestr stringtruechar runetrueyes booltrueevents &lt;-chan stringtruehandler interface&#123;&#125;trueref *bytetrueraw [10]byte&#125;func main() &#123;truev1 := data&#123;&#125;truev2 := data&#123;&#125;truefmt.Println(\"v1 == v2: \", v1 == v2) // true&#125; 如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。 1234567891011121314type data struct &#123;truenum inttruechecks [10]func() bool // 无法比较truedoIt func() bool // 无法比较truem map[string]string // 无法比较truebytes []byte // 无法比较&#125;func main() &#123;truev1 := data&#123;&#125;truev2 := data&#123;&#125;truefmt.Println(\"v1 == v2: \", v1 == v2)&#125; invalid operation: v1 &#x3D;&#x3D; v2 (struct containing [10]func() bool cannot be compared) Go 提供了一些库函数来比较那些无法使用 == 比较的变量，比如使用 “reflect” 包的 DeepEqual() ： 123456789101112131415// 比较相等运算符无法比较的元素func main() &#123;truev1 := data&#123;&#125;truev2 := data&#123;&#125;truefmt.Println(\"v1 == v2: \", reflect.DeepEqual(v1, v2)) // truetruem1 := map[string]string&#123;\"one\": \"a\", \"two\": \"b\"&#125;truem2 := map[string]string&#123;\"two\": \"b\", \"one\": \"a\"&#125;truefmt.Println(\"v1 == v2: \", reflect.DeepEqual(m1, m2)) // truetrues1 := []int&#123;1, 2, 3&#125;trues2 := []int&#123;1, 2, 3&#125; // 注意两个 slice 相等，值和顺序必须一致truefmt.Println(\"v1 == v2: \", reflect.DeepEqual(s1, s2)) // true&#125; 这种比较方式可能比较慢，根据你的程序需求来使用。DeepEqual() 还有其他用法： 12345func main() &#123;truevar b1 []byte = niltrueb2 := []byte&#123;&#125;truefmt.Println(\"b1 == b2: \", reflect.DeepEqual(b1, b2)) // false&#125; 注意： DeepEqual() 并不总适合于比较 slice 123456789101112131415161718func main() &#123;truevar str = \"one\"truevar in interface&#123;&#125; = \"one\"truefmt.Println(\"str == in: \", reflect.DeepEqual(str, in)) // truetruev1 := []string&#123;\"one\", \"two\"&#125;truev2 := []string&#123;\"two\", \"one\"&#125;truefmt.Println(\"v1 == v2: \", reflect.DeepEqual(v1, v2)) // falsetruedata := map[string]interface&#123;&#125;&#123;truetrue\"code\": 200,truetrue\"value\": []string&#123;\"one\", \"two\"&#125;,true&#125;trueencoded, _ := json.Marshal(data)truevar decoded map[string]interface&#123;&#125;truejson.Unmarshal(encoded, &amp;decoded)truefmt.Println(\"data == decoded: \", reflect.DeepEqual(data, decoded)) // false&#125; 如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 ToUpper() 和 ToLower() 函数。比较其他语言的 byte 或 string，应使用 bytes.EqualFold() 和 strings.EqualFold() 如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 reflect.DeepEqual()、bytes.Equal()、 bytes.Compare()。这三个函数容易对程序造成 timing attacks，此时应使用 “crypto&#x2F;subtle” 包中的 subtle.ConstantTimeCompare() 等函数 reflect.DeepEqual() 认为空 slice 与 nil slice 并不相等，但注意 byte.Equal() 会认为二者相等： 12345678func main() &#123;truevar b1 []byte = niltrueb2 := []byte&#123;&#125; // b1 与 b2 长度相等、有相同的字节序 // nil 与 slice 在字节上是相同的 fmt.Println(\"b1 == b2: \", bytes.Equal(b1, b2)) // true&#125; 39. 从 panic 中恢复在一个 defer 延迟执行的函数中调用 recover() ，它便能捕捉 &#x2F; 中断 panic 123456789101112131415// 错误的 recover 调用示例func main() &#123;truerecover() // 什么都不会捕捉truepanic(\"not good\") // 发生 panic，主程序退出truerecover() // 不会被执行trueprintln(\"ok\")&#125;// 正确的 recover 调用示例func main() &#123;truedefer func() &#123;truetruefmt.Println(\"recovered: \", recover())true&#125;()truepanic(\"not good\")&#125; 从上边可以看出，recover() 仅在 defer 执行的函数中调用才会生效。 1234567891011// 错误的调用示例func main() &#123;truedefer func() &#123;truetruedoRecover()true&#125;()truepanic(\"not good\")&#125;func doRecover() &#123;truefmt.Println(\"recobered: \", recover())&#125; recobered: panic: not good 40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址： 1234567func main() &#123;truedata := []int&#123;1, 2, 3&#125;truefor _, v := range data &#123;truetruev *= 10 // data 中原有元素是不会被修改的true&#125;truefmt.Println(\"data: \", data) // data: [1 2 3]&#125; 如果要修改原有元素的值，应该使用索引直接访问： 1234567func main() &#123;truedata := []int&#123;1, 2, 3&#125;truefor i, v := range data &#123;truetruedata[i] = v * 10 true&#125;truefmt.Println(\"data: \", data) // data: [10 20 30]&#125; 如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值： 1234567func main() &#123;truedata := []*struct&#123; num int &#125;&#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;,&#125;truefor _, v := range data &#123;truetruev.num *= 10 // 直接使用指针更新true&#125;truefmt.Println(data[0], data[1], data[2]) // &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;&#125; 41. slice 中隐藏的数据从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。 12345678910func get() []byte &#123;trueraw := make([]byte, 10000)truefmt.Println(len(raw), cap(raw), &amp;raw[0]) // 10000 10000 0xc420080000truereturn raw[:3] // 重新分配容量为 10000 的 slice&#125;func main() &#123;truedata := get()truefmt.Println(len(data), cap(data), &amp;data[0]) // 3 10000 0xc420080000&#125; 可以通过拷贝临时 slice 的数据，而不是重新切片来解决： 123456789101112func get() (res []byte) &#123;trueraw := make([]byte, 10000)truefmt.Println(len(raw), cap(raw), &amp;raw[0]) // 10000 10000 0xc420080000trueres = make([]byte, 3)truecopy(res, raw[:3])truereturn&#125;func main() &#123;truedata := get()truefmt.Println(len(data), cap(data), &amp;data[0]) // 3 3 0xc4200160b8&#125; 42. Slice 中数据的误用举个简单例子，重写文件路径（存储在 slice 中） 分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径： 1234567891011121314151617181920// 错误使用 slice 的拼接示例func main() &#123;truepath := []byte(\"AAAA/BBBBBBBBB\")truesepIndex := bytes.IndexByte(path, '/') // 4trueprintln(sepIndex)truedir1 := path[:sepIndex]truedir2 := path[sepIndex+1:]trueprintln(\"dir1: \", string(dir1)) // AAAAtrueprintln(\"dir2: \", string(dir2)) // BBBBBBBBBtruedir1 = append(dir1, \"suffix\"...) println(\"current path: \", string(path)) // AAAAsuffixBBBB truepath = bytes.Join([][]byte&#123;dir1, dir2&#125;, []byte&#123;'/'&#125;)trueprintln(\"dir1: \", string(dir1)) // AAAAsuffixtrueprintln(\"dir2: \", string(dir2)) // uffixBBBBtrueprintln(\"new path: \", string(path)) // AAAAsuffix/uffixBBBB // 错误结果&#125; 拼接的结果不是正确的 AAAAsuffix/BBBBBBBBB，因为 dir1、 dir2 两个 slice 引用的数据都是 path 的底层数组，第 13 行修改 dir1 同时也修改了 path，也导致了 dir2 的修改 解决方法： 重新分配新的 slice 并拷贝你需要的数据 使用完整的 slice 表达式：input[low:high:max]，容量便调整为 max - low 1234567891011121314// 使用 full slice expressionfunc main() &#123;truepath := []byte(\"AAAA/BBBBBBBBB\")truesepIndex := bytes.IndexByte(path, '/') // 4 dir1 := path[:sepIndex:sepIndex] // 此时 cap(dir1) 指定为4， 而不是先前的 16truedir2 := path[sepIndex+1:]truedir1 = append(dir1, \"suffix\"...)truepath = bytes.Join([][]byte&#123;dir1, dir2&#125;, []byte&#123;'/'&#125;)trueprintln(\"dir1: \", string(dir1)) // AAAAsuffixtrueprintln(\"dir2: \", string(dir2)) // BBBBBBBBBtrueprintln(\"new path: \", string(path)) // AAAAsuffix/BBBBBBBBB&#125; 第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组 43. 旧 slice当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。 某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。 1234567891011121314151617181920212223// 超过容量将重新分配数组来拷贝值、重新存储func main() &#123;trues1 := []int&#123;1, 2, 3&#125;truefmt.Println(len(s1), cap(s1), s1) // 3 3 [1 2 3 ]trues2 := s1[1:]truefmt.Println(len(s2), cap(s2), s2) // 2 2 [2 3]truefor i := range s2 &#123;truetrues2[i] += 20true&#125;true// 此时的 s1 与 s2 是指向同一个底层数组的truefmt.Println(s1) // [1 22 23]truefmt.Println(s2) // [22 23]trues2 = append(s2, 4) // 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存truefor i := range s2 &#123;truetrues2[i] += 10true&#125;truefmt.Println(s1) // [1 22 23] // 此时的 s1 不再更新，为旧数据truefmt.Println(s2) // [32 33 14]&#125; 44. 类型声明与方法从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法： 12345678// 定义 Mutex 的自定义类型type myMutex sync.Mutexfunc main() &#123;truevar mtx myMutextruemtx.Lock()truemtx.UnLock()&#125; mtx.Lock undefined (type myMutex has no field or method Lock)… 如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中： 12345678910// 类型以字段形式直接嵌入type myLocker struct &#123;truesync.Mutex&#125;func main() &#123;truevar locker myLockertruelocker.Lock()truelocker.Unlock()&#125; interface 类型声明也保留它的方法集： 1234567type myLocker sync.Lockerfunc main() &#123;truevar locker myLockertruelocker.Lock()truelocker.Unlock()&#125; 45. 跳出 for-switch 和 for-select 代码块没有指定标签的 break 只会跳出 switch&#x2F;select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块： 12345678910111213// break 配合 label 跳出指定代码块func main() &#123;loop:truefor &#123;truetrueswitch &#123;truetruecase true:truetruetruefmt.Println(\"breaking out...\")truetruetrue//break // 死循环，一直打印 breaking out...truetruetruebreak looptruetrue&#125;true&#125;truefmt.Println(\"out...\")&#125; goto 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。 46. for 语句中的迭代变量与闭包函数for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值： 123456789101112func main() &#123;truedata := []string&#123;\"one\", \"two\", \"three\"&#125;truefor _, v := range data &#123;truetruego func() &#123;truetruetruefmt.Println(v)truetrue&#125;()true&#125;truetime.Sleep(3 * time.Second)true// 输出 three three three&#125; 最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参： 12345678910111213func main() &#123;truedata := []string&#123;\"one\", \"two\", \"three\"&#125;truefor _, v := range data &#123;truetruevCopy := vtruetruego func() &#123;truetruetruefmt.Println(vCopy)truetrue&#125;()true&#125;truetime.Sleep(3 * time.Second)true// 输出 one two three&#125; 另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数： 123456789101112func main() &#123;truedata := []string&#123;\"one\", \"two\", \"three\"&#125;truefor _, v := range data &#123;truetruego func(in string) &#123;truetruetruefmt.Println(in)truetrue&#125;(v)true&#125;truetime.Sleep(3 * time.Second)true// 输出 one two three&#125; 注意下边这个稍复杂的 3 个示例区别： 123456789101112131415161718192021222324252627282930313233343536373839type field struct &#123;truename string&#125;func (p *field) print() &#123;truefmt.Println(p.name)&#125;// 错误示例func main() &#123;truedata := []field&#123;&#123;\"one\"&#125;, &#123;\"two\"&#125;, &#123;\"three\"&#125;&#125;truefor _, v := range data &#123;truetruego v.print()true&#125;truetime.Sleep(3 * time.Second)true// 输出 three three three &#125;// 正确示例func main() &#123;truedata := []field&#123;&#123;\"one\"&#125;, &#123;\"two\"&#125;, &#123;\"three\"&#125;&#125;truefor _, v := range data &#123;truetruev := vtruetruego v.print()true&#125;truetime.Sleep(3 * time.Second)true// 输出 one two three&#125;// 正确示例func main() &#123;truedata := []*field&#123;&#123;\"one\"&#125;, &#123;\"two\"&#125;, &#123;\"three\"&#125;&#125;truefor _, v := range data &#123; // 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同truetruego v.print()true&#125;truetime.Sleep(3 * time.Second)true// 输出 one two three&#125; 47. defer 函数的参数值对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值： 123456// 在 defer 函数中参数会提前求值func main() &#123;truevar i = 1truedefer fmt.Println(\"result: \", func() int &#123; return i * 2 &#125;())truei++&#125; result: 2 48. defer 函数的执行时机对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。 比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题： 123456789101112131415161718192021222324252627282930313233343536373839// 命令行参数指定目录名// 遍历读取目录下的文件func main() &#123;trueif len(os.Args) != 2 &#123;truetrueos.Exit(1)true&#125;truedir := os.Args[1]truestart, err := os.Stat(dir)trueif err != nil || !start.IsDir() &#123;truetrueos.Exit(2)true&#125;truevar targets []stringtruefilepath.Walk(dir, func(fPath string, fInfo os.FileInfo, err error) error &#123;truetrueif err != nil &#123;truetruetruereturn errtruetrue&#125;truetrueif !fInfo.Mode().IsRegular() &#123;truetruetruereturn niltruetrue&#125;truetruetargets = append(targets, fPath)truetruereturn niltrue&#125;)truefor _, target := range targets &#123;truetruef, err := os.Open(target)truetrueif err != nil &#123;truetruetruefmt.Println(\"bad target:\", target, \"error:\", err) //error:too many open filestruetruetruebreaktruetrue&#125;truetruedefer f.Close() // 在每次 for 语句块结束时，不会关闭文件资源truetruetruetrue// 使用 f 资源true&#125;&#125; 先创建 10000 个文件： 1234#!/bin/bashfor n in &#123;1..10000&#125;; dotrueecho content &gt; \"file$&#123;n&#125;.txt\"done 运行效果： 解决办法：defer 延迟执行的函数写入匿名函数中： 1234567891011121314151617// 目录遍历正常func main() &#123; // ...truefor _, target := range targets &#123;truetruefunc() &#123;truetruetruef, err := os.Open(target)truetruetrueif err != nil &#123;truetruetruetruefmt.Println(\"bad target:\", target, \"error:\", err)truetruetruetruereturn // 在匿名函数内使用 return 代替 break 即可truetruetrue&#125;truetruetruedefer f.Close() // 匿名函数执行结束，调用关闭文件资源truetruetruetruetruetrue// 使用 f 资源truetrue&#125;()true&#125;&#125; 当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 f.Close() 来关闭。 49. 失败的类型断言在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况： 1234567891011121314151617181920212223// 错误示例func main() &#123;truevar data interface&#123;&#125; = \"great\" // data 混用trueif data, ok := data.(int); ok &#123;truetruefmt.Println(\"[is an int], data: \", data)true&#125; else &#123;truetruefmt.Println(\"[not an int], data: \", data) // [isn't a int], data: 0true&#125;&#125;// 正确示例func main() &#123;truevar data interface&#123;&#125; = \"great\"trueif res, ok := data.(int); ok &#123;truetruefmt.Println(\"[is an int], data: \", res)true&#125; else &#123;truetruefmt.Println(\"[not an int], data: \", data) // [not an int], data: greattrue&#125;&#125; 50. 阻塞的 gorutinue 与资源泄露在 2012 年 Google I&#x2F;O 大会上，Rob Pike 的 Go Concurrency Patterns 演讲讨论 Go 的几种基本并发模式，如 完整代码 中从数据集中获取第一条数据的函数： 12345678func First(query string, replicas []Search) Result &#123;truec := make(chan Result)truereplicaSearch := func(i int) &#123; c &lt;- replicas[i](query) &#125;truefor i := range replicas &#123;truetruego replicaSearch(i)true&#125;truereturn &lt;-c&#125; 在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。 返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？ 在 First() 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。 为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法： 使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果： 12345678func First(query string, replicas ...Search) Result &#123; c := make(chan Result,len(replicas)) searchReplica := func(i int) &#123; c &lt;- replicas[i](query) &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; 使用 select 语句，配合能保存一个缓冲值的 channel default 语句： default 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine 12345678910111213func First(query string, replicas ...Search) Result &#123; c := make(chan Result,1) searchReplica := func(i int) &#123; select &#123; case c &lt;- replicas[i](query): default: &#125; &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; 使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行： 12345678910111213141516func First(query string, replicas ...Search) Result &#123; c := make(chan Result) done := make(chan struct&#123;&#125;) defer close(done) searchReplica := func(i int) &#123; select &#123; case c &lt;- replicas[i](query): case &lt;- done: &#125; &#125; for i := range replicas &#123; go searchReplica(i) &#125; return &lt;-c&#125; Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。 高级篇：51-5751. 使用指针作为方法的 receiver只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。 但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量： 123456789101112131415161718192021222324type data struct &#123;truename string&#125;type printer interface &#123;trueprint()&#125;func (p *data) print() &#123;truefmt.Println(\"name: \", p.name)&#125;func main() &#123;trued1 := data&#123;\"one\"&#125;trued1.print() // d1 变量可寻址，可直接调用指针 receiver 的方法truevar in printer = data&#123;\"two\"&#125;truein.print() // 类型不匹配truem := map[string]data&#123;truetrue\"x\": data&#123;\"three\"&#125;,true&#125;truem[\"x\"].print() // m[\"x\"] 是不可寻址的 // 变动频繁&#125; cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver) cannot call pointer method on m[“x”]cannot take the address of m[“x”] 52. 更新 map 字段的值如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段： 1234567891011// 无法直接更新 struct 的字段值type data struct &#123;truename string&#125;func main() &#123;truem := map[string]data&#123;truetrue\"x\": &#123;\"Tom\"&#125;,true&#125;truem[\"x\"].name = \"Jerry\"&#125; cannot assign to struct field m[“x”].name in map 因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址： 123456789type data struct &#123;truename string&#125;func main() &#123;trues := []data&#123;&#123;\"Tom\"&#125;&#125;trues[0].name = \"Jerry\"truefmt.Println(s) // [&#123;Jerry&#125;]&#125; 注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。 更新 map 中 struct 元素的字段值，有 2 个方法： 使用局部变量 1234567891011121314// 提取整个 struct 到局部变量中，修改字段值后再整个赋值type data struct &#123;truename string&#125;func main() &#123;truem := map[string]data&#123;truetrue\"x\": &#123;\"Tom\"&#125;,true&#125;truer := m[\"x\"]truer.name = \"Jerry\"truem[\"x\"] = rtruefmt.Println(m) // map[x:&#123;Jerry&#125;]&#125; 使用指向元素的 map 指针 12345678func main() &#123;truem := map[string]*data&#123;truetrue\"x\": &#123;\"Tom\"&#125;,true&#125;truetruem[\"x\"].name = \"Jerry\" // 直接修改 m[\"x\"] 中的字段truefmt.Println(m[\"x\"]) // &amp;&#123;Jerry&#125;&#125; 但是要注意下边这种误用： 1234567func main() &#123;truem := map[string]*data&#123;truetrue\"x\": &#123;\"Tom\"&#125;,true&#125;truem[\"z\"].name = \"what???\" truefmt.Println(m[\"x\"])&#125; panic: runtime error: invalid memory address or nil pointer dereference 53. nil interface 和 nil interface 值虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil 如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心： 12345678910func main() &#123;truevar data *bytetruevar in interface&#123;&#125;truefmt.Println(data, data == nil) // &lt;nil&gt; truetruefmt.Println(in, in == nil) // &lt;nil&gt; truetruein = datatruefmt.Println(in, in == nil) // &lt;nil&gt; false // data 值为 nil，但 in 值不为 nil&#125; 如果你的函数返回值类型是 interface，更要小心这个坑： 123456789101112131415161718192021222324252627282930313233343536// 错误示例func main() &#123;truedoIt := func(arg int) interface&#123;&#125; &#123;truetruevar result *struct&#123;&#125; = niltruetrueif arg &gt; 0 &#123;truetruetrueresult = &amp;struct&#123;&#125;&#123;&#125;truetrue&#125;truetruereturn resulttrue&#125;trueif res := doIt(-1); res != nil &#123;truetruefmt.Println(\"Good result: \", res) // Good result: &lt;nil&gt;truetruefmt.Printf(\"%T\\n\", res) // *struct &#123;&#125; // res 不是 nil，它的值为 niltruetruefmt.Printf(\"%v\\n\", res) // &lt;nil&gt;true&#125;&#125;// 正确示例func main() &#123;truedoIt := func(arg int) interface&#123;&#125; &#123;truetruevar result *struct&#123;&#125; = niltruetrueif arg &gt; 0 &#123;truetruetrueresult = &amp;struct&#123;&#125;&#123;&#125;truetrue&#125; else &#123;truetruetruereturn nil // 明确指明返回 niltruetrue&#125;truetruereturn resulttrue&#125;trueif res := doIt(-1); res != nil &#123;truetruefmt.Println(\"Good result: \", res)true&#125; else &#123;truetruefmt.Println(\"Bad result: \", res) // Bad result: &lt;nil&gt;true&#125;&#125; 54. 堆栈变量你并不总是清楚你的变量是分配到了堆还是栈。 在 C++ 中使用 new 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 new()、make() 来创建变量，变量为内存分配位置依旧归 Go 编译器管。 Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C&#x2F;C++ 中是不行的。 在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置： 55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）Go 1.4 及以下版本，程序只会使用 1 个执行上下文 &#x2F; OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。 Go 1.5 版本将可执行上下文的数量设置为 runtime.NumCPU() 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 GOMAXPROCS 环境变量或者动态的使用 runtime.GOMAXPROCS() 来调整。 误区：GOMAXPROCS 表示执行 goroutine 的 CPU 核心数，参考文档 GOMAXPROCS 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256 12345678func main() &#123;truefmt.Println(runtime.GOMAXPROCS(-1)) // 4truefmt.Println(runtime.NumCPU()) // 4trueruntime.GOMAXPROCS(20)truefmt.Println(runtime.GOMAXPROCS(-1)) // 20trueruntime.GOMAXPROCS(300)truefmt.Println(runtime.GOMAXPROCS(-1)) // Go 1.9.2 // 300&#125; 56. 读写操作的重新排序Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序： 12345678910111213141516171819202122232425var _ = runtime.GOMAXPROCS(3)var a, b intfunc u1() &#123;truea = 1trueb = 2&#125;func u2() &#123;truea = 3trueb = 4&#125;func p() &#123;trueprintln(a)trueprintln(b)&#125;func main() &#123;truego u1() // 多个 goroutine 的执行顺序不定truego u2() truego p()truetime.Sleep(1 * time.Second)&#125; 运行效果： 如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。 57. 优先调度你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 for 循环： 123456789101112func main() &#123;truedone := falsetruego func() &#123;truetruedone = truetrue&#125;()truefor !done &#123;true&#125;trueprintln(\"done !\")&#125; for 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。 调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行： 12345678910111213func main() &#123;truedone := falsetruego func() &#123;truetruedone = truetrue&#125;()truefor !done &#123;truetrueprintln(\"not done !\") // 并不内联执行true&#125;trueprintln(\"done !\")&#125; 可以添加 -m 参数来分析 for 代码块中调用的内联函数： 你也可以使用 runtime 包中的 Gosched() 来 手动启动调度器： 12345678910111213func main() &#123;truedone := falsetruego func() &#123;truetruedone = truetrue&#125;()truefor !done &#123;truetrueruntime.Gosched()true&#125;trueprintln(\"done !\")&#125; 运行效果： 总结感谢原作者 kcqon 总结的这篇博客，让我受益匪浅。 由于译者水平有限，不免出现理解失误，望读者在下评论区指出，不胜感激。 后续再更新类似高质量文章的翻译 😍 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"必知必会","slug":"必知必会","permalink":"https://liangyuanzheng.com/tags/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"}]},{"title":"MySQL表转为Golang结构体","slug":"MySQL表转为Golang结构体","date":"2019-09-05T12:40:10.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"MySQL表转为Golang结构体.html","link":"","permalink":"https://liangyuanzheng.com/MySQL%E8%A1%A8%E8%BD%AC%E4%B8%BAGolang%E7%BB%93%E6%9E%84%E4%BD%93.html","excerpt":"MySQL 表结构转为 go 结构体。","text":"MySQL 表结构转为 go 结构体。 1234567891011121314151617181920212223242526package mainimport (true\"fmt\"true\"github.com/gohouse/converter\")func main() &#123;truetable2Struct := converter.NewTable2Struct()truetable2Struct.Config(&amp;converter.T2tConfig&#123;truetrueSeperatFile: false,true&#125;)trueerr := table2Struct.truetrueEnableJsonTag(true).truetruePackageName(\"main\").truetrueTagKey(\"ddb\").truetrueSavePath(\"model.go\").truetrueDsn(\"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8\").truetrueRun()trueif err != nil &#123;truetruefmt.Println(err)true&#125; else &#123;truetruefmt.Println(\"success\")true&#125;&#125; hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://liangyuanzheng.com/tags/golang/"},{"name":"mysql","slug":"mysql","permalink":"https://liangyuanzheng.com/tags/mysql/"},{"name":"table2struct","slug":"table2struct","permalink":"https://liangyuanzheng.com/tags/table2struct/"}]},{"title":"mac 安装 zsh","slug":"mac-安装-zsh","date":"2019-01-26T11:12:43.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"mac-安装-zsh.html","link":"","permalink":"https://liangyuanzheng.com/mac-%E5%AE%89%E8%A3%85-zsh.html","excerpt":"","text":"1.下载.oh-my-zsh配置 1git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 2.创建新配置 NOTE:如果有~&#x2F;.zshrc，那就先备份下。 12cp ~/.zshrc ~/.zshrc.origcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 3.把zsh设置为默认的shell 1chsh -s /bin/zsh 4.重启zsh（打开一个新的terminal窗口） hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"zsh","slug":"zsh","permalink":"https://liangyuanzheng.com/tags/zsh/"}]},{"title":"HTTP 状态码","slug":"HTTP-状态码","date":"2018-04-23T07:53:29.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"HTTP-状态码.html","link":"","permalink":"https://liangyuanzheng.com/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81.html","excerpt":"HTTP 状态码HTTP是一种请求&#x2F;回应（Request&#x2F;Response）的网路传输协定，当用户端应用程式(浏览器)要求一网页资讯或资源（Document）时，网站伺服器端就会回传状态码（Status Code），这些状态码通常是以数据化显示，使用者最常见到应该是 404，其它包括 200、301、302、304、403、410、500等等。","text":"HTTP 状态码HTTP是一种请求&#x2F;回应（Request&#x2F;Response）的网路传输协定，当用户端应用程式(浏览器)要求一网页资讯或资源（Document）时，网站伺服器端就会回传状态码（Status Code），这些状态码通常是以数据化显示，使用者最常见到应该是 404，其它包括 200、301、302、304、403、410、500等等。 状态码 说明 解释 1XX 信息性（Informational） 服务器收到请求，需要请求者继续执行操作。 2XX 成功（Success） 成功，操作被成功接收并处理。 200 OK 表示从客户端发来的请求在服务器端被正常处理了。在响应报文中，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对于请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。 204 No Content 表示请求已成功处理，但是没有内容返回（就应该是没有内容返回的情况）。也就是返回响应报文没有报文实体。浏览提向服务器发送请求后收到 204，那么浏览器页面不会发生更新，一般用在只是客服端向服务器发送消息，二服务器不用向客户端发挥什么信息的情况。 205 Reset Content 重置内容。服务器处理成功，用户终端（如：浏览器）应重置文档试图。可通过此返回码清除浏览器的表单域。 206 Partial Content 表示服务器已经完成了部分 GET 请求（客户端进行了范围请求），响应报文中包含 Content-Range 指定范围的实体内容。 3XX 重定向（Redirection） 重定向，需要进一步的操作以完成请求。 301 Moved Permanently 永久重定向，表示请求的资源已经永久的搬到了其他位置，就是说资源已经被分配了新的 URI，新的 URI 应该提示在响应报文的 Location 收不字段，只要不是 HEAD 请求，响应实体应该包含新URI的超链接和简短说明。 302 Found 临时重定向，表示请求的资源临时搬到了其他位置，请的的资源被配到了新的 URI。和 301 很像，只不过资源是临时移动资源在将来可能还会改变；同样地，新的临时 URI 应该提示在响应报文的 Location 首部字段。 303 See Other 表示请求资源存在另一个 URI，应使用 GET 定向获取请求资源；303 功能与 302 一样，区别只是 303 明确客户端应该使用 GET 访问（很多 HTTP&#x2F;1.1 之前的浏览器不能理解 303，但是大家都把 302 当 303 对待使用 GTE 请求新 URI） 304 Not Modified 表示客户端发送附带条件的请求（GET 方法请求报文中的 IF …）时，条件不满足返回 304时，不包含任何响应主体。（虽然 304 被换分在 3XX，但和重定向一毛钱关系都没有。） 305 User Proxy 请求者只能使用代理访问请求的网页。 307 Temporary Redirect 临时重定向，和 302 有着相同的含义；尽管 302 标准进制 POST 变为 GET，单没人听他的，而 307 就会遵照标准，不会从 POST 变为 GET，但响应处理行为，各浏览器可能不同。 4XX 客户端错误（Client Error） 客户端错误，请求包含语法错误或无法完成请求。 400 Bad Request 表示请求报文存在语法错误或参数错误，服务器不理解；客户端不应该重复提交这个请求，需要修改请求内容后再次提交。 401 Unauthorized 需要通过 HTTP 认证或认证失败。 402 Payment Required 保留，将来使用。 403 Forbidden 请求资源被拒绝。 404 Not Found 请求的文件或目录不存在或删除。 405 Method Not Allowed 禁用请求中指定的方法。 406 Not Acceptable 无法使用请求的内容特性响应请求的网页。 407 Proxy Authentication Required 此代码与 401（Unauthorized）类似，但指定请求者应当授权使用代理。 408 Request Time-out 服务器等候请求时发生超时。 409 Conflict 服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突信息。 410 Gone 请求的资源已被永久删除。 411 Length Required 服务器不接受不含有效内容长度标头字段的请求。 412 Precondition Failed 服务器未满足请求者在请求中设置的其中一个前提条件。 413 Request Entity Too Large 服务器无法处理请求，应为请求实体过大，超出服务器处理能力。 414 Request URI Too Large 请求的 URI（通常为网址）过长，服务器无法处理。 415 Unsupported Media Type 请求的格式不受请求页面的支持。 416 Requested Range Not Satisfiable 如果页面无法提供请求的范围，则服务器会返回此代码。 417 Exception Failed 服务器未满足＂期望＂请求标头字段的要求。 451 Unavailable For Legal Reasons 出于法律原因不与展示。 499 client has closed connection（Nginx status） nginx认为是不安全的连接，主动拒绝了客户端的连接 5XX 服务器错误（Server Error） 服务器错误，服务器在处理请求的过程中发生了错误。 500 Internal Server Error 服务器执行请求出错，无法完成请求。可能是 Web 应用有 bug 或临时故障，更有可能是服务器源代码有 bug… 501 Not Implemented 服务器不具备完成请求的功能。如服务器无法识别请求方法时可能返回此代码。 502 Bad Gateway 服务器暂时不可用。服务器作为网关或代理，从上游服务器收到无效响应。 503 Service Unavailable 服务器超时，表示服务器超负载或正停机维护，无法处理请求；如果服务器知道还需要多长时间，就写入 Retry-After 首部字段返回。 504 Gateway Time-out 网关过载。 505 HTTP Version Not Supported 服务器不支持请求的 HTTP 协议版本，无法完成处理。 510 Not Extended 获取资源所需要的策略没有被满足 511 Network Authentication Required 客户需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。 参考文档 HTTP状态码 http://www.cnblogs.com/jinjiangongzuoshi/p/3778883.html http://bbs.tianya.cn/post-no110-13639238-1.shtml http://www.runoob.com/http/http-status-codes.html HTTP状态码大全 HTTP 499 状态码 nginx下 499错误 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：https://leunggeorge.github.io/","categories":[{"name":"网络","slug":"网络","permalink":"https://liangyuanzheng.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://liangyuanzheng.com/tags/http/"},{"name":"状态码","slug":"状态码","permalink":"https://liangyuanzheng.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"}]},{"title":"威尔逊得分","slug":"威尔逊得分","date":"2018-02-09T03:51:56.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"威尔逊得分.html","link":"","permalink":"https://liangyuanzheng.com/%E5%A8%81%E5%B0%94%E9%80%8A%E5%BE%97%E5%88%86.html","excerpt":"如何评价知乎的回答排序算法？知乎今天上线了新的回答排序算法。 你也许不会注意到太大的变化，毕竟旧版排序在大部分情形下效果也不错。因此，这次改进的目标，是更好地做到两点： 专业、严谨、认真的高质量回答，排序应该更靠前 新创作的优质回答，能更快地获得更好的排序","text":"如何评价知乎的回答排序算法？知乎今天上线了新的回答排序算法。 你也许不会注意到太大的变化，毕竟旧版排序在大部分情形下效果也不错。因此，这次改进的目标，是更好地做到两点： 专业、严谨、认真的高质量回答，排序应该更靠前 新创作的优质回答，能更快地获得更好的排序 为了帮助大家更好的理解新的机制，我们先来看看改进前的排序存在哪些问题。旧版的算法简化后可以表示为： 1得分 = 加权赞同数 - 加权反对数 注：用户在不同话题下的权重计算方法，可以参考我之前的回答「知乎如何计算用户在某个领域下的权重？」。 公式本身很朴素。事实上之所以到今天这个简单的公式仍然能保证大部分优质内容能够排到前面，主要是用户投票权重在发挥作用。虽然针对权重计算的优化仍然在持续进行，我们也很快遇到了一些算法上的瓶颈。 当问题下有多个发布较早的回答获得高票时，新的回答即使质量很高，也很难在问题页上获得足够的曝光，难以积累更多赞同票 一些误导性、煽动性的高票内容，即使同时也有很多反对票，仍然排在认真、严谨但票数相对较少的优质回答前面 一旦回答的反对数超过赞同数，得分为负，就会显示在所有低票回答下面（可能有几百个）。即使内容经过作者修改，也几乎没有机会重见天日。 上述问题在专业领域内对参与讨论的用户造成的伤害尤其明显。这绝不是我们希望看到的。 新的排序机制在很大程度上解决了这些问题。如果想了解算法原理和相关细节，可以移步「如何评价知乎的回答排序算法？」，下文的说明中并不会涉及专业知识。 新排序算法（可以简称为「威尔逊得分」算法）的思想是，如果把一个回答展示给很多人看并让他们投票，内容质量不同的回答会得到不同比例的赞同和反对票数，最终得到一个反映内容质量的得分。当投票的人比较少时，可以根据已经获得的票数估计这个回答的质量得分，投票的人越多则估计结果越接近真实得分。 如果新一个回答获得了 1 票赞同 0 票反对，也就是说参与投票的用户 100% 都选了赞同，但是因为数量太少，所以得分也不会太高。如果一小段时间后这个回答获得了 20 次赞同 1 次反对，那么基于新算法，我们就有较强的信心把它排在另一个有 50 次赞同 20 次反对的回答前面。原因是我们预测当这个回答同样获得 50 次赞同时，它获得的反对数应该会小于 20。威尔逊得分算法最好的特性就是，即使前一步我们错了，现在这个新回答排到了前面，获得了更多展示，在它得到更多投票后，算法便会自我修正，基于更多的投票数据更准确地计算得分，从而让排序最终能够真实地反映内容的质量。 因此未来我们会看到更多新创作的优质内容，快速获得靠前的排序，低质内容则会长期保持在底部。（细心的你可能也想到了，并不是所有的回答最终都会获得很多投票，大体上获得投票总数较多的回答仍然会排在投票较少的回答前面。） 这次算法改进，仍然遵循此前公布的「知乎回答排序原则」。由于权重的计算方法没有公布，反对票也没有显示在页面上，因此出现低票回答在前高票回答在后是很正常的现象。 投票权重的计算方法，很多用户非常关心。我们正好再次明确一下最重要的几点原则： 在知乎上创作了专业、严谨、认真的高质量回答的人，应该在他&#x2F;她擅长的领域里，有更大的判断力。权重则是这个判断力的体现。 用户在一系列相关话题下发布的全部回答所得到赞同、反对、没有帮助票数决定用户在该领域下的权重 问题添加的话题和话题父子关系决定问题归属的领域 对内容质量的判断，归根结底，是通过知乎社区中用户的集体智慧的选择而完成的，更具体则体现为每一次「赞同」「反对」「没有帮助」按钮的点击。新版排序机制所鼓励的，仍然是知乎从成立第一天就追求的：创作过专业、严谨、认真的高质量内容，并且得到社区认可的用户，在塑造社区未来的内容质量标准和其他社区共识的过程中，他们能发挥的作用也更大。 回想一下，是否有那么一些时候，你面对某个排序并不理想的问题页皱紧眉头，感觉自己的一票对排序结果的影响微乎其微而深感无力。新版排序算法结合话题权重，相比过去能够做到对每一次投票做出更迅速的反应。不试试看又怎么知道呢？ 知乎如何对回答进行排序？你的每一次投票都很重要。 查看原文 如何评价知乎的回答排序算法？-精彩回答这个算法中用来做排序依据的得分的更严谨的名称是「二项分布样本的威尔逊置信区间下界」。计算公式是在 1927 年由数学家 Edwin B. Wilson 发展得到的 [1]，用来对二项分布进行参数估计。2009 年芝加哥的软件工程师 Evan Miller 提出 [2]，可以用威尔逊置信区间的下界对具有正负双向投票的系统进行排序。在我最初通过煎蛋的介绍 [3] 了解到这个算法时，便立即被它的很多优良特性所吸引： 投票总数增加时，得分趋向于正向反馈占总反馈的比例，对于内容质量有较强的解释性。 在总票数较少（个位数投票）和极端参数（真实比例接近 0 或 100%）的情形下，结果也能具有较高的准确性。 置信区间大小可以通过参数控制。 虽然二项分布是离散模型，但是由于得分表达式关于正负反馈次数的函数是连续的，因此可以引入非整数的投票（加权投票），同时不改变算法性质。 得分的取值范围是 (0,1)，与投票总数无关。因此可以间接地用来对不同问题下的回答做归一化的质量比较。 下面这两张图可以比较直观地显示威尔逊得分算法的几个重要特性。 为方便讨论，依次称左图中 up-vote, down-vote, score 对应的轴为 x,y,z 轴。右图为左图的等高线图。 左图的整体曲面形状，与通常理解中赞同票、反对票和回答质量的对应关系是相符的。固定反对票，赞同票越多得分越高；固定赞同票，反对越多得分越低；固定赞同与反对的比例，总票数越高得分越高。 总投票数较少时，回答如果获得投票，得分会快速增加，总票数越大增加速度越慢。体现为垂直 y 轴的平面截得的曲线斜率对 x 恒正且单调下降。同时，赞同数较高的回答，开始获得反对票时，得分会快速下降，总反对数越大下降速度越慢。垂直 x 轴的平面截得的曲线斜率对 y 恒负且单调上升。 对老版算法，对应函数 z &#x3D; x - y，也不难画出上面两个图（这么简单的表达式，相信很多人闭上眼睛就已经把图画出来了）。老版算法的得分曲面实际为平面，因此各种截线都是平行直线（斜率为固定常数），右图等高线也是平行直线。 相对而言，新版算法对应的等高线图，等高线比老版更密集 [4]，因此跨越等高线更容易。这也是新排序机制的上线说明中，我们说新算法能够做到对单次投票更加敏感的根本原因。 另一方面，函数曲面连续光滑，使得这个算法可以很好的处理浮点数投票，支持知乎已有的用户话题权重机制。二者有机结合，让回答排序更符合真实的内容质量。 当然，使用威尔逊得分来决定排序也远非完善。不同的回答获得投票的能力不同，这一点受很多因素影响，包括作者的文风、内容是否属于专业领域等。这些差异目前还没有在算法中得到体现。 另一个问题是，算法在 x &#x3D; 0 时函数取值收敛为 0，无法对赞同为 0 但有不同反对票数的回答进行排序。我们的处理方式是默认所有回答者对自己的回答投了一票赞同。这样不仅解决了这个问题，还能让回答者的权重参与到排序的计算中。 威尔逊得分是一个简单强大，但是价值还没有被充分发掘的算法。至今，世界范围内应用了这个算法的著名网站仍然寥寥无几 [5]。近几年开始见到一些应用较广的开源库支持威尔逊得分，关于它的讨论似乎也在逐渐增加 [6]，还是很让人开心的。我也希望借此次知乎排序算法升级，把这个算法介绍给更多国内的团队，希望能对大家有所助益。 下面是利用威尔逊得分是一个扩展： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpdefine('STRATEGY_BASIC', 1);define('STRATEGY_WILSON_SCORE', 2);define('STRATEGY_SCORE_WEIGHT', 1000000);define('DEFAULT_ZA', 21);/** * $&#123;STATIC&#125; calc_reply_or_comment_score * @desc: * @param $intU * @param $intV * @param $intID * @param $intTime * @param int $intSwc * @param int $intZa * @return int */function calc_reply_or_comment_score($intU, $intV, $intID, $intTime, $intSwc = STRATEGY_BASIC, $intZa = DEFAULT_ZA) &#123; if (empty($intTime)) &#123; $intTime = time(); &#125; $intScore = 0; switch($intSwc) &#123; case STRATEGY_BASIC: &#123; /// 公式一 /// 赞同率 $intN = $intU + $intV; $fScore = ($intN &gt; 0) ? ($intU / doubleval($intN)) : 0; $intScore = intval(STRATEGY_SCORE_WEIGHT * $fScore); break; &#125; case STRATEGY_WILSON_SCORE: &#123; /// 公式一 /// 威尔逊得分 $intN = $intU + $intV; if ($intN &gt; 0) &#123; $fP = $intU / doubleval($intN); $intZa2 = $intZa * $intZa; $fScore = ($fP + $intZa2 / (2 * $intN) - $intZa / (2 * $intN) * sqrt(4 * $intN * (1 - $fP) * $fP + $intZa2)) / (1 + $intZa2 / $intN); $intScore = intval(STRATEGY_SCORE_WEIGHT * $fScore); &#125; break; &#125; &#125; $bitTime = $intTime &amp; 0x1FFFFFF; $bitThumb = $intScore &amp; 0xEFFFFF; $bitReplyId = $intID &amp; 0xFF; $score = $bitReplyId | ($bitTime &lt;&lt; 8) | ($bitThumb &lt;&lt; 33); return $score;&#125;// demo$intID = 0;for ($intU = 0; $intU &lt; 10; $intU++) &#123; for ($intV = 0; $intV &lt; 10; $intV++) &#123; $intID++; $score = calc_reply_or_comment_score($intU, $intV, $intID, time(), STRATEGY_WILSON_SCORE); echo \"U=&#123;$intU&#125;,V=&#123;$intV&#125;,score=&#123;$score&#125;\\n\"; &#125;&#125; Binomial proportion confidence intervalHow Not To Sort By Average RatingReddit的评论排序新算法威尔逊得分 Wilson Score 排序算法-简书如何评价知乎的回答排序算法？ hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"威尔逊得分","slug":"威尔逊得分","permalink":"https://liangyuanzheng.com/tags/%E5%A8%81%E5%B0%94%E9%80%8A%E5%BE%97%E5%88%86/"}]},{"title":"基于redis实现scrapy分布式爬虫","slug":"基于redis实现scrapy分布式爬虫","date":"2017-12-23T09:08:56.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"基于redis实现scrapy分布式爬虫.html","link":"","permalink":"https://liangyuanzheng.com/%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0scrapy%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB.html","excerpt":"安装redis下载1wget http://download.redis.io/releases/redis-stable.tar.gz 安装12tar -zxvf redis-stable.tar.gzcd redis-stable","text":"安装redis下载1wget http://download.redis.io/releases/redis-stable.tar.gz 安装12tar -zxvf redis-stable.tar.gzcd redis-stable 运行12./src/redis-server./src/redis-cli 安装scrapy-redis1pip install scrapy-redis 新建分布式爬虫 新建项目1scrapy startproject distributedspider 新建redis crawler(mycrawler_redis.py)1234567891011121314151617181920212223import redisfrom scrapy.spiders import Rulefrom scrapy.linkextractors import LinkExtractorfrom scrapy_redis.spiders import RedisCrawlSpiderclass MyCrawler(RedisCrawlSpider): \"\"\"Spider that reads urls from redis queue (myspider:start_urls).\"\"\" name = 'mycrawler_redis' redis_key = 'mycrawler:start_urls' start_urls = [] def __init__(self, *args, **kwargs): super(MyCrawler, self).__init__(*args, **kwargs) # Dynamically define the allowed domains list. domain = kwargs.pop('domain', '') self.allowed_domains = filter(None, domain.split(',')) self.start_urls.append('http://joke.4399pk.com/funnyimg/find-cate-2.html') r = redis.Redis() for pageNum in range(1, 20, 1): pageUrl = 'http://joke.4399pk.com/funnyimg/find-cate-2-p-' + str(pageNum) + '.html' start_urls_len = r.lpush(\"myspider:start_urls\", pageUrl) print 'start_urls_len:' + str(start_urls_len) 新建redis spider(myspider_redis.py)12345678910111213141516171819202122from scrapy_redis.spiders import RedisSpiderclass MySpider(RedisSpider): \"\"\"Spider that reads urls from redis queue (myspider:start_urls).\"\"\" name = 'myspider_redis' redis_key = 'myspider:start_urls' def __init__(self, *args, **kwargs): # Dynamically define the allowed domains list. domain = kwargs.pop('domain', '') self.allowed_domains = filter(None, domain.split(',')) super(MySpider, self).__init__(*args, **kwargs) def parse(self, response): print 'spider_____________' print response.url return &#123; 'name': response.css('title::text').extract_first(), 'url': response.url, &#125; 修改配置（settings.pyc）配置redis地址，多机部署时队列读取地址。 1234567891011DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"SCHEDULER = \"scrapy_redis.scheduler.Scheduler\"ITEM_PIPELINES = &#123; 'distributedspider.pipelines.DistributedspiderPipeline': 300, 'scrapy_redis.pipelines.RedisPipeline': 400,&#125;REDIS_HOST = '127.0.0.1'REDIS_PORT = 6379 运行启动redis 运行spider1 运行spider2 添加start_urls方式一（手动添加）： 方式二（执行脚本添加）： 1scrapy crawl mycrawler_redis 结论可以看到spider1、spider2在并行处理请求 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://liangyuanzheng.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"scrapy","slug":"scrapy","permalink":"https://liangyuanzheng.com/tags/scrapy/"},{"name":"分布式","slug":"分布式","permalink":"https://liangyuanzheng.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"scrapyd监控scrapy爬虫进度","slug":"scrapyd监控scrapy爬虫进度","date":"2017-12-22T15:30:33.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"scrapyd监控scrapy爬虫进度.html","link":"","permalink":"https://liangyuanzheng.com/scrapyd%E7%9B%91%E6%8E%A7scrapy%E7%88%AC%E8%99%AB%E8%BF%9B%E5%BA%A6.html","excerpt":"准备工作安装scrapyd1pip install scrapyd 安装scrapyd-client1pip install scrapyd-client 运行scrapyd服务1scrapyd Spider进度查看地址：http://localhost:6800/","text":"准备工作安装scrapyd1pip install scrapyd 安装scrapyd-client1pip install scrapyd-client 运行scrapyd服务1scrapyd Spider进度查看地址：http://localhost:6800/ 部署scrapy项目部署scrapy项目（修改Spider之后需要重新部署哦）修改scrapy.cfg文件 12345678[deploy] section see:[settings]default = demo.settings[deploy:demo_deploy]url = http://localhost:6800/project = demo 直接在项目demo的根目录路运行部署命令： 12345➜ demo git:(master) ✗ scrapyd-deploy demo_deploy -p demoPacking version 1513956720Deploying to project \"demo\" in http://localhost:6800/addversion.jsonServer response (200):&#123;\"status\": \"ok\", \"project\": \"demo\", \"version\": \"1513956720\", \"spiders\": 2, \"node_name\": \"MacBook-Pro-4.local\"&#125; 添加Spider到任务队列查看已有爬虫： 123➜ demo git:(master) scrapy listdemo4399pkyh31 添加Spider到任务队列： 1curl http://localhost:6800/schedule.json -d project=demo -d spider=yh31 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://liangyuanzheng.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://liangyuanzheng.com/tags/scrapy/"},{"name":"scrapyd","slug":"scrapyd","permalink":"https://liangyuanzheng.com/tags/scrapyd/"}]},{"title":"fis 修改上传文件大小限制","slug":"fis-修改上传文件大小限制","date":"2017-12-15T02:41:50.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"fis-修改上传文件大小限制.html","link":"","permalink":"https://liangyuanzheng.com/fis-%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6.html","excerpt":"","text":"1.修改php.ini 1post_max_size = 100m ;指通过表单POST给PHP的所能接收的最大值，包括表单里的所有值。默认为8M 2.修改nginx.conf 1client_max_body_size 100m; 引用http://www.phpchina.com/blog-52440-181965.htmlhttp://blog.csdn.net/bruce128/article/details/9665503 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"fis","slug":"fis","permalink":"https://liangyuanzheng.com/tags/fis/"}]},{"title":"starUML破解方法（Windows10 & MAC）","slug":"starUML破解方法（Windows10-MAC）","date":"2017-11-30T02:00:55.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"starUML破解方法（Windows10-MAC）.html","link":"","permalink":"https://liangyuanzheng.com/starUML%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95%EF%BC%88Windows10-MAC%EF%BC%89.html","excerpt":"破解之路Mac版（摘自互联网） 原文请查看引用【StarUML 版本破解(MAC版)】 1，打开对应 mac版本的安装包位置，在对应目录js文件 1/Applications/StarUML.app/Contents/www/license/node/LicenseManagerDomain.js","text":"破解之路Mac版（摘自互联网） 原文请查看引用【StarUML 版本破解(MAC版)】 1，打开对应 mac版本的安装包位置，在对应目录js文件 1/Applications/StarUML.app/Contents/www/license/node/LicenseManagerDomain.js 2，找到文件23行，修改对应下面函数。更改为如下代码： 123456789101112131415161718192021222324252627282930function validate(PK, name, product, licenseKey) &#123; var pk, decrypted; // edit by 0xcb return &#123; name: \"0xcb\", product: \"StarUML\", licenseType: \"vip\", quantity: \"mergades.com\", licenseKey: \"later equals never!\" &#125;; try &#123; pk = new NodeRSA(PK); decrypted = pk.decrypt(licenseKey, 'utf8'); &#125; catch (err) &#123; return false; &#125; var terms = decrypted.trim().split(\"\\n\"); if (terms[0] === name &amp;&amp; terms[1] === product) &#123; return &#123; name: name, product: product, licenseType: terms[2], quantity: terms[3], licenseKey: licenseKey &#125;; &#125; else &#123; return false; &#125; &#125; 我的做法是注释掉原有代码，再增加，防止出现问题。 3，打开starUML。 help&gt;enter license 12Name:0xcblicenseKey:later equals never! 然后提示你注册成功！ 引用UML——状态图starUML破解方法（Windows10 &amp; MAC）StarUML 版本破解(MAC版)App can’t be opened because it is from an unidentified developer hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"staruml","slug":"staruml","permalink":"https://liangyuanzheng.com/tags/staruml/"}]},{"title":"安装pip","slug":"安装pip","date":"2017-11-25T05:53:42.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"安装pip.html","link":"","permalink":"https://liangyuanzheng.com/%E5%AE%89%E8%A3%85pip.html","excerpt":"安装pip下载get-pip.py1curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py","text":"安装pip下载get-pip.py1curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 运行1python get-pip.py 升级pip1pip install -U pip 引用https://pip.pypa.io/en/latest/installing/#id7 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://liangyuanzheng.com/tags/pip/"}]},{"title":"使用scrapy抓取代理ip实例","slug":"使用scrapy抓取代理ip实例","date":"2017-11-12T15:18:36.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"使用scrapy抓取代理ip实例.html","link":"","permalink":"https://liangyuanzheng.com/%E4%BD%BF%E7%94%A8scrapy%E6%8A%93%E5%8F%96%E4%BB%A3%E7%90%86ip%E5%AE%9E%E4%BE%8B.html","excerpt":"","text":"使用scrapy抓取代理ip实例准备如果你尚未安装scrapy，或者不知道怎么创建爬虫项目，请参考 python scrapy框架 安装一节。 我们创建项目collectips；新建爬虫xicidaili。 主要代码解析初始化123name = 'xicidaili'allowed_domains = ['www.xicidaili.com']start_urls = ['http://www.xicidaili.com/nn/1'] 解析1234567891011121314151617181920212223242526272829303132333435363738394041def parse(self, response): ip_list = response.xpath('//*[@id=\"ip_list\"]') trs = ip_list[0].xpath('tr') for tr in trs[1:]: item = CollectipsItem() item['ip'] = tr.xpath('td[2]/text()').extract() item['port'] = tr.xpath('td[3]/text()').extract() item['server_address'] = tr.xpath('td[4]/a/text()').extract() item['is_gao_ni'] = tr.xpath('td[5]/text()').extract() item['ip_type'] = tr.xpath('td[6]/text()').extract() item['speed'] = tr.xpath('td[7]/div/@title').extract()[0] item['connection_time'] = tr.xpath('td[8]/div/@title').extract()[0] item['alive_time'] = tr.xpath('td[9]/text()').extract() item['check_time'] = tr.xpath('td[10]/text()').extract() myProxy = str(tr.xpath('td[2]/text()').extract()[0]) + str(':') + str(tr.xpath('td[3]/text()').extract()[0]) if self.is_valid_ip(myProxy) == 1: print 'save a valid ip' objFile = open('ip_port_list.txt', 'a') rowData = myProxy objFile.write(rowData) objFile.write('\\n') objFile.close() yield item pagination = response.xpath('//*[@id=\"body\"]/div[2]') alist = pagination[0].xpath('a') pageNum = response.url.split('/')[-1] if pageNum &gt;= 5: print 'crawl end...' exit(0) for a in alist: class_name = a.xpath('text()').extract() class_name2 = class_name[0].strip() if u'下一页 ›' == class_name2: print 'next page...............' nextPageHref = a.xpath('@href').extract()[0] nextPageHrefFullUrl = response.urljoin(nextPageHref) yield scrapy.Request(nextPageHrefFullUrl, callback=self.parse) 检验代理ip可用性我们需要对抓取的代理ip的可用性进行验证，方式如下： 12345678910111213def is_valid_ip(self, proxy): print 'check ip...' try: protocol = 'http://' proxies = &#123;protocol: proxy&#125; if requests.get('http://www.baidu.com', proxies=proxies, timeout=2).status_code == 200: return 1 except: print 'ip is not valid...' pass return 0 修改配置 修改下载延迟 1234# Configure a delay for requests for the same website (default: 0)# See http://scrapy.readthedocs.org/en/latest/topics/settings.html#download-delay# See also autothrottle settings and docsDOWNLOAD_DELAY = 1 新增下载中间件 123456# Enable or disable downloader middlewares# See http://scrapy.readthedocs.org/en/latest/topics/downloader-middleware.htmlDOWNLOADER_MIDDLEWARES = &#123;# 'collectips.middlewares.MyCustomDownloaderMiddleware': 543, 'collectips.middlewares.CollectipsSpiderMiddleware': 100,&#125; 代理IP 1234567891011121314151617IP_POOL = [ &#123;\"ipaddr\":\"59.40.69.231:8010\"&#125;, &#123;\"ipaddr\":\"27.219.36.127:8118\"&#125;, &#123;\"ipaddr\":\"118.187.58.34:53281\"&#125;, &#123;\"ipaddr\":\"117.78.37.198:8000\"&#125;, &#123;\"ipaddr\":\"42.55.171.123:80\"&#125;, &#123;\"ipaddr\":\"119.115.21.17:80\"&#125;, &#123;\"ipaddr\":\"17-11-05 11:44:4395\"&#125;, &#123;\"ipaddr\":\"59.40.50.169:8010\"&#125;, &#123;\"ipaddr\":\"61.129.70.131:8080\"&#125;, &#123;\"ipaddr\":\"61.152.81.193:9100\"&#125;, &#123;\"ipaddr\":\"120.204.85.29:3128\"&#125;, &#123;\"ipaddr\":\"219.228.126.86:8123\"&#125;, &#123;\"ipaddr\":\"61.152.81.193:9100\"&#125;, &#123;\"ipaddr\":\"218.82.33.225:53853\"&#125;, &#123;\"ipaddr\":\"223.167.190.17:42789\"&#125;,] USER_AGENT设置 1234567891011121314151617181920USER_AGENT_LIST = [ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\",] gogogo西刺代理运行： 1scrapy crawl xicidaili -o my_ip.json 抓取数据示例12345678910111213141516171819202122232425&#123; \"connection_time\":\"0.034秒\", \"check_time\":[ \"17-11-12 16:37\" ], \"is_gao_ni\":[ \"高匿\" ], \"ip\":[ \"119.130.240.25\" ], \"server_address\":[ \"广东广州\" ], \"alive_time\":[ \"2小时\" ], \"ip_type\":[ \"HTTPS\" ], \"speed\":\"0.174秒\", \"port\":[ \"8118\" ]&#125; 引用 源码：collectips hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://liangyuanzheng.com/tags/scrapy/"}]},{"title":"HTTP使用POST提交数据常见方式","slug":"HTTP使用POST提交数据常见方式","date":"2017-08-23T11:31:15.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"HTTP使用POST提交数据常见方式.html","link":"","permalink":"https://liangyuanzheng.com/HTTP%E4%BD%BF%E7%94%A8POST%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F.html","excerpt":"HTTP&#x2F;1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。","text":"HTTP&#x2F;1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。 我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP&#x2F;IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 application&#x2F;x-www-form-urlencoded这应该是最常见的 POST 提交数据的方式了。浏览器的原生 &lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）： 1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application&#x2F;x-www-form-urlencoded；其次，提交的数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST[‘title’] 可以获取到 title 的值，$_POST[‘sub’] 可以得到 sub 数组。 很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8」。 multipart&#x2F;form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart&#x2F;form-data。直接来看一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"text\"title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart&#x2F;form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 multipart&#x2F;form-data 的详细定义，请前往 rfc1867 查看。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt; 表单也只支持这两种方式（通过 &lt;form&gt; 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 application&#x2F;jsonapplication&#x2F;json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。 Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码： 1234var data = &#123;'title':'test', 'sub' : [1,2,3]&#125;;$http.post(url, data).success(function(result) &#123;true...&#125;); 最终发送的请求是： 1234POST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8&#123;\"title\":\"test\",\"sub\":[1,2,3]&#125; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application&#x2F;json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。 当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考这篇文章。 text&#x2F;xml我的博客之前提到过 XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： 123456789101112POST http://www.example.com HTTP/1.1 Content-Type: text/xml&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt;true&lt;methodName&gt;examples.getStateName&lt;/methodName&gt;true&lt;params&gt;truetrue&lt;param&gt;truetruetrue&lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;truetrue&lt;/param&gt;true&lt;/params&gt;&lt;/methodCall&gt; XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。 原文链接：https://imququ.com/post/four-ways-to-post-data-in-http.html，前往原文评论 » 四种常见的 POST 提交数据方式Multipart&#x2F;form-data hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"网络","slug":"网络","permalink":"https://liangyuanzheng.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://liangyuanzheng.com/tags/http/"},{"name":"post","slug":"post","permalink":"https://liangyuanzheng.com/tags/post/"}]},{"title":"线上数据库使用规范","slug":"线上数据库使用规范","date":"2017-08-15T13:32:00.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"线上数据库使用规范.html","link":"","permalink":"https://liangyuanzheng.com/%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83.html","excerpt":"","text":"命名规范库名、表名、字段名、索引库名、表名、字段名使用驼峰命名。（线上库为大小写敏感） MySQL有配置参数lower_case_table_names&#x3D;1，即库表名以小写存储，大小写不敏感。如果是0，则库表名以实际情况存储，大小写敏感；如果是2，以实际情况存储，但以小写比较。 查看MySQL是否大小写敏感： 12345678mysql&gt; show variables like '%case%';+------------------------+-------+| Variable_name | Value |+------------------------+-------+| lower_case_file_system | OFF || lower_case_table_names | 0 |+------------------------+-------+2 rows in set (0.01 sec) 库名以【db】开头(暂未遵循)1create database db_xxx default character set=utf8; 表名以【tbl】开头,如：tblUserMsg职责相近的表，命名规则应该相同，功能相关的表尽量采用相同的前缀。例如: 123tblAtlasAtlas tblAtlasComment tblAtlasPic 字段名以【驼峰】风格命名索引命名 数据表必须有主键，且建议均使用auto_increment的id作为主键（与业务无关）,和业务相关的要做为唯一索引，原则上必须定义PRIMARY KEY (id)。 普通索引以【idx_】开头后面紧跟相关列（idx_col1_col2）如：KEY idx_msgType_status (msgType,status) 唯一索引以【uk_】开头（uk_col1_col2 ）如：UNIQUE KEY uk_adminUid_userUid (adminUid,userUid) 命名长度限制库名、表名、字段名禁止超过32个字符，需见名知意。 临时库、表名须以tmp加日期为后缀（原则上不允许线上创建临时表）比如tblCrmEcRecord201403。不具有时间特性的，直接以 tblName01 这样的方式命名。 库、表约束规范存储引擎使用Innodb存储引擎 字符集默认使用utf8字符集（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上） 建表规范所有表都必须要显式指定主键，每个字段都要有注释，，写明白这个表中存放的数据内容。例如： 12345678910111213141516tblUserMsg |CREATE TABLE `tblUserMsg` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增私信id', `msgType` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '0:test,1:单个、多个用户，2：全部用户', `status` tinyint(2) unsigned NOT NULL DEFAULT '0' COMMENT '0 : not start , 1: dealing,3:finished', `senderUid` bigint(20) unsigned NOT NULL COMMENT '私信发送者uid', `startUid` bigint(20) unsigned NOT NULL COMMENT '发送起始用户id', `curUid` bigint(20) unsigned NOT NULL COMMENT '当前发送用户id', `endUid` bigint(20) unsigned NOT NULL COMMENT '最后发送用户id', `percent` decimal(5,4) unsigned NOT NULL DEFAULT '0.0000' COMMENT 'produce percent', `createTime` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'create time', `updateTime` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'update time', `deleted` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '0 : not , 1: deleted', `ext` varchar(5000) NOT NULL DEFAULT '[]' COMMENT 'extension json', PRIMARY KEY (`id`), KEY `idx_msgType_status` (`msgType`,`status`)) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8 COMMENT='用户私信列表' 关于分表预估表数据量，如果数据量较大（超过1000w）则需要考虑分表策略。要分表的数据表必须与DBA商量分表策略。 字段定义规范char、varchar、text等字符串类型 对于长度基本固定的列，如果该列恰好更新又特别频繁，适合char varchar虽然存储变长字符串，但不可太小也不可太大。UTF8最多能存21844个汉字，或65532个英文 varbinary(M)保存的是二进制字符串，它保存的是字节而不是字符，所以没有字符集的概念，M长度0-255（字节）。只用于排序或比较时大小写敏感的类型，不包括密码存储 TEXT类型与VARCHAR都类似，存储可变长度，最大限制也是2^16，但是它20bytes以后的内容是在数据页以外的空间存储（row_format&#x3D;dynamic），对它的使用需要多一次寻址，没有默认值。一般用于存放容量平均都很大、操作没有其它字段那样频繁的值。网上部分文章说要避免使用text和blob，要知道如果纯用varchar可能会导致行溢出，效果差不多，但因为每行占用字节数过多，会导致buffer_pool能缓存的数据行、页下降。另外text和blob上面一般不会去建索引，而是利用sphinx之类的第三方全文搜索引擎，如果确实要创建（前缀）索引，那就会影响性能。凡事看具体场景。另外尽可能把text&#x2F;blob拆到另一个表中 BLOB可以看出varbinary的扩展版本，内容以二进制字符串存储，无字符集，区分大小写，有一种经常提但不用的场景：不要在数据库里存储图片。 int、tinyint、decimal等数字类型 使用tinyint来代替 enum和boolean，ENUM类型在需要修改或增加枚举值时，需要在线DDL，成本较高；ENUM列值如果含有数字类型，可能会引起默认值混淆，tinyint使用1个字节，一般用于status,type,flag的列 建议使用 UNSIGNED 存储非负数值，相比不使用 unsigned，可以扩大一倍使用数值范围 int使用固定4个字节存储，int(11)与int(4)只是显示宽度的区别 使用Decimal 代替float&#x2F;double存储精确浮点数，对于货币、金额这样的类型，使用decimal，如 decimal(9,2)。float默认只能能精确到6位有效数字 timestamp与datetime选择建议字段都定义为NOT NULL索引定义规范sql上线，先explain，查看索引使用情况尽量避免extra列出现：Using File Sort，Using Temporary，rows超过1000的要谨慎上线。explain解读: type：ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好） possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用 key：表示MySQL实际决定使用的键（索引）,如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX ref：表示选择 key 列上的索引，哪些列或常量被用于查找索引列上的值 rows：根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数 Extra Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询 Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序” 其他索引规范 单个索引字段数不超过5，单表索引数量不超过5，索引设计遵循B+ Tree索引最左前缀匹配原则 选择区分度高的列作为索引，区分度高的放在前面 对字符串使用前缀索引，前缀索引长度不超过8个字符 建议优先考虑前缀索引，必要时可添加伪列并建立索引 建立的索引能覆盖80%主要的查询，不求全，解决问题的主要矛盾 DML和order by和group by字段要建立合适的索引 避免索引的隐式转换隐式转换例子，字段定义为varchar，但传入的值是个int，就会导致全表扫描，要求程序端要做好类型检查字段：remark varchar(50) NOT Null 1234mysql&gt;SELECT id, gift_code FROM gift WHERE deal_id = 640 AND remark=115127;1 row in set (0.14 sec)mysql&gt;SELECT id, gift_code FROM pool_gift WHEREdeal_id = 640 AND remark=‘115127’;1 row in set (0.005 sec) 避免冗余索引 关于主键：表必须有主键 ；不使用更新频繁的列 ；不选择字符串列 ；不使用UUID MD5 HASH ；默认使用非空的唯一键 ，建议选择自增或发号器 重要的SQL必须被索引：UPDATE、DELETE语句的WHERE条件列；ORDER BY、GROUP BY、DISTINCT的字段；多表JOIN的字段 核心SQL优先考虑覆盖索引 不在低基数列上建立索引，例如“性别” 不在索引列进行数学运算和函数运算 尽量不使⽤外键 ，外键用来保护参照完整性，可在业务端实现；对父亲和子表的操作会相互影响，降低可用性 ；INNODB本身对online DDL的限制 不使⽤%前导的查询，如like “%ab” 不使用负向查询，如not in&#x2F;like “无法使用索引，导致全表扫描 最左前缀原则 mysql使用联合索引时，从左向右匹配，遇到断开或者范围查询时，无法用到后续的索引列比如索引idx_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)、(c1,c2)、(c1,c2,c3)三个索引，where条件包含上面三种情况的字段比较则可以用到索引，但像 where c1&#x3D;a and c3&#x3D;c 只能用到c1列的索引，像 c2&#x3D;b and c3&#x3D;c等情况就完全用不到这个索引 尽量不要在频繁更新的列上创建索引如不在定义了 ON UPDATE CURRENT_STAMP 的列上创建索引，维护成本太高（好在mysql有insert buffer，会合并索引的插入） SQL设计规范 杜绝直接 SELECT * 读取全部字段 能确定返回结果只有一条时，使用 limit 1 使用like模糊匹配，%不要放首位会导致索引失效，有这种搜索需求是，考虑其它方案，如sphinx全文搜索 涉及到复杂sql时，务必先参考已有索引设计，先explain IN的内容尽量不超过200个 拒绝大事务比如在一个事务里进行多个select，多个update，如果是高频事务，会严重影响MySQL并发能力，因为事务持有的锁等资源只在事务rollback&#x2F;commit时才能释放。但同时也要权衡数据写入的一致性。 减少与数据库交互的次数，尽量采用批量SQL语句 INSERT … ON DUPLICATE KEY UPDATE …，插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行旧行UPDATE，如果不重复则直接插入，影响1行。 REPLACE INTO类似，但它是冲突时删除旧行。INSERT IGNORE相反，保留旧行，丢弃要插入的新行。 INSERT INTO VALUES(),(),()，合并插入。 去掉where 1&#x3D;1 这样无意义或恒真的条件，如果遇到update&#x2F;delete或遭到sql注入就恐怖了 事务使用规范使用场景、原则等。 行为规范 杜绝危险SQL 大批量更新，如修复数据，避开高峰期，并通知DBA。直接执行sql的由运维或DBA同事操作 及时处理已下线业务的SQL 复杂sql如多表join,count,group by，主动上报DBA评估。 引用 http://seanlook.com/2016/05/11/mysql-dev-principle-ec/http://www.cnblogs.com/chenpingzhao/p/5059985.html hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"mysql","slug":"mysql","permalink":"https://liangyuanzheng.com/categories/mysql/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liangyuanzheng.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"规范","slug":"规范","permalink":"https://liangyuanzheng.com/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"linux-crontab 定时任务","slug":"linux-crontab-定时任务","date":"2017-08-08T11:47:47.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"linux-crontab-定时任务.html","link":"","permalink":"https://liangyuanzheng.com/linux-crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html","excerpt":"定时任务crontab 定时任务详解，各种周期的ct任务写法。我们通过创建ct任务（crontab定时任务），可以达到周期运行脚本的目的。时间周期为：分钟、小时、日、月、周的各种组合。","text":"定时任务crontab 定时任务详解，各种周期的ct任务写法。我们通过创建ct任务（crontab定时任务），可以达到周期运行脚本的目的。时间周期为：分钟、小时、日、月、周的各种组合。 ** 示例 ** 每分钟执行一次 1* * * * * shellCommand 每小时执行一次 10 * * * * shellCommand 每小时的1,10,20分钟执行一次 11,10,20 * * * * shellCommand 8-11点的1,10,20分钟执行一次 11,10,20 8-11 * * * shellCommand 每隔2天的8-11点的1,10,20分钟执行一次 11,10,20 8-11 */2 * * shellCommand 每隔周一的8-11点的1,10,20分钟执行一次 11,10,20 8-11 * * 1 shellCommand hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"linux","slug":"linux","permalink":"https://liangyuanzheng.com/categories/linux/"}],"tags":[{"name":"crontab","slug":"crontab","permalink":"https://liangyuanzheng.com/tags/crontab/"}]},{"title":"黑客与画家","slug":"黑客与画家","date":"2017-07-29T14:37:42.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"黑客与画家.html","link":"","permalink":"https://liangyuanzheng.com/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6.html","excerpt":"","text":"前情提要推荐一本最近看的好书，书还没看完，先整理下，来一波书评，求轻拍^_^ 内容整理自互联网 内容简介《黑客与画家》一书是硅谷创业之父Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。 作者介绍Paul Graham(保罗•格雷厄姆)，《黑客与画家》一书的作者，硅谷创业之父,显然也是一名屌屌的黑客。本科毕业于康奈尔大学，然后在哈佛大学获得计算机科学博士学位。1995年，他创办了Viaweb，帮助个人用户在网上开店，这是世界上第一个互联网应用程序。1998年夏天，Yahoo!公司收购了Viaweb，收购价约为5000万美元。此后，他架起了paulgraham.com，在上面撰写关于软件和创业的文章，以深刻的见解和清晰的表达而著称，迅速引起了轰动。2005年，他身体力行，创建了风险投资公司Y Combinator，将自己的理论转化为实践，目前已经资助了80多家创业公司。现在，他是公认的互联网创业权威。 举个栗子我来介绍一下这本书的几个小章节。 为什么书呆子不受欢迎大家可能都有类似的体会，往往有相似兴趣的人会聚集在一起（比如吃饭、旅行等等）；同样，这部分人往往具有较高的“人气指数”。文中通过观察餐厅就餐的座位分布，并结合自己圈子抛出了第一个结论：作者抛出了本书的第一个结论：“书呆子”与“高智商”有着强烈的正相关关系，与“受欢迎”有一种更强烈的负相关关系。 书中是这样描述的（书中描述的有原因哦，我觉得挺有道理，感兴趣的可以去读一下）：我后来认识很多人，读书的时候都被称为书呆子。从他们身上我发现，”书呆子”与”高智商”有强烈的正相关关系。而这些人在中学里都是不受欢迎的学生，你越喜欢读书，就越不受别人的欢迎，因此”书呆子”和”受欢迎”之间，有一种更强烈的负相关关系。这样看来，”高智商”似乎导致了你不受欢迎。 黑客与画家这个章节通过作者自身的体会（声明一下哈，作者是一个浪浪的奇人，程序员转行去画画，没搞出太大名堂，又回来搞程序）论证了画画一编程之间的共性。保罗是这样说的(方法论哦，值得学习)： 黑客和画家一样，定期从头开始，而不是在一个项目上长年累月的工作，并且试图把所有的新的想法都以修订版的形式包括进去。创作的时候，自身设计一个规格，预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最终会有一个更好的结果。模仿是很好的学习方法，编程和画画一样，在模仿的过程中可以学会注意细节。 媒体评论此书将迫使你重新思考计算机编程的本质。—— Robert Morris，麻省理工学院 真正睿智之士的脑力激荡，读来令人着迷。单单是《为何书呆子不受欢迎》一文就值回书价，它回答了我们这个时代的关键问题。—— Chris Anderson，Wired杂志主编 Paul Graham的思维站在高处，文笔优雅清晰，且不乏幽默，这不仅在像他这样的电脑高手群体中实属罕见，而且足以跻身于优秀作家的行列。—— David Weinberger，《Cluetrain Manifesto》的作者 Paul Graham是一个电脑高手，还是一个画家，以及一个出色的作家。他的文章清晰易懂、幽默生动，充满了与众不同的看法和切实可行的高见。他从艺术、科学、商业互相交织的角度，谈论如何写出优秀的代码。你可能会因为他的文章，而想要用Lisp语言编程。—— Andy Hertzfeld，《Macintosh Computer》的作者 Paul Graham的《黑客与画家》是我最近读到的最发人深思的书籍之一。行文明白流畅，主题多样，而且十分有趣。—— Jeff “hemos” Bates，OSDN的主管和Slashdot的开发者 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"python scrapy框架","slug":"python-scrapy框架","date":"2017-07-21T15:59:15.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"python-scrapy框架.html","link":"","permalink":"https://liangyuanzheng.com/python-scrapy%E6%A1%86%E6%9E%B6.html","excerpt":"","text":"安装Scrapy 安装教程 使用创建新项目创造一个项目： 1scrapy startproject tutorial 目录层级结构如图： 12345678910tutorial scrapy.cfg # 项目的配置文件 tutorial # 项目的python模块, 在这里稍后你将会导入你的代码 __init__.py items.py # 项目items文件 middlewares.py # 项目中间件文件 pipelines.py # 项目管道文件 settings.py # 项目配置文件 spiders # 你的spider目录 __init__.py 定义抓取项定义我们要抓取的内容（items.py）： 1234567891011import scrapyclass TutorialItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() passclass JianShuItem(scrapy.Item): # define the fields for your item here like: title = scrapy.Field() content = scrapy.Field() 创建Spider创建命令： 1scrapy genspider -t basic jianshu jianshu.com 修改Spider内容为： 123456789import scrapyclass CrawlSpider(scrapy.Spider): name = 'crawl' allowed_domains = ['JianShu'] start_urls = ['http://JianShu/'] def parse(self, response): pass 保存数据1scrapy crawl JianShuSpider -o items.json -t json 错误处理[scrapy.core.engine] DEBUG: Crawled (403) &lt;GET http://www.jianshu.com/&gt; (referer: None) 修改DOWNLOADER_MIDDLEWARES配置： 123DOWNLOADER_MIDDLEWARES = &#123; 'scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware' : None,#必需 ,禁用默认的middleware&#125; [scrapy.core.scraper] ERROR: Spider error processing &lt;GET http://www.jianshu.com/&gt; (referer: None) 修改DOWNLOADER_MIDDLEWARES配置： 1234DOWNLOADER_MIDDLEWARES = &#123; 'scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware' : None,#必需 ,禁用默认的middleware 'jianshu.middlewares.JianshuSpiderMiddleware': 543,&#125; 修改middlewares.py配置： 1234567891011from scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass JianShuSpiderAgent(UserAgentMiddleware): def __init__(self,user_agent=''): self.user_agent = user_agent def process_request(self,request,spider): request.headers.setdefault('Host','www.jianshu.com') request.headers.setdefault('User-Agent','Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/53.0.2785.143 Chrome/53.0.2785.143 Safari/537.36')&#125; 参考资料西刺免费代理IPscrapy代理、UA配置Scrapy环境搭建数据抓取框架Scrapy下载中间件scrapy自定义User-Agent如何让你的scrapy爬虫不再被banCnblogsSpider hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://liangyuanzheng.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"https://liangyuanzheng.com/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://liangyuanzheng.com/tags/scrapy/"}]},{"title":"正则表达式用法总结","slug":"正则表达式用法总结","date":"2017-07-19T03:39:08.000Z","updated":"2025-10-27T00:35:41.789Z","comments":true,"path":"正则表达式用法总结.html","link":"","permalink":"https://liangyuanzheng.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93.html","excerpt":"正则表达式在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。","text":"正则表达式在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 发展历史正则表达式的”祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。 1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为”神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为”正则集的代数”的表达式，因此采用”正则表达式”这个术语。 随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。 如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。 正则表达式-语法正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 举个栗子： runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。 runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。 colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 : runo*ob 匹配 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 &#124; 指明两项之间的一个选择。要匹配&#124;，请使用 &#124;。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题： 1/Chapter [1-9][0-9]*/ 请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。 这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。 如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。 1/Chapter [0-9]&#123;1,2&#125;/ 上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下： 1/Chapter [1-9][0-9]?/ 或 1/Chapter [1-9][0-9]&#123;0,1&#125;/ *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下： 1&lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt; 贪婪：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。 1/&lt;.*&gt;/ 非贪婪：如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 &lt;H1&gt;。 1/&lt;.*?&gt;/ 如果只想匹配开始的 H1 标签，表达式则是： 1/&lt;\\w+?&gt;/ 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪心”表达式转换为”非贪心”表达式或者最小匹配。 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个字边界，即字与空格间的位置。 \\B 非字边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首： 1/^Chapter [1-9][0-9]&#123;0,1&#125;/ 真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。 1/^Chapter [1-9][0-9]&#123;0,1&#125;$/ 匹配字边界稍有不同，但向正则表达式添加了很重要的能力。字边界是单词和空格之间的位置。非字边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现字边界后面： 1/\\bCha/ \\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在字边界的前面： 1/ter\\b/ 下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt： 1/\\Bapt/ 字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。对于 \\B 非字边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 正则表达式 - 元字符下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*‘。 {n,m} m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.&#124;\\n)”的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (&#124;) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y&#124;ies) 就是一个比 ‘industry&#124;industries’ 更简略的表达式。 (?&#x3D;pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95&#124;98&#124;NT&#124;2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95&#124;98&#124;NT&#124;2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;&#x3D;pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;&#x3D;95&#124;98&#124;NT&#124;2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95&#124;98&#124;NT&#124;2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 正则表达式 - 运算符优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 运算符 描述 \\ 转义符 (), (?:), (?&#x3D;), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） &#124; 替换，”或”操作，字符具有高于替换运算符的优先级，使得”m&#124;food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m&#124;f)ood”。 正则表达式 - 匹配规则基本模式匹配一切从最基本的开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如： 1^once 这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。 1bucket$ 这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如： 1^bucket$ 只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式 1once 与字符串 12There once was a man from NewYorkWho kept all of his cash in a bucket. 是匹配的。 在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是：\\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式： 1^\\t 类似的，用\\n表示”新行”，\\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\表示，句号.用.表示，以此类推。 字符簇在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。 所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里： 1[AaEeIiOoUu] 这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如： 123456[a-z] //匹配所有的小写字母 [A-Z] //匹配所有的大写字母 [a-zA-Z] //匹配所有的字母 [0-9] //匹配所有的数字 [0-9\\.\\-] //匹配所有的数字，句号和减号 [ \\f\\r\\t\\n] //匹配所有的白字符 同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2”、”t6”或”g7”，但不是”ab2”、”r2d3” 或”b52”的话，用这个模式： 1^[a-z][0-9]$ 尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。 前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示”非”或”排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字： 1^[^0-9][0-9]$ 这个模式与”&amp;5”、”g7”及”-2”是匹配的，但与”12”、”66”是不匹配的。下面是几个排除特定字符的例子： 123[^a-z] //除了小写字母以外的所有字符 [^\\\\\\/\\^] //除了(\\)(/)(^)之外的所有字符 [^\\\"\\'] //除了双引号(\")和单引号(')之外的所有字符 特殊字符”.” (点，句号)在正则表达式中用来表示除了”新行”之外的所有字符。所以模式”^.5$”与任何两个字符的、以数字5结尾和以其他非”新行”字符开头的字符串匹配。模式”.”可以匹配任何字符串，除了空串和只包括一个”新行”的字符串。 PHP的正则表达式有一些内置的通用字符簇，列表如下： 字符簇 描述 [[:alpha:]] 任何字母 [[:digit:]] 任何数字 [[:alnum:]] 任何字母和数字 [[:space:]] 任何空白字符 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 [[:punct:]] 任何标点符号 [[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F] 确定重复出现到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。 字符簇 描述 ^[a-zA-Z_]$ 所有的字母和下划线 ^[[:alpha:]]{3}$ 所有的3个字母的单词 ^a$ 字母a ^a{4}$ aaaa ^a{2,4}$ aa,aaa或aaaa ^a{1,3}$ a,aa或aaa ^a{2,}$ 包含多于两个a的字符串 ^a{2,} 如：aardvark和aaab，但apple不行 a{2,} 如：baad和aaa，但Nantucket不行 \\t{2} 两个制表符 .{2} 所有的两个字符 这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思是前面的字符或字符簇只出现x次 ；一个数字加逗号 {x,} 的意思是前面的内容出现x或更多的次数 ；两个数字用逗号分隔的数字 {x,y} 表示 前面的内容至少出现x次，但不超过y次。我们可以把模式扩展到更多的单词或数字： 1234^[a-zA-Z0-9_]&#123;1,&#125;$ // 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]&#123;0,&#125;$ // 所有的正整数 ^\\-&#123;0,1&#125;[0-9]&#123;1,&#125;$ // 所有的整数 ^[-]?[0-9]+\\.?[0-9]+$ // 所有的浮点数 最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 ([-]?) 开头 (^)、跟着1个或更多的数字([0-9]+)、和一个小数点(.)再跟上1个或多个数字([0-9]+)，并且后面没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。 特殊字符 ? 与 {0,1} 是相等的，它们都代表着： 0个或1个前面的内容 或 前面的内容是可选的 。所以刚才的例子可以简化为： 1^\\-?[0-9]&#123;1,&#125;\\.?[0-9]&#123;1,&#125;$ 特殊字符 * 与 {0,} 是相等的，它们都代表着 0 个或多个前面的内容 。最后，字符 + 与 {1,} 是相等的，表示 1 个或多个前面的内容 ，所以上面的4个例子可以写成： 1234^[a-zA-Z0-9_]+$ // 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]*$ // 所有的正整数 ^\\-?[0-9]+$ // 所有的整数 ^\\-?[0-9]+\\.?[0-9]*$ // 所有的浮点数 当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。 正则表达式 - 示例校验数字的表达式12345678910111213141516171819数字：^[0-9]*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)$正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$有两位小数的正实数：^[0-9]+(\\.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(\\.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$非负整数：^\\d+$ 或 ^[1-9]\\d*|0$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式123456789101112汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 特殊需求表达式1234567891011121314151617181920212223242526272829303132Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\\d&#123;11&#125;)|^((\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;)|(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;))$)身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$钱的输入格式： 1. 有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]\\*$ 2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]\\*)$ 3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]\\*)$ 4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5. 必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\\*(.[0-9]&#123;1,2&#125;)?$ 8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)\\*)(.[0-9]&#123;1,2&#125;)?$ 9. 备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\\u4e00-\\u9fa5]双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 引用 正则表达式 - 教程正则表达式30分钟入门教程正则表达式在线测试正则表达式 例子 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://liangyuanzheng.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"推荐系统初探","slug":"推荐系统初探","date":"2017-07-17T10:15:32.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"推荐系统初探.html","link":"","permalink":"https://liangyuanzheng.com/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2.html","excerpt":"","text":"推荐算法推荐算法通过利用用户的一些行为，通过一些数学算法，推测出用户可能喜欢的东西，筛选合适的数据集，推荐给用户。 推荐算法的分类基于人口统计学的推荐基于人口统计学的推荐（Demographic-based Recommendation）易于实现的推荐方法，它根据系统用户的基本信息发现用户的相似度，然后将相似用户喜爱的其他物品推荐给当前用户。工作原理图：系统对每个根据每个用户的基本信息，计算用户的相似度。比如系统通过计算发现用户A和C比较相似。就会把A喜欢的物品推荐给C。 基于内容的推荐工作原理图：如图给出的一个电影推荐系统，首先对电影的元数据建模，然后计算电影间的相似度。如 A 和 C 会被认为是相似的电影。最后实现推荐，我们可以给用户A推荐类似于电影A的电影C。 基于协同过滤的推荐基于用户的协同过滤推荐基本假设：喜欢类似物品的用户，可能有相似的口味和偏好主要步骤：（1）找出和目标用户兴趣相似的用户集合（2）找到用户集合中A的同类用户喜欢的，A没有接触的物品推荐给A相似度计算：（1）Jaccard公式（2）余弦相似度其中，N(u),N(v)分别代表用户u，v的兴趣集合。用户行为记录表：如图，用户A对物品{a, b, d}有过行为，用户B对物品{a, c}有过行为，利用余弦相似度公式计算用户A和用户B的兴趣相似度为:用户相似度矩阵： A B C D A 1 1&#x2F;&radic;6 1&#x2F;&radic;6 1&#x2F;3 B 1&#x2F;&radic;6 1 0 1&#x2F;&radic;6 C 1&#x2F;&radic;6 0 1 1&#x2F;&radic;6 D 1&#x2F;3 1&#x2F;&radic;6 1&#x2F;&radic;6 1 改进型用户相似度计算该方法通过 1&#x2F;log2(1+|N(i)|) 惩罚了用户u，v共同兴趣列表中热门物品对他们相似度的影响。用户对物品感兴趣程度公式：其中，wuv是用户u、v的相似度，rvi代表用户对物品的兴趣（此处取1）。推荐列表（假设推荐用户数取3）：与A相似的用户为B、C、D，筛选B、C、D感兴趣的物品并且A未关注的，那么A对物品c、e的兴趣为：p(A,c)&#x3D;wAB+wCD&#x3D;0.7416p(A,e)&#x3D;wAC+wCD&#x3D;0.7416 基于人口统计学的推荐和基于用户的协同过滤推荐都是计算用户的相似度，但二者在相似度的计算上有所不同，前者只考虑用户本身的特征，后者会在用户的历史偏好数据上计算用户相似度。 基于项目的协同过滤推荐主要步骤：（1）计算物品之间的相似度（2）根据物品的相似度和用户的历史行为给用户生成推荐列表相似度计算：相似度矩阵：推荐结果的算法类似于【基于用户的协同过滤推荐】，略之。 基于内容的推荐和基于项目的协同过滤推荐同样都是基于物品相似度进行推荐，只是相似度计算的方法不一样，前者是是基于物品本身的属性特征信息，而后者会从用户历史的偏好推断。 协同过滤总结UserCF、ItemCF比较：UserCF侧重于挖掘有共同兴趣的人喜欢的物品,反应用户兴趣相似的群体热点，更加社会化；ItemCF侧重于挖掘用户曾经喜欢过的类似的物品,维系用户的历史兴趣，更加个性化； UserCF ItemCF 性能 适用于用户较少的场合,如果用户很多,计算用户相似度矩阵代价很大 适用于物品数明显小于用户数的场合,如果物品 很多(网页),计算物品相似度矩阵代价很大 领域 时效性较强,用户个性化兴趣不太明显的领域 长尾物品丰富,用户个性化需求强烈的领域 实时性 用户有新行为,不一定造成推荐结果的立即变化 用户有新行为，一定会导致推荐结果的实时变化 冷启动 在新用户对很少的物品产生行为后,不能立即对他 进行个性化推荐,因为用户相似度表是每隔一段时间离线计算的;新物品上线后一段时间,一旦有用户对物品产生行为,就可以将新物品推荐给和对它产生行为的用户 兴趣相似的其他用户 新用户只要对一个物品产生行为,就可以给他推荐和该物品相关的其他物品;但没有办法在不离线更新物品相似度表的情况下将新物品推荐给用户 推荐理由 很难提供令用户信服的推荐解释 利用用户的历史行为给用户做推荐解释,可以令用户比较信服 CF的优势：a 它不需要对物品或用户进行严格建模，不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。b 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好。CF的不足：a 方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。b 推荐的效果依赖于用户历史偏好数据的多少和准确性。c 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。d 对于一些特殊品味的用户不能给予很好的推荐。e 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。 混合的推荐机制在现行的 Web 站点上的推荐往往都不是单纯只采用了某一种推荐的机制和策略，他们往往是将多个方法混合在一起，从而达到更好的推荐效果。关于如何组合各个推荐机制，这里讲几种比较流行的组合方法。 加权的混合（Weighted Hybridization）: 用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最好的推荐效果。 切换的混合（Switching Hybridization）：前面也讲到，其实对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，那么切换的混合方式，就是允许在不同的情况下，选择最为合适的推荐机制计算推荐。 分区的混合（Mixed Hybridization）：采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户。其实，Amazon，当当网等很多电子商务网站都是采用这样的方式，用户可以得到很全面的推荐，也更容易找到他们想要的东西。 分层的混合（Meta-Level Hybridization）: 采用多种推荐机制，并将一个推荐机制的结果作为另一个的输入，从而综合各个推荐机制的优缺点，得到更加准确的推荐。 推荐引擎的应用豆瓣猜豆瓣是国内做的比较成功的社交网站，它以图书，电影，音乐和同城活动为中心，形成一个多元化的社交网络平台。豆瓣图书推荐：豆瓣电影推荐： 补充补全用户缺失评分数据SlopeOne 算法采用均质化的思想来掩盖个体的打分差异。计算方法： rating 洗衣机 电冰箱 张三 5 10 李四 4 5 王五 4 ? SlopeOne 算法采用均值化的思想，R王五 &#x3D; 4-{ [ (5 - 10) + (4 - 5) ] &#x2F; 2} &#x3D; 7 对于多组数据：rb &#x3D; (n * (ra - R(A-&gt;B)) + m * (rc - R(C-&gt;B))) &#x2F; (m+n)其中，a,b,c 代表“商品”；ra 代表“商品的打分值”；R(A-&gt;B) 代表“A组到B组的平均差（均值化）”；m,n 代表人数。 rating 洗衣机 电冰箱 彩电 空调 张三 5 10 10 5 李四 4 5 4 10 王五 4 10 ? 5 R王五 &#x3D; (2 * (4 - R(洗衣机-&gt;彩电)) + 2 * (10 - R(电冰箱-&gt;彩电))+ 2 * (5 - R(空调-&gt;彩电)))&#x2F;(2+2+2)&#x3D;6.8 系列文章：推荐系统的常用算法概述从算法到案例：推荐系统必读的10篇精选技术文章机器学习相关——协同过滤推荐引擎初探推荐算法综述（一）推荐算法综述（二）推荐算法综述（三）推荐算法综述（四）推荐算法综述（五）从item-base到svd再到rbm，多种Collaborative Filtering(协同过滤算法)从原理到实现推荐算法之 Slope One 算法SlopeOne 算法推荐算法之 slope one 算法-CSDN推荐算法之 Slope One 算法-博客园经典算法题每日演练——第六题 协同推荐SlopeOne 算法使用SVD++进行协同过滤(算法原理部分主要引用自他人)-布布扣-bubu—-Slope One Predictors for Online Rating-Based Collaborative Filtering知乎上的推荐算法相关问题 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"essay","slug":"essay","permalink":"https://liangyuanzheng.com/categories/essay/"}],"tags":[{"name":"推荐系统","slug":"推荐系统","permalink":"https://liangyuanzheng.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"php.ini修改php上传文件大小限制","slug":"php-ini修改php上传文件大小限制","date":"2017-07-13T03:18:52.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"php-ini修改php上传文件大小限制.html","link":"","permalink":"https://liangyuanzheng.com/php-ini%E4%BF%AE%E6%94%B9php%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6.html","excerpt":"","text":"打开php.ini，首先找到file_uploads &#x3D; on ;是否允许通过HTTP上传文件的开关。默认为ON即是开upload_tmp_dir ;文件上传至服务器上存储临时文件的地方，如果没指定就会用系统默认的临时文件夹upload_max_filesize &#x3D; 8m ;望文生意，即允许上传文件大小的最大值。默认为2Mpost_max_size &#x3D; 8m ;指通过表单POST给PHP的所能接收的最大值，包括表单里的所有值。默认为8M 一般地，设置好上述四个参数后，上传&lt;&#x3D;8M的文件是不成问题，在网络正常的情况下。但如果要上传&gt;8M的大体积文件，只设置上述四项还一定能行的通。 进一步配置以下的参数max_execution_time &#x3D; 600 ;每个PHP页面运行的最大时间值(秒)，默认30秒max_input_time &#x3D; 600 ;每个PHP页面接收数据所需的最大时间，默认60秒memory_limit &#x3D; 8m ;每个PHP页面所吃掉的最大内存，默认8M把上述参数修改后，在网络所允许的正常情况下，就可以上传大体积文件了 1234567max_execution_time = 600 max_input_time = 600 memory_limit = 32m file_uploads = on upload_tmp_dir = /tmp upload_max_filesize = 32m post_max_size = 32m 引用地址：文章1 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"php","slug":"php","permalink":"https://liangyuanzheng.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://liangyuanzheng.com/tags/php/"}]},{"title":"高效代码审查的十个经验","slug":"高效代码审查的十个经验","date":"2017-07-09T08:23:38.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"高效代码审查的十个经验.html","link":"","permalink":"https://liangyuanzheng.com/%E9%AB%98%E6%95%88%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%8D%81%E4%B8%AA%E7%BB%8F%E9%AA%8C.html","excerpt":"代码审查（Code Review)是软件开发中常用的手段，和 QA 测试相比，它更容易发现和架构以及时序相关等较难发现的问题，还可以帮助团队成员提高编程技能，统一编程风格等。","text":"代码审查（Code Review)是软件开发中常用的手段，和 QA 测试相比，它更容易发现和架构以及时序相关等较难发现的问题，还可以帮助团队成员提高编程技能，统一编程风格等。 代码审查要求团队有良好的文化团队需要认识到代码审查是为了提高整个团队的能力，而不是针对个体设置的检查“关卡”。“A 的代码有个 bug 被 B 发现，所以 A 能力不行，B 能力更好”，这一类的陷阱很容易被扩散从而影响团队内部的协作，因此需要避免。另外，代码审查本身可以提高开发者的能力，让其从自身犯过的错误中学习，从他人的思路中学习。如果开发者对这个流程有抵触或者反感，这个目的就达不到。 谨慎的使用审查中问题的发现率作为考评标准 在代码审查中如果发现问题，对于问题的发现者来说这是好事，应该予以鼓励。但对于被发现者，我们不主张使用这个方式予以惩罚。软件开发中 bug 在所难免，过度苛求本身有悖常理。更糟的是，如果造成参与者怕承担责任，不愿意在审查中指出问题，代码审查就没有任何的价值和意义。 控制每次审查的代码数量根据 smartbear 在思科所作的调查，每次审查 200 行-400 行的代码效果最好。每次试图审查的代码过多，发现问题的能力就会下降，具体的比例关系如下图所示： 我们在实践中发现，随着开发平台和开发语言的不同，最优的代码审查量有所不同。但是限制每次审查的数量确实非常必要，因为这个过程是高强度的脑力密集型活动。时间一长，代码在审查者眼里只是字母，无任何逻辑联系，自然不会有太多的产出。 带着问题去进行审查我们在每次代码审查中，要求审查者利用自身的经验先思考可能会碰到的问题，然后通过审查工作验证这些问题是否已经解决。一个窍门是，从用户可见的功能出发，假设一个比较复杂的使用场景，在代码阅读中验证这个使用场景是否能够正确工作。使用这个技巧，可以让审查者有代入感，真正的沉浸入代码中，提高效率。大家都知道看武侠小说不容易瞌睡，而看专业书容易瞌睡，原因就是武侠小说更容易产生代入感。有的研究建议每次树立目标，控制单位时间内审核的代码数量。这个方法在我们的实践中显得很机械和流程化，不如上面的方法效果好。 所有的问题和修改，必须由原作者进行确认如果在审查中发现问题，务必由原作者进行确认。这样做有两个目的：(1)确认问题确实存在，保证问题被解决(2)让原作者了解问题和不足，帮助其成长有些时候为了追求效率，有经验的审查者更倾向于直接修改代码乃至重构所有代码，但这样不利于提高团队效率，并且会增加因为重构引入新 bug 的几率，通常情况下我们不予鼓励。 利用代码审查激活个体“能动性”即使项目进度比较紧张，无法完全的进行代码审查，至少也要进行部分代码的审查，此时随即抽取一些关键部分是个不错的办法。背后的逻辑是，软件开发是非常有创造性的工作，开发者都有强烈的自我驱动性和自我实现的要求。让开发者知道他写的任何代码都可能被其他人阅读和审察，可以促使开发者集中注意力，尤其是避免将质量糟糕，乃至有低级错误的代码提交给同伴审查。开源软件也很好的利用了这种心态来提高代码质量。 在非正式，轻松的环境下进行代码审查如前所述，代码审查是一个脑力密集型的工作。参与者需要在比较轻松的环境下进行该工作。因此，我们认为像某些实践中建议的那样，以会议的形式进行代码审查效果并不好，不仅因为长时间的会议容易让效率低下，更因为会议上可能出现的争议和思考不利于进行如此复杂的工作。 提交代码前自我审查，添加对代码的说明所有团队成员在提交代码给其他成员审查前，必须先进行一次审查。这次自我修正形式的审查除了检查代码的正确性以外，还可以完成如下的工作：(1)对代码添加注释，说明本次修改背后的原因，方便其他人进行审查。(2)修正编码风格，尤其是一些关键数据结构和方法的命名，提高代码的可读性。(3)从全局审视设计，是否完整的考虑了所有情景。在实现之前做的设计如果存在考虑不周的情况，这个阶段可以很好的进行补救。我们在实践中发现，即使只有原作者进行代码审查，仍然可以很好的提高代码质量。 实现中记录笔记可以很好的提高问题发现率成员在编码的时候应做随手记录，包括在代码中用注释的方式表示，或者记录简单的个人文档，这样做有几个好处：(1)避免遗漏。在编码时将考虑到的任何问题都记录下来，在审查阶段再次检查这些问题都确认解决。(2)根据研究，每个人都习惯犯一些重复性的错误。这类问题在编码是记录下来，可以在审查的时候用作检查的依据。(3)在反复记录笔记并在审查中发现类似的问题后，该类问题出现率会显著下降 使用好的工具进行轻量级的代码审查“工欲善其事，必先利其器”。我们使用的是 bitbucket 提供的代码托管服务。每个团队成员独立开发功能，然后利用 Pull Request 的形式将代码提交给审查者。复审者可以很方便在网页上阅读代码，添加评论等，然后原作者会自动收到邮件提醒，对审阅的意见进行讨论。即使团队成员分布在天南海北，利用 bitbucket 提供的工具也能很好的进行代码审查。 原文：http://www.html5cn.org/article-4001-1.html——转摘自互联网 hljs.tabReplace = ' '; hljs.initHighlightingOnLoad();","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"代码审查","slug":"代码审查","permalink":"https://liangyuanzheng.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"}]},{"title":"执行hexo时的一些报错处理","slug":"执行hexo时的一些报错处理","date":"2017-07-09T03:49:15.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"执行hexo时的一些报错处理.html","link":"","permalink":"https://liangyuanzheng.com/%E6%89%A7%E8%A1%8Chexo%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86.html","excerpt":"主要有一下几个报错处理: Uncaught TypeError: Cannot read property ‘addEventListener’ of null 执行hexo algolia时报TypeError: Cannot read property ‘filter’ of undefined 执行hexo algolia时报Error AlgoliaSearchNodeJS.AlgoliaSearchCore 执行hexo g时报Error: Cannot find module DTraceProviderBindings","text":"主要有一下几个报错处理: Uncaught TypeError: Cannot read property ‘addEventListener’ of null 执行hexo algolia时报TypeError: Cannot read property ‘filter’ of undefined 执行hexo algolia时报Error AlgoliaSearchNodeJS.AlgoliaSearchCore 执行hexo g时报Error: Cannot find module DTraceProviderBindings Uncaught TypeError: Cannot read property ‘addEventListener’ of null报错信息 123456(index):1690 Uncaught TypeError: Cannot read property 'addEventListener' of null at Object.success ((index):1690) at j (index.js?v=2.1.3:2) at Object.fireWith [as resolveWith] (index.js?v=2.1.3:2) at x (index.js?v=2.1.3:4) at XMLHttpRequest.&lt;anonymous&gt; (index.js?v=2.1.3:4) 修复方法修改主题配置：关闭local_search 12345678# Local searchlocal_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 修改站点配置： 12345678search: true#search:# path: search.xml# field: post# format: html# limit: 10000# filter:# - title 执行hexo algolia时报TypeError: Cannot read property ‘filter’ of undefined报错信息 1234567891011121314151617181920212223FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTypeError: Cannot read property 'filter' of undefined at getFields (/home/work/github/blog/LeungGeorge.github.io/node_modules/hexo-algoliasearch/lib/algolia.js:146:16) at Hexo.algolia (/home/work/github/blog/LeungGeorge.github.io/node_modules/hexo-algoliasearch/lib/algolia.js:16:16) at Hexo.tryCatcher (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/util.js:16:23) at Hexo.ret (eval at makeNodePromisifiedEval (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promisify.js:184:12), &lt;anonymous&gt;:13:39) at /home/work/github/blog/LeungGeorge.github.io/node_modules/hexo/lib/hexo/index.js:195:9 at Promise._execute (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/debuggability.js:300:9) at Promise._resolveFromExecutor (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/promise.js:79:10) at Hexo.call (/home/work/github/blog/LeungGeorge.github.io/node_modules/hexo/lib/hexo/index.js:191:10) at /usr/local/lib/node_modules/hexo-cli/lib/hexo.js:66:17 at tryCatcher (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/promise.js:693:18) at Async._drainQueue (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/async.js:133:16) at Async._drainQueues (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/async.js:143:10) at Immediate.Async.drainQueues (/usr/local/lib/node_modules/hexo-cli/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:637:20) at tryOnImmediate (timers.js:610:5) at processImmediate [as _immediateCallback] (timers.js:582:5) 修复方法 修改站点配置，修改algolia的filter 123algolia: filter: - title 执行hexo algolia时报Error AlgoliaSearchNodeJS.AlgoliaSearchCore报错信息 123456789101112131415161718192021/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/async.js:61 fn = function () &#123; throw arg; &#125;; ^Error at AlgoliaSearchNodeJS.AlgoliaSearchCore (/home/work/github/blog/LeungGeorge.github.io/node_modules/algoliasearch/src/AlgoliaSearchCore.js:51:11) at AlgoliaSearchNodeJS.AlgoliaSearch (/home/work/github/blog/LeungGeorge.github.io/node_modules/algoliasearch/src/AlgoliaSearch.js:11:21) at AlgoliaSearchNodeJS.AlgoliaSearchServer (/home/work/github/blog/LeungGeorge.github.io/node_modules/algoliasearch/src/server/builds/AlgoliaSearchServer.js:17:17) at new AlgoliaSearchNodeJS (/home/work/github/blog/LeungGeorge.github.io/node_modules/algoliasearch/src/server/builds/node.js:79:23) at algoliasearch (/home/work/github/blog/LeungGeorge.github.io/node_modules/algoliasearch/src/server/builds/node.js:68:10) at /home/work/github/blog/LeungGeorge.github.io/node_modules/hexo-algoliasearch/lib/algolia.js:119:18 at tryCatcher (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/util.js:16:23) at Promise.successAdapter [as _fulfillmentHandler0] (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/nodeify.js:22:30) at Promise._settlePromise (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/promise.js:566:21) at Promise._settlePromise0 (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/promise.js:693:18) at Async._drainQueue (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/async.js:133:16) at Async._drainQueues (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/async.js:143:10) at Immediate.Async.drainQueues (/home/work/github/blog/LeungGeorge.github.io/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:637:20) at tryOnImmediate (timers.js:610:5) at processImmediate [as _immediateCallback] (timers.js:582:5) 修复方法安装&#104;&#101;&#120;&#x6f;&#x2d;&#x61;&#x6c;&#103;&#111;&#108;&#x69;&#x61;&#64;&#x30;&#46;&#x32;&#46;&#48;，再执行hexo algolia就可以了 1234npm install hexo-algolia@0.2.0hexo cleanhexo ghexo algolia 执行hexo g时报Error: Cannot find module DTraceProviderBindings报错信息 1234567891011121314151617&#123; Error: Cannot find module './build/default/DTraceProviderBindings' at Function.Module._resolveFilename (module.js:472:15) at Function.Module._load (module.js:420:25) at Module.require (module.js:500:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/dtrace-provider.js:17:23) at Module._compile (module.js:573:32) at Object.Module._extensions..js (module.js:582:10) at Module.load (module.js:490:32) at tryModuleLoad (module.js:449:12) at Function.Module._load (module.js:441:3) at Module.require (module.js:500:17) at require (internal/module.js:20:19) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/hexo/node_modules/bunyan/lib/bunyan.js:79:18) at Module._compile (module.js:573:32) at Object.Module._extensions..js (module.js:582:10) at Module.load (module.js:490:32) code: 'MODULE_NOT_FOUND' &#125; 解决办法重装：hexo-cli 12npm uninstall hexo-cli -g npm install hexo-cli -g hljs.tabReplace = ' '; hljs.initHighlightingOnLoad(); 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://liangyuanzheng.com/tags/hexo/"}]},{"title":"hexo搭建github个人博客","slug":"hexo搭建github个人博客","date":"2017-07-09T01:48:42.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"hexo搭建github个人博客.html","link":"","permalink":"https://liangyuanzheng.com/hexo%E6%90%AD%E5%BB%BAgithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html","excerpt":"使用 hexo 搭建 github个人博客。","text":"使用 hexo 搭建 github个人博客。 安装Hexo安装node.js123sudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install nodejs 安装hexo1sudo npm install hexo -g Hexo命令写博客常用命令常用： 12345hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub 简写: 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 复合： 12hexo deploy -ghexo server -g shell 打包命令写一个shell文件，把上面的命令写到里面，这样就不用每次都敲一遍了，嘿嘿。。。例如：创建preview.sh，内容如下，这样就可以直接预览了： 1234#!/bin/bashhexo cleanhexo ghexo s 创建push，内容如下，这样就可以push到github了： 12345678#!/bin/bashgit pullhexo ghexo dgit add --allgit commit -m \"auto commit\"git push origin hexogit pull 主题其他主题安装方法类似 NexT主题配置使用主题下载进入博客目录文件 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改站点配置文件配置theme为：next 123456789101112# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape# theme: yilia# theme: pacman# theme: jacman# theme: hexo-theme-next# theme: uno# theme: concise# theme: hexo-theme-freemindtheme: next 修改主题配置修改Scheme：Mist 1234# Schemes# scheme: Musescheme: Mist#scheme: Pisces TOC设置成全部展开修改 next 主题样式，themes/next/source/css/_common/components/sidebar/sidebar-toc.styl： 1.post-toc .nav .nav-child &#123; display: none; &#125; 修改为： 1.post-toc .nav .nav-child &#123; display: block; &#125; 效果如图： 添加阅读进度添加点击鼠标红心效果1、新增js文件在\\themes\\next\\source\\js\\src目录新增love.js文件。内容为： 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2、引用js找到\\themes\\next\\layout_layout.swing文件，在文件的后面，之前 添加以下代码： 12&lt;!-- 小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/love.js\"&gt;&lt;/script&gt; 添加文章阅读数 使用 LeanCloud 添加文章阅读量 1、修改配置:themes&#x2F;next&#x2F;_config.yml 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 你申请的app_id app_key: 你申请的app_key 2、修改对应的语言配置（例如我的是汉语）：themes&#x2F;next&#x2F;languages&#x2F;zh-Hans.yml 12post: visitors: 阅读 插件RSS插件安装hexo-generator-feed 1npm install hexo-generator-feed --save 修改站点配置文件 123456feed: type: atom path: atom.xml limit: 20 hub: content: Sitemap插件给博客生成一个站点地图，提交搜索引擎 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 修改站点配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 【搜索优化】Hexo-next百度和谷歌搜索优化【搜索优化】Hexo-next百度和谷歌搜索优化 搜索插件集成Algolia**1.注册Algolia，创建Index ** 前往 Algolia 注册页面，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。 2.安装hexo algolia Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： 1npm install --save hexo-algolia 3.设置key，更新站点配置文件 在 Algolia 服务站点上找到需要使用的一些配置的值，包括 ApplicationID、Search API Key、 Admin API Key。注意，Admin API Key 需要保密保存。 编辑 站点配置文件，新增以下配置(替换除了 chunkSize 以外的其他字段为在 Algolia 获取到的值)： 12345678algolia: applicationID: applicationID apiKey: apiKey adminApiKey: adminApiKey indexName: indexName chunkSize: 5000 filter: - title 注意：此处的filter与Algolia的Searchable attributes保持一致。 4.更新index 当配置完成，在站点根目录下执行 hexo algolia 来更新 Index。请注意观察命令的输出。 5.主题集成 更改主题配置文件，找到 Algolia Search 配置部分,将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。 12345678910algolia: true# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: \"We didn't find any results for the search: $&#123;query&#125;\" hits_stats: \"$&#123;hits&#125; results found in $&#123;time&#125; ms\" Local Search插件1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 2.编辑 站点配置文件，新增以下内容 12345search: path: search.xml field: post format: html limit: 10000 3.编辑 主题配置文件，启用本地搜索功能： enable修改为：true 12345678# Local searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 图片插件安装1npm install https://github.com/CodeFalling/hexo-asset-image -- save 修改站点配置1post_asset_folder: true #是否启动资源文件夹 使用注意，test-image.png放到md文件对应的目录中。格式如下（无需包含路径名）： 1![image](test-image.png) 评论设置404页面在主题目录新增404.html文件(配置为腾讯公益)，内容为： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; &lt;meta name=\"robots\" content=\"all\" /&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\" homePageName=\"BackToHomePage\"&gt; &lt;/script&gt; &lt;script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果预览： 统计百度统计注册百度统计获取统计串： 修改主题配置主题配置文件中增加baidu_analytics配置。注意:修改85c063245825f8a02c40f450c05f5d86为自己的串 12# Baidu Analytics IDbaidu_analytics: 85c063245825f8a02c40f450c05f5d86 检查安装效果：大概过20分钟，就可以去百度统计看到效果了。 更新总结引用 安装Hexo hexo.io hexo 安装 blog-admin 博客插件 Hexo的Next主题配置 Hexo(Pages)—优化博客 Hexo 插件 基于 Hexo 从零开始搭建个人博客（五）","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://liangyuanzheng.com/tags/hexo/"}]},{"title":"浏览器地址栏输入一个URL按下回车","slug":"浏览器地址栏输入一个url按下回车","date":"2017-07-01T03:04:51.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"浏览器地址栏输入一个url按下回车.html","link":"","permalink":"https://liangyuanzheng.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6.html","excerpt":"","text":"当你在浏览器地址栏输入一个 URL 后回车，将会发生的事情？这是一道经典的面试题，同时也是一道复杂的题目，涉及到很多东西，不同的软件开发者对于此道问题有不同的答案，对于其中的某一点也能无限深究，今天我们就来侧重于 web 前端来看一下究竟发生了什么。 基本流程： ① 查询 ip 地址 ② 建立 tcp 连接，接入服务器 ③ 浏览器发起 http 请求 ④ 服务器后台操作并做出 http 响应 ⑤ 网页的解析与渲染 一. 浏览器解析出 url 中的域名url 由通信协议+域名+端口号+资源路径组成，浏览器需要从 url 中解析要请求的域名 二. DNS 解析找到域名对应的 IP 地址，该过程分为如下 10 步： 查询浏览器的 DNS 缓存 若浏览器缓存中未找到该域名对应的 ip，则查找操作系统的 DNS 缓存，即 hosts 文件中的域名与 ip 的映射关系 若在操作系统缓存中也没有找到，则查找本地 DNS 服务器缓存。 若本地 DNS 缓存中仍然没有找到，则直接请求 Root Server 域名服务器 根域名服务器返回给本地服务器一个所查询域的主域名服务器（gTLD Server）地址，gTLD 是顶级域名服务器，如 .com、.cn、.org 等。 本地域名服务器向上一步返回的 gTLD 服务器发送解析请求。 gTLD 接受请求查找并返回此域名对应的 Name Server 域名服务器的地址 本地域名服务器向 Name Server 域名服务器发送解析请求，Name Server 域名服务器找到该域名对应的 ip，连同一个 TTL 值返回给本地域名服务器。 本地域名服务器缓存该域名和 ip 的对应关系，缓存时间由 TTL 的值控制。 把解析结果返回给用户，用户根据 TTL 值进行缓存。 三. 客户端与服务器建立 TCP 连接通过三次握手，建立了客户端和服务器之间的连接 第一次握手：客户端向服务器端发送请求（SYN&#x3D;1） 等待服务器确认； 第二次握手：服务器收到请求并确认，回复一个指令（SYN&#x3D;1，ACK&#x3D;1）； 第三次握手：客户端收到服务器的回复指令并返回确认（ACK&#x3D;1）。 四. 浏览器与服务器进行数据传输浏览器向服务器发送 http 的请求报文，浏览器从服务器读取响应报文，然后浏览器关闭连接。 五. 浏览器渲染页面客户端拿到服务器端传输来的文件，找到 HTML 和 MIME 文件，通过 MIME 文件，浏览器知道要用页面渲染引擎来处理 HTML 文件。 浏览器会解析 html 源码，然后创建一个 DOM 树。 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。 浏览器解析 CSS 代码，计算出最终的样式数据，形成 css 对象模型 CSSOM。 首先会忽略非法的 CSS 代码，之后按照浏览器默认设置——用户设置——外链样式——内联样式——HTML 中的 style 样式顺序进行渲染。 利用 DOM 和 CSSOM 构建一个渲染树（rendering tree）。 渲染树和 DOM 树有点像，但是是有区别的。 DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。 而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。 浏览器就根据渲染树直接把页面绘制到屏幕上。 当我们在浏览器地址栏输入一个 URL，按下回车发生了什么？在浏览器地址栏输入 URL，按下回车后究竟发生了什么？","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"writing","slug":"writing","permalink":"https://liangyuanzheng.com/tags/writing/"}]},{"title":"第一次使用VS Code时你应该知道的一切配置","slug":"第一次使用VS Code时你应该知道的一切配置","date":"2017-06-30T16:00:00.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"第一次使用VS Code时你应该知道的一切配置.html","link":"","permalink":"https://liangyuanzheng.com/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8VS%20Code%E6%97%B6%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"前言 文章标题：《第一次使用 VS Code 时你应该知道的一切配置》。本文的最新内容，更新于 2021-10-09。大家完全不用担心这篇文章会过时，因为随着 VS Code 的版本更新和插件更新，本文也会随之更新。 本文的最新内容，也会在 GitHub 上同步更新，欢迎 star。 VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网青年正在使用它。 前端男神尤雨溪大大这样评价 VS Code： 有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 Electron）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律： 任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。 Jeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。 前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。 如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「主力开发工具」。这款软件是为前端同学量身定制的。 如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「代码编辑器」来使用，纵享丝滑。 甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown 写作工具，毫无违和感。 退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的文本编辑器来使用，完胜 Windows 系统自带的记事本。 写下这篇文章，是顺势而为。 一、VS Code 的介绍VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。 微软有两种软件：一种是 VS Code，一种是其他软件。 IDE 与编辑器的对比IDE 和编辑器是有区别的： IDE（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。 编辑器：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。 需要注意的是，VS Code 的定位是编辑器，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。 VS Code 的特点 VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。 跨平台支持 MacOS、Windows 和 Linux 等多个平台。 VS Code 的源代码以 MIT 协议开源。 支持第三方插件，功能强大，生态系统完善。 自带丰富的调试功能。 自带 emmet：支持代码自动补全，快速地生成简单的语法结构。要知道，这个功能在 Sublime Text 中，得先安装插件才行。 VS Code 自带了 JavaScript、TypeScript 和 Node. Js 的语法支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的扩展包插件，也会有智能提示。 前端利器之争： VS Code 与 WebStorm前端小白最喜欢问的一个问题是：哪个编辑器&#x2F;IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比： 哪个更酷：显然 VS Code 更酷。 内存占用情况：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。 使用比例：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120 个后台、80 个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。 所以，如果你以后还问这个问题，那就真有些掉底了。 VS Code 的安装 VS Code 官网：https://code.visualstudio.com VS Code 的安装很简单，直接去官网下载安装包，然后双击安装即可。 上图中，直接点击 download，一键下载安装即可。 VS Code 支持以下平台： 二、崭露锋芒：VS Code 快捷键VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。 任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？ 但我想说的是：**那从来都不是同样的 20%**，每个人都会用到不同的功能。 掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。 1、工作区快捷键 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + P Ctrl + Shift + P，F 1 显示命令面板 Cmd + B Ctrl + B 显示&#x2F;隐藏侧边栏 很实用 Cmd + \\ Ctrl + \\ 创建多个编辑器 【重要】抄代码利器 Cmd + 1、2 Ctrl + 1、2 聚焦到第 1、第 2 个编辑器 同上重要 Cmd + +、Cmd + - ctrl + +、ctrl + - 将工作区放大&#x2F;缩小（包括代码字体、左侧导航栏） 在投影仪场景经常用到 Cmd + J Ctrl + J 显示&#x2F;隐藏控制台 Cmd + Shift + N Ctrl + Shift + N 重新开一个软件的窗口 很常用 Cmd + Shift + W Ctrl + Shift + W 关闭软件的当前窗口 Cmd + N Ctrl + N 新建文件 Cmd + W Ctrl + W 关闭当前文件 2、跳转操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + ` 没有 在同一个软件的多个工作区之间切换 使用很频繁 Cmd + Option + 左右方向键 Ctrl + Pagedown&#x2F;Pageup 在已经打开的多个文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的多个文件之间进行跳转 不如上面的快捷键快 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 Ctrl + G Ctrl + G 跳转到指定行 Cmd+Shift+\\ Ctrl+Shift+\\ 跳转到匹配的括号 3、移动光标 Mac 快捷键 Win 快捷键 作用 备注 方向键 方向键 在单个字符之间移动光标 大家都知道 option + 左右方向键 Ctrl + 左右方向键 在单词之间移动光标 很常用 Cmd + 左右方向键 Fn + 左右方向键 在整行之间移动光标 很常用 Cmd + ← Fn + ←（或 Win + ←） 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + →（或 Win + →） 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 Cmd + Shift + \\ 在代码块之间移动光标 4、编辑操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + C Ctrl + C 复制 Cmd + X Ctrl + X 剪切 Cmd + C Ctrl + V 粘贴 Cmd + Enter Ctrl + Enter 在当前行的下方新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Cmd+Shift+Enter Ctrl+Shift+Enter 在当前行的上方新增一行，然后跳至该行 即使光标不在行尾，也能快速向上插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 Option + Shift + ↑ Alt + Shift + ↑ 将代码向上复制一行 Option + Shift + ↓ Alt + Shift + ↓ 将代码向下复制一行 写重复代码的利器 另外再补充一点：将光标点击到某一行的任意位置时，默认就已经是选中全行了，此时可以直接复制或剪切，无需点击鼠标。这个非常实用，是所有的编辑操作中，使用得最频繁的。它可以有以下使用场景： 场景 1：假设光标现在处于第 5 行的任意位置，那么，直接依次按下 Cmd + C 和 Cmd + V，就会把这行代码复制到第 6 行。继续按 Cmd + C 和 Cmd + V，就会把这行代码复制到第 7 行。Copy 代码 so easy。 场景 2：假设光标现在处于第 5 行，那么，先按下 Cmd + C，然后按两下 ↑ 方向键，此时光标处于第 3 行；紧接着，继续按下 Cmd + V，就会把刚刚那行代码复制到第 3 行，原本处于第 3 行的代码会整体下移。 你看到了没？上面的两个场景，我全程没有使用鼠标，只通过简单的复制粘贴和方向键，就做到了如此迅速的 copy 代码。你说是不是很高效？ 5、多光标编辑 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 上下键 Ctrl + Alt + 上下键 在连续的多列上，同时出现光标 Option + 鼠标点击任意位置 Alt + 鼠标点击任意位置 在任意位置，同时出现光标 Option + Shift + 鼠标拖动 Alt + Shift + 鼠标拖动 在选中区域的每一行末尾，出现光标 Cmd + Shift + L Ctrl + Shift + L 在选中文本的所有相同内容处，出现光标 其他的多光标编辑操作：（很重要） 选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键），即可将全文中相同的词逐一加入选择。 选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。 6、删除操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + Backspace 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。 7、编程语言相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + &#x2F; Ctrl + &#x2F; 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 F 2 F 2 以重构的方式进行重命名 改代码备 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 8、搜索相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + F Ctrl + Shift +F 全局搜索代码 很常用 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件名 Cmd + F Ctrl + F 在当前文件中搜索代码，光标在搜索框里 Cmd + G F 3 在当前文件中搜索代码，光标仍停留在编辑器里 很巧妙 9、自定义快捷键按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。 当然，你也可以选择菜单栏「偏好设置 –&gt; 键盘快捷方式」，进入快捷键的设置： 10、快捷键列表你可以点击 VS Code 左下角的齿轮按钮，效果如下： 上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了： 快捷键参考链接 快捷键速查表[官方]：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 三、纵享丝滑：常见操作1、快速生成 HTML 骨架先新建一个空的 html 文件，然后通过以下方式，可以快速生成 html 骨架。 方式 1：输入 !，然后按下 enter 键，即可生成 html 骨架。如下图： 方式 2：输入 html:5，然后按住 Tab 键，即可生成 html 骨架。 生成的骨架，内容如下： 1&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 有了上面的 html 骨架之后，我们就可以快乐地在里面插入 CSS 代码和 JS 代码。 2、左右显示多个编辑器窗口（抄代码利器）Mac 用户按住快捷键 Cmd + \\， Windows 用户按住快捷键 Ctrl + \\，即可同时打开多个编辑器窗口。 按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。 学会了这一招，以后抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。 四、高端访问：命令面板的使用Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键 Ctrl+Shift+P），可以打开命令面板。效果如下： 如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。 1、VS Code 设置为中文语言Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键 Ctrl+Shift+P），打开命令面板。 在命令面板中，输入 Configure Display Language，选择 Install additional languages，然后安装插件 Chinese (Simplified) Language Pack for Visual Studio Code 即可。 或者，我们可以直接安装插件 Chinese (Simplified) Language Pack for Visual Studio Code，是一样的。 安装完成后，重启 VS Code。 2、设置字体大小在命令面板输入“字体”，可以进行字体的设置，效果如下： 当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。 3、快捷键设置在命令面板输入“快捷键”，就可以进入快捷键的设置。 4、大小写转换选中文本后，在命令面板中输入 transfrom，就可以修改文本的大小写了。 5、使用命令行启动 VS Code（1）输入快捷键「Cmd + Shift + P 」，选择 install code command： （2）使用命令行： code 命令：启动 VS Code 软件 code pathName/fileName 命令：通过 VS Code 软件打开指定目录&#x2F;指定文件。 五、私人订制：VS Code 的常见配置在修改 VS Code 配置之前，我们需要知道，在哪里可以找到配置项的入口。 方式 1：Mac 用户选择菜单栏「Code–&gt; 首选项–&gt;设置」，即可打开配置项： 方式 2：点击软件右下角的设置图标： 1、修改颜色主题选择菜单栏「Code –&gt; 首选项 –&gt; 颜色主题」： 在弹出的对话框中，挑选你一个你喜欢的的颜色主题吧： 2、面包屑（Breadcrumb）打开 VS Code 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示： 上图中，将红框部分打钩即可。 设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示： 有了这个面包屑导航，我们可以点击它，在任意目录、任意文件之间随意跳转。 4、是否显示代码的行号VS Code 默认显示代码的行号。你可以在设置项里搜索 editor.lineNumbers 修改设置，配置项如下： 我建议保留这个设置项，无需修改。 5、右侧是否显示代码的缩略图VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 editor.minimap 进行设置，配置项如下： 6、将当前行代码高亮显示（更改光标所在行的背景色）当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想高亮显示当前行的代码，需要设置两步： （1）在设置项里搜索 editor.renderLineHighlight，将选项值设置为 all 或者 line。 （2）在设置项里增加如下内容： 1\"workbench.colorCustomizations\": &#123; \"editor.lineHighlightBackground\": \"#00000090\", \"editor.lineHighlightBorder\": \"#ffffff30\" &#125; 上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。 7、改完代码后立即自动保存方式一： 改完代码后，默认不会自动保存。你可以在设置项里搜索 files.autoSave，修改配置项如下： 上图中，我们将配置项修改为 onFocusChange 之后，那么，当光标离开该文件后，这个文件就会自动保存了。非常方便。 方式二： 当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。 8、保存代码后，是否立即格式化保存代码后，默认不会立即进行代码的格式化。你可以在设置项里搜索 editor.formatOnSave 查看该配置项： 我觉得这个配置项保持默认就好，不用打钩。 9、空格 or 制表符VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。 常见的设置项如下： editor. DetectIndentation：自动检测（默认开启）。截图如下： editor. InsertSpaces：按 Tab 键时插入空格（默认）。截图如下： editor. TabSize：一个制表符默认等于四个空格。截图如下： 10、新建文件后的默认文件类型当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。 如果你想修改默认的文件类型，可以在设置项里搜索 files.defaultLanguage，设置项如下： 上图中的红框部分，填入你期望的默认文件类型。我填的是 html 类型，你也可以填写成 javascript 或者 markdown，或者其他的语言类型。 11、删除文件时，是否弹出确认框当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索 xplorer.confirmDelete。截图如下： 我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？ 接下来，我们来讲一些更高级的配置。 12、文件对比VS Code 默认支持对比两个文件的内容。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下： VS Code 自带的对比功能并不够强大，我们可以安装插件 compareit，进行更丰富的对比。比如说，安装完插件 compareit 之后，我们可以将「当前文件」与「剪切板」里的内容进行对比： 13、查找某个函数在哪些地方被调用了比如我已经在 a.js 文件里调用了 foo() 函数。那么，如果我想知道 foo() 函数在其他文件中是否也被调用了，该怎么做呢？ 做法如下：在 a.js 文件里，选中 foo() 函数（或者将光标放置在 foo() 函数上），然后按住快捷键「Shift + F 12」，就能看到 foo() 函数在哪些地方被调用了，比较实用。 14、鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。 用鼠标单击文件的行号，可以选中当前行。 在某个行号的位置，上下移动鼠标，可以选中多行。 15、重构重构分很多种，我们来举几个例子。 命名重构： 当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F 2」键，那么，这个函数（或者变量名）出现的地方都会被修改。 方法重构： 选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。 16、在当前文件中搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里 Cmd + G（Win 用户是 F 3）：在当前文件中搜索，光标仍停留在编辑器里 另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示： 上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。 「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 editor.find.autoFindInSelection，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以自动只在这些内容里进行查找。该设置项如下图所示： 17、全局搜索在上面的快捷键列表中，我们已经知道如下快捷键： Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下： 上图中，你可以点击红框部分，展开更多的配置项。 18、Git 版本管理VS Code 自带了 Git 版本管理，如下图所示： 上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 Git 版本管理，可以先去补补课。 与此同时，我建议安装插件 GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。 19、将工作区放大&#x2F;缩小我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。 如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +&#x2F;-**」。Windows 用户是按下「ctrl +&#x2F;-」 当我们在投影仪上给别人演示代码的时候，这一招十分管用。 如果你想恢复默认的工作区大小，可以在命令面板输入 重置缩放（英文是 reset zoom） 20、创建多层子文件夹我们可以在新建文件夹的时候，如果直接输入 aa/bb/cc，比如： 那么，就可以创建多层子文件夹，效果如下： 21、.vscode 文件夹的作用为了统一团队的 vscode 配置，我们可以在项目的根目录下建立 .vscode 目录，在里面放置一些配置内容，比如： settings.json：工作空间设置、代码格式化配置、插件配置。 sftp.json：ftp 文件传输的配置。 .vscode 目录里的配置只针对当前项目范围内生效。将 .vscode 提交到代码仓库，大家统一配置时，会非常方便。 22、自带终端我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 item 2。 23、markdown 语法支持VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。 写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示： 我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。 你也可以在控制面板输入 Markdown: 打开预览，直接全屏预览 markdown 文件。 24、Emmet in VS CodeEmmet 可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。 举个例子，我们在编辑器中输入缩写代码：ul&gt;li*6 ，然后按下 Tab 键，即可得到如下代码片段： 1&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。 25、修改字体，使用「Fira Code」字体这款字体很漂亮，很适合用来写代码： 安装步骤如下： （1）进入 https://github.com/tonsky/FiraCode 网站，下载并安装「Fira Code」字体。 （2）打开 VS Code 的「设置」，搜索 font，修改相关配置为如下内容： 1\"editor.fontFamily\": \"'Fira Code',Menlo, Monaco, 'Courier New', monospace\", // 设置字体显示 \"editor.fontLigatures\": false,//控制是否启用字体连字，true启用，false不启用 上方的第二行配置，取决于个人习惯，我是直接设置为 &quot;editor.fontLigatures&quot;: null，因为我不太习惯连字。 26、代码格式化：Prettier我们可以使用 Prettier 进行代码格式化，会让代码的展示更加美观。步骤如下： （1）安装插件 Prettier。 （2）在项目的根路径下，新建文件 .prettierrc，并在文件中添加如下内容： 1&#123; \"printWidth\": 150, \"tabWidth\": 4, \"semi\": true, \"singleQuote\": true, \"trailingComma\": \"es5\", \"tslintIntegration\": true, \"insertSpaceBeforeFunctionParenthesis\": false &#125; 上面的内容，是我自己的配置，你可以参考。 更多配置，可以参考官方文档：https://prettier.io/docs/en/options.html 27、文件传输：sftp如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 sftp 这个插件，很好用。在公司会经常用到。 步骤如下： （1）安装插件 sftp。 （2）配置 sftp.json 文件。插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入 sftp:config，回车，当前工程的 .vscode 文件夹下就会自动生成一个 sftp.json 文件，我们需要在这个文件里配置的内容可以是： host：服务器的 IP 地址 username：用户名 privateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件） remotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录 ignore：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号 举例如下：(注意，其中的注释需要去掉) 1&#123; \"host\": \"192.168.xxx.xxx\", //服务器ip \"port\": 22, //端口，sftp模式是22 \"username\": \"\", //用户名 \"password\": \"\", //密码 \"protocol\": \"sftp\", //模式 \"agent\": null, \"privateKeyPath\": null, \"passphrase\": null, \"passive\": false, \"interactiveAuth\": false, \"remotePath\": \"/root/node/build/\", //服务器上的文件地址 \"context\": \"./server/build\", //本地的文件地址 \"uploadOnSave\": true, //监听保存并上传 \"syncMode\": \"update\", \"watcher\": &#123; //监听外部文件 \"files\": false, //外部文件的绝对路径 \"autoUpload\": false, \"autoDelete\": false &#125;, \"ignore\": [ //忽略项 \"**/.vscode/**\", \"**/.git/**\", \"**/.DS_Store\" ] &#125; （3）在 VS Code 的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到指定的 ftp 服务器上（也就是在上方 host 中配置的服务器 ip）。 我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。 28、设置 tab 的缩进在配置里搜索 Detect Indentation，修改为 false。参考链接：https://www.yisu.com/zixun/327399.html 六、三头六臂：VS Code 插件推荐VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。 上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。 我来列举几个常见的插件，这些插件都很实用。注意：顺序越靠前，越实用。 1、GitLens 【荐】我强烈建议你安装插件 GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。 GitLens 在 Git 管理上有很多强大的功能，比如： 将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。 查看某个 commit 的代码改动记录 查看不同的分支 可以将两个 commit 进行代码对比 甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。 打开你的 Git 仓库，未安装 GitLens 时是这样的： 安装了 GitLens 之后是这样的： 上图中，红框部分就是 GitLens 的功能，诸君可以自由发挥。 2、Git History有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。 3、Live Server 【荐】在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。 使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。 4、Chinese (Simplified) Language Pack for Visual Studio Code让软件显示为简体中文语言。 5、Bracket Pair Colorizer 2：突出显示成对的括号【荐】Bracket Pair Colorizer 2 插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称彩虹括号。 另外，还有个 Rainbow Brackets 插件，也可以突出显示成对的括号。 6、sftp：文件传输 【荐】如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装 sftp 这个插件，很好用。在公司会经常用到。 详细配置已经在上面讲过。 7、open in browser安装 open in browser 插件后，在 HTML 文件中「右键选择 –&gt; Open in Default Browser」，即可在浏览器中预览网页。 8、highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。 所用了这个插件之后，VS Code 自带的高亮就可以关掉了： 在用户设置里添加 &quot;editor.selectionHighlight&quot;: false 即可。 参考链接：vscode 选中后相同内容高亮插件推荐 9、vscode-iconsVscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。 10、Project Manager工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。 11、TODO Highlight写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写 TODO，而不是小写的 todo） 1//TODO:这里有个bug，我一会儿再收拾你 或者： 1//FIXME:我也不知道为啥， but it works only that way. 安装了插件 TODO Highlight 之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。 12、WakaTime 【荐】统计在 VS Code 里写代码的时间。统计效果如下： 13、Code TimeCode Time 插件：记录编程时间，统计代码行数。 安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。 备注：团长试了一下这个 code time 插件，发现统计结果不是很准。 14、Markdown Preview Github Styling 【荐】以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果： 15、Markdown Preview Enhanced预览 Markdown 样式。 Markdown All in One这个插件将帮助你更高效地在 Markdown 中编写文档。 16、Settings Sync 地址：https://github.com/shanalikhan/code-settings-sync 作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。 同步的详细操作，下一段会讲。 另外，北京时间的 2020 年 8 月 14 日，微软发布 Visual Studio Code 1.48 稳定版。此版本原生支持用户同步 VS Code 的配置，只需要登录微软账号或者 GitHub 账号即可。 17、vscode-syncing 地址：https://github.com/nonoroazoro/vscode-syncing 作用：多台设备之间，同步 VS Code 配置。 18、VeturVue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。 19、ES 7 React&#x2F;Redux&#x2F;GraphQL&#x2F;React-Native snippetsReact&#x2F;Redux&#x2F;react-router 的语法智能提示。 20、minapp：小程序支持小程序开发必备插件。 21、Prettier：代码格式化Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。 22、ESLint：代码格式校验日常开发中，建议用可以用 Prettier 做代码格式化，然后用 eslint 做校验。 23、Beautify代码格式化工具。 备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。 24、JavaScript (ES 6) code snippetsES 6 语法智能提示，支持快速输入。 25、Search node_modules 【荐】node_modules 模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 Search node_modules 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 node_modules，在弹出的选项中选择 Search node_modules，即可搜索 node_modules 里的模块。 26、indent-rainbow：突出显示代码缩进indent-rainbow 插件：突出显示代码缩进。 安装完成后，效果如下图所示： 27、javascript console utils：快速打印 log 日志【荐】安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 console.log()。简直是日志党福音。 当我们选中某个变量 name，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 console.log(name)。 其他的同类插件还有：Turbo Console Log。 不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。 编程有三等境界： 第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。 第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。 第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。 28、Code Spell Checker：单词拼写错误检查这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish. 29、Local History 【荐】维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。 30、Polacode-2020：生成代码截图 【荐】可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。 尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。 生成的效果如下： 其他同类插件：CodeSnap。我们也可以通过 https://carbon.now.sh/ 这个网站生成代码图片 有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。 31、Image Preview 【荐】图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。 32、Auto Close Tag、Auto Rename Tag自动闭合标签、自动对标签重命名。 为注释添加更醒目、带分类的色彩。 34、CSS Peek增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。 35、Vue CSS PeekCSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。 36、Color Info这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 37、RemoteHub不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。 RemoteHub 插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。 这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。 Live Share 这个神奇的插件是由微软官方出品，它的作用是：实时编码分享。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是结对编程的神器啊。 安装方式： 打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮： 上图中，点击红框部分，登录后就可以分享你的工作空间了。 39、Import Cost在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。Import Cost 插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。 Paste JSON as Code此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。 七、无缝切换：VS Code 配置云同步我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。 下面讲的两个同步方法，都可以，看你自己需要。方法 1 是 VS Code 自带的同步功能，操作简单。方法 2 需要安装插件，支持更多的自定义配置。 方法 1：使用 VS Code 自带的同步功能1、配置同步： （1）在菜单栏选择「 Code –&gt; 首选项 –&gt; 打开设置同步」： （2）选择需要同步的配置： （3）通过 Microsoft 或者 GitHub 账号登录。上图中，点击“登录并打开”，然后弹出如下界面： 上图中，使用微软账号或者 GitHub 账号登录： （4）同步完成后，菜单栏会显示“首先项同步已打开”，最左侧也会多出一个同步图标，如下图所示： 2、管理同步： （1）点击菜单栏「Code –&gt; 首选项 –&gt; 设置同步已打开」，会弹出如下界面，进行相应的同步管理即可： （2）换另外一个电脑时，登录相同的账号，即可完成同步。 参考链接： VS Code 原生的配置同步功能——Settings Sync 方法 2：使用插件 settings-sync使用方法 2，我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。 1、配置同步：（将自己本地的配置云同步到 GitHub） （1）安装插件 settings-sync。 （2）安装完插件后，在插件里使用 GitHub 账号登录。 （3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。 （4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新&#x2F;上传配置」，这样就可以把最新的配置上传到 GitHub。 2、管理同步：（换另外一个电脑时，从云端同步配置到本地） （1）当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件。 （2）安装完插件后，在插件里使用 GitHub 账号登录。 （3）登录之后，插件的界面上，会自动出现之前的同步记录： 上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地： 如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。 使用其他人的配置： 如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下： （1）安装插件 settings-sync。 （2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」 （3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。 八、常见主题插件给你的 VS Code 换个皮肤吧，免费的那种。 Dracula Theme Material Theme Nebula Theme One Dark Pro One Monokai Theme Monokai Pro Ayu Snazzy Plus Dainty SynthWave &#39;84 GitHub Plus Theme：白色主题 Horizon Theme：红色主题 最后一段如果你还有什么推荐的 VS Code 插件，欢迎留言。 大家完全不用担心这篇文章会过时，随着 VS Code 的版本更新和插件更新，本文也会随之更新。关于 VS Code 内容的后续更新，你可以关注我在 GitHub 上的前端入门项目，项目地址是： https://github.com/qianguyihao/Web 一个超级详细和真诚的前端入门项目。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","categories":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://liangyuanzheng.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"note","slug":"note","permalink":"https://liangyuanzheng.com/tags/note/"},{"name":"TODO","slug":"todo","permalink":"https://liangyuanzheng.com/tags/todo/"},{"name":"收藏","slug":"收藏","permalink":"https://liangyuanzheng.com/tags/%E6%94%B6%E8%97%8F/"}]},{"title":"换电脑了hexo博客怎么办？","slug":"换电脑了hexo博客怎么办？","date":"2017-04-23T03:48:24.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"换电脑了hexo博客怎么办？.html","link":"","permalink":"https://liangyuanzheng.com/%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86hexo%E5%8D%9A%E5%AE%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F.html","excerpt":"","text":"搭建流程 创建仓库，leunggeorge.github.io 创建两个分支：master 与 hexo； 设置 hexo 为默认分支（因为我们只需要手动管理这个分支上的 Hexo 网站文件）； 使用 git clone &#103;&#x69;&#x74;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;:LeungGeorge&#x2F;LeungGeorge.github.io.git 拷贝仓库； 在本地leunggeorge.github.io文件夹下通过 Git bash 依次执行 npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为 hexo）; 修改_config.yml 中的 deploy 参数，分支应为 master；具体如下:deploy:type: gitrepository: https://github.com/LeungGeorge/LeungGeorge.github.io.gitbranch: master 依次执行 git add .、git commit -m “…”、git push origin hexo 提交网站相关的文件； 执行 hexo g -d 生成网站并部署到 GitHub 上。这样一来，在 GitHub 上的https://leunggeorge.github.io/仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 改进流程 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。依次执行指令将改动推送到 GitHub（此时当前分支应为 hexo）；：git add .git commit -m “…”git push origin hexo 然后才执行 hexo g -d 发布网站到 master 分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 本地资料恢复流程 使用 git clone &#x67;&#105;&#x74;&#64;&#103;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;:LeungGeorge&#x2F;LeungGeorge.github.io.git 拷贝仓库（默认分支为 hexo）； 在本地新拷贝的LeungGeorge.github.io文件夹下通过 Git bash 依次执行下列指令：npm install hexonpm installnpm install hexo-deployer-git【记得，不需要 hexo init 这条指令】 常见错误处理 ERROR Deployer not found: git 参考运行以下命令即可：npm install hexo-deployer-git –save 原文地址：https://www.zhihu.com/question/21193762 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://liangyuanzheng.com/tags/hexo/"},{"name":"迁移","slug":"迁移","permalink":"https://liangyuanzheng.com/tags/%E8%BF%81%E7%A7%BB/"}]},{"title":"ubuntu LNMP Mac","slug":"ubuntu-LNMP-Mac","date":"2016-09-12T13:14:24.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"ubuntu-LNMP-Mac.html","link":"","permalink":"https://liangyuanzheng.com/ubuntu-LNMP-Mac.html","excerpt":"","text":"安装 homebrew安装 Nginx安装 12brew search nginxbrew install nginx 启动、关闭 nginx 1nginx -s reload|reopen|stop|quit 配置 1234cd /usr/local/etc/nginx/mkdir conf.dvim nginx.confvim ./conf.d/default.conf nginx.conf 内容 1234567891011121314151617181920212223242526272829worker_processes 1;error_log /usr/local/var/log/nginx/error.log warn;pid /usr/local/var/run/nginx.pid;events &#123; #worker_connections 1024; worker_connections 256;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /usr/local/var/log/nginx/access.log main; port_in_redirect off; sendfile on; keepalive_timeout 65; include /usr/local/etc/nginx/conf.d/*.conf; include servers/*;&#125; default.conf 文件内容 1234567891011121314151617181920212223server &#123; listen 80; server_name localhost; # root /usr/local/var/www/ # /usr/local/var/www/ # root /Users/username/Sites/; # 该项要修改为你准备存放相关网页的路径 root /usr/local/var/; # 该项要修改为你准备存放相关网页的路径 location / &#123; index index.php; autoindex on; &#125; #proxy the php scripts to php-fpm location ~ \\.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; include fastcgi_params; &#125;&#125; 安装 MYSQL测试Nginx 配置文件 root 对应目录下新建 index.php 123&lt;? phpinfo();?&gt; 安装 php参考资料Mac 下安装 LNMP(Nginx+PHP5.6)环境Mac OSX 10.9 搭建 nginx+mysql+php-fpm 环境 来源：http://leunggeorge.github.io/","categories":[{"name":"linux","slug":"linux","permalink":"https://liangyuanzheng.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://liangyuanzheng.com/tags/linux/"},{"name":"lnmp","slug":"lnmp","permalink":"https://liangyuanzheng.com/tags/lnmp/"},{"name":"nginx","slug":"nginx","permalink":"https://liangyuanzheng.com/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"https://liangyuanzheng.com/tags/mysql/"},{"name":"php","slug":"php","permalink":"https://liangyuanzheng.com/tags/php/"}]},{"title":"linux 查看磁盘空间","slug":"linux-查看磁盘空间","date":"2016-09-10T07:35:24.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"linux-查看磁盘空间.html","link":"","permalink":"https://liangyuanzheng.com/linux-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4.html","excerpt":"","text":"df查看磁盘空间1234➜ df -hlFilesystem Size Used Avail Capacity iused ifree %iused Mounted on/dev/disk0s2 112Gi 101Gi 11Gi 90% 26473262 2939106 90% /localhost:/Zp5mvtzEO2n01q 112Gi 112Gi 0Bi 100% 0 0 100% /Volumes/MobileBackups 查看文件夹空间12➜ du -sh 61M . 查看当前目录下的各个目录、文件大小： 123456789101112131415161718192021222324➜ for i in $(ls -l |grep '^d' |du -s * |sort -nr|awk '&#123;print $2&#125;');do du -sh $i;done 15M 19550429.tar.gz 14M 19550994.tar.gz 14M 19550453.tar.gz5.6M 19550447.tar.gz3.9M 19550606.tar.gz3.0M 19550597.tar.gz1.5M 19553761.tar.gz956K 19562246.tar.gz632K 19585906.tar.gz552K 19610713.tar.gz396K 19587600.tar.gz388K 19616004.tar.gz332K 19568604.tar.gz320K 19551176.tar.gz196K 19567582.tar.gz184K 19561990.tar.gz112K 19562533.tar.gz 76K 19556528.tar.gz 72K 19595169.tar.gz 68K 19609459.tar.gz 16K 19724913.tar.gz4.0K run.sh4.0K 19585960.tar.gz 来源：http://leunggeorge.github.io/","categories":[{"name":"linux","slug":"linux","permalink":"https://liangyuanzheng.com/categories/linux/"}],"tags":[{"name":"磁盘空间","slug":"磁盘空间","permalink":"https://liangyuanzheng.com/tags/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/"}]},{"title":"markdown-Marxico","slug":"markdown-Marxico","date":"2016-08-28T15:01:41.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"markdown-Marxico.html","link":"","permalink":"https://liangyuanzheng.com/markdown-Marxico.html","excerpt":"","text":"Welcome to Marxico@(Sample notebook)[Marxico|Manual|Markdown] Marxico is a delicate Markdown editor for Evernote. With reliable storage and sync powered by Evernote, Marxico offers greate writing experience. Versatile - supporting code highlight, LaTeX &amp; flow charts, inserting images &amp; attachments by all means. Exquisite - neat but powerful editor, featuring offline docs, live preview, and offering the desktop client and offline Chrome App. Sophisticated - deeply integrated with Evernote, supporting notebook &amp; tags, two-way bind editing. [TOC] Introducing Markdown Markdown is a plain text formatting syntax designed to be converted to HTML. Markdown is popularly used as format for readme files, … or in text editors for the quick creation of rich text documents. - Wikipedia As showed in this manual, it uses hash(#) to identify headings, emphasizes some text to be bold or italic. You can insert a link , or a footnote[^demo]. Serveral advanced syntax are listed below, please press Ctrl + / to view Markdown cheatsheet. Code block12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX expression$$ x &#x3D; \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ Table Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 DiagramsFlow charts12345678st&#x3D;&gt;start: Starte&#x3D;&gt;endop&#x3D;&gt;operation: My Operationcond&#x3D;&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op Sequence diagrams123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! Note: You can find more information: about Sequence diagrams syntax here, about Flow charts syntax here. CheckboxYou can use - [ ] and - [x] to create checkboxes, for example: Item1 Item2 Item3 Note: Currently it is only partially supported. You can’t toggle checkboxes in Evernote. You can only modify the Markdown in Marxico to do that. Next version will fix this. Dancing with EvernoteNotebook &amp; TagsMarxico add @(Notebook)[tag1|tag2|tag3] syntax to select notebook and set tags for the note. After typing @(, the notebook list would appear, please select one from it. TitleMarxico would adopt the first heading encountered as the note title. For example, in this manual the first line Welcome to Marxico is the title. Quick EditingNote saved by Marxico in Evernote would have a red ribbon button on the top-right corner. Click it and it would bring you back to Marxico to edit the note. Note: Currently Marxico is unable to detect and merge any modifications in Evernote by user. Please go back to Marxico to edit. Data SynchronizationWhile saving rich HTML content in Evernote, Marxico puts the Markdown text in a hidden area of the note, which makes it possible to get the original text in Marxico and edit it again. This is a really brilliant design because: it is beyond just one-way exporting HTML which other services do; and it avoids privacy and security problems caused by storing content in a intermediate server. Privacy Statement: All of your notes data are saved in Evernote. Marxico doesn’t save any of them. Offline StorageMarxico stores your unsynchronized content locally in browser storage, so no worries about network and broswer crash. It also keeps the recent file list you’ve edited in Document Management(Ctrl + O). Note: Although browser storage is reliable in the most time, Evernote is born to do that. So please sync the document regularly while writing. ShortcutsHelp Ctrl + /Sync Doc Ctrl + SCreate Doc Ctrl + Alt + NMaximize Editor Ctrl + EnterPreview Doc Ctrl + Alt + EnterDoc Management Ctrl + OMenu Ctrl + M Bold Ctrl + BInsert Image Ctrl + GInsert Link Ctrl + LConvert Heading Ctrl + H About ProMarixo offers a free trial of 10 days. After that, you need to purchase the Pro service. Otherwise, you would not be able to sync new notes. Previous notes can be edited and synced all the time. CreditsMarxico was first built upon Dillinger, and the newest version is almost based on the awesome StackEdit. Acknowledgments to them and other incredible open source projects! Feedback &amp; Bug Report Twitter: @gock2 Email: &#104;&#x75;&#x73;&#116;&#103;&#111;&#x63;&#107;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d; Thank you for reading this manual. Now please press Ctrl + M and click Link with Evernote. Enjoy your Marxico journey! [^demo]: This is a demo footnote. Read the MultiMarkdown Syntax Guide to learn more. Note that Evernote disables ID attributes in its notes , so footnote and TOC are not actually working.","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://liangyuanzheng.com/tags/markdown/"}]},{"title":"markdownMou","slug":"markdown-Mou","date":"2016-08-28T15:01:17.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"markdown-Mou.html","link":"","permalink":"https://liangyuanzheng.com/markdown-Mou.html","excerpt":"","text":"Mou OverviewMou, the missing Markdown editor for web developers. SyntaxStrong and Emphasizestrong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and EmailAn email &#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#46;&#99;&#x6f;&#x6d; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. ImagesAn inline image , title is optional. A reference style image. Inline code and Block codeInline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered ListsOrdered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered ListsUnordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. Horizontal RulesThree or more asterisks or dashes: HeadersSetext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6Extra SyntaxFootnotesFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[^1] [^1]: And that’s the footnote. StrikethroughWrap with 2 tilde characters: Strikethrough Fenced Code BlocksStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. TablesA simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right ShortcutsView Toggle live preview: Shift + Cmd + I Toggle Words Counter: Shift + Cmd + W Toggle Transparent: Shift + Cmd + T Toggle Floating: Shift + Cmd + F Left&#x2F;Right &#x3D; 1&#x2F;1: Cmd + 0 Left&#x2F;Right &#x3D; 3&#x2F;1: Cmd + + Left&#x2F;Right &#x3D; 1&#x2F;3: Cmd + - Toggle Writing orientation: Cmd + L Toggle fullscreen: Control + Cmd + F Actions Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + &#x2F; Hard Linebreak: Control + Return Edit Auto complete current word: Esc Find: Cmd + F Close find bar: Esc Post Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T Export Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P And more?Don’t forget to check Preferences, lots of useful options are there. Follow @Mou on Twitter for the latest news. For feedback, use the menu Help - Send Feedback","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://liangyuanzheng.com/tags/markdown/"}]},{"title":"Charles4.0 crack","slug":"tool-Charles4-0-crack","date":"2016-08-22T16:00:00.000Z","updated":"2025-10-27T00:35:41.788Z","comments":true,"path":"tool-Charles4-0-crack.html","link":"","permalink":"https://liangyuanzheng.com/tool-Charles4-0-crack.html","excerpt":"","text":"Charles4.0 最新版破解Charles4.0 最新版破解 来源：http://leunggeorge.github.io/","categories":[{"name":"工具","slug":"工具","permalink":"https://liangyuanzheng.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://liangyuanzheng.com/tags/blog/"},{"name":"charles","slug":"charles","permalink":"https://liangyuanzheng.com/tags/charles/"}]}]}