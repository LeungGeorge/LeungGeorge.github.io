---
uuid: 7dd12190-e8d0-11e9-bf61-fb81afac94ab
title: gcache 源码分析
tags:
  - gcache
  - Golang
  - 源码分析
categories:
  - golang
comments: false
date: 2019-10-07 15:02:57
description: 首先介绍 FIFO 、LRU、LFU 三种缓存算法的特征、区别。喝杯咖啡，然后开始 gcache 的源码分析。
---

<!-- TODO 缓存算法 + gcache 的源码分析 -->
<!--more-->

## 缓存算法

### FIFO
FIFO（First In First Out）是一种先进先出的调度算法（队列）。

基本思想：
> 最先进入的数据，在将来被访问的可能性较小。当空间满时，优先淘汰最先进入的数据。

实现（哈希表 + 双向链表）：
> 维护一个长度为 `L` 的链表 `evictList` 存储已访问的数据（数据队列）。  
> 不断将新的数据项 `item` 放到链表首部，当 `evictList` 长度大于 `L` 时，移除 `evictList` 尾部数据项；  
> 访问某个 `item` 时，不改变其在 `evictList` 的排名。

缺点：
> 判断一个页面置换算法优劣的指标就是缺页率，而 `FIFO` 算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为 `Belady` 现象。产生 `Belady` 现象现象的原因是，`FIFO` 置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此 `FIFO` 算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，`FIFO` 算法的使用场景较少。

### LRU

LRU（Least Recently Used）是一种最近最久未使用调度算法。

基本思想：
> 最近访问的数据，在将来被访问的可能性更大（换言之，如果一个数据在一段时间内没有被访问，那么未来被访问的可能性也很小）。当空间满时，优先淘汰最久没有被访问的数据。

实现（哈希表 + 双向链表）：
> 维护一个长度为 `L` 的链表 `evictList` 存储已访问的数据。  
> 不断将新的数据项 `item` 放到链表首部，当 `evictList` 长度大于 `L` 时，移除 `evictList` 尾部数据项；  
> 访问某个 `item` 时，改变其在 `evictList` 的排名，将 `item` 移至首部。

### LFU

LRU（Least Frequency Used）是一种最近最少使用调度算法。

基本思想：
> 访问频次较小的数据，在将来被访问的可能性更小。当空间满时，优先淘汰访问频次较小的数据。

实现（哈希表 + 双向链表 [频次 + 哈希表] ）：
> 维护一个长度为 `L` 的链表 `freqList` 存储频次和数据。  
> 不断将新的数据项 `item` 放到链表（0 频次节点）哈希表，当 `freqList` 长度大于 `L` 时，移除 `freqList` 首部节点哈希表中数据；  
> 访问某个 `item` 时，改变其在 `freqList` 的位置（将 `item` 频次 `+1` 并移至下一个频次节点对应的哈希表）。

### OPT

OPT（OPTimal replacement）是一种理论上最佳的页面置换算法。

基本思想：
> 淘汰以后永远用不到的数据项；如果没有，则淘汰最久以后再用到的数据项。  
> 属于理想型算法，不可能实现（因为无法知道全局的访问序列）。但是，可以最为评价其他算法优劣的参考标准。

## gcache 源码分析

gcache 是基于 Golang 实现的一个内存级 Cache 基础库。支持带失效时间的 Cache，目前包括 LFU（Least Frequency Used），LRU（Least Recently Used），ARC（Adaptive Replacement Cache）三种缓存策略。

- Goroutine 安全
- 支持驱逐，清除和添加条目的事件处理程序。（可选）
- 如果缓存不存在，则自动加载缓存。（可选）
- 支持计数

### Source code and API 
> [官方代码](https://github.com/bluele/gcache)  
> [注解版代码](https://github.com/LeungGeorge/gcache)  
> [godoc 文档](https://godoc.org/github.com/bluele/gcache)

### CacheBuilder

构造缓存对象，以及各种个性化化配置、策略。[cache.go](https://github.com/LeungGeorge/gcache/blob/master/cache.go) 中有详细注解。

```go
type (
	LoaderFunc       func(interface{}) (interface{}, error)
	LoaderExpireFunc func(interface{}) (interface{}, *time.Duration, error)
	EvictedFunc      func(interface{}, interface{})
	PurgeVisitorFunc func(interface{}, interface{})
	AddedFunc        func(interface{}, interface{})
	DeserializeFunc  func(interface{}, interface{}) (interface{}, error)
	SerializeFunc    func(interface{}, interface{}) (interface{}, error)
)

// CacheBuilder 构造缓存对象，以及各种个性化化配置、策略。
type CacheBuilder struct {
	clock            Clock            // cache 时钟
	tp               string           // 缓存类型：TYPE_SIMPLE，TYPE_LRU，TYPE_LFU，TYPE_ARC
	size             int              // 缓存大小
	loaderExpireFunc LoaderExpireFunc // key 过期时的回调函数
	evictedFunc      EvictedFunc      // 淘汰 key 时的回调函数
	purgeVisitorFunc PurgeVisitorFunc // 清空缓存所有 key 时的回调函数
	addedFunc        AddedFunc        // 新增 key 时的回调函数
	expiration       *time.Duration   // 失效时间
	deserializeFunc  DeserializeFunc  // 序列化回调函数
	serializeFunc    SerializeFunc    // 反序列化回调函数
}
```

### Cache 接口

```go
// Cache 接口
type Cache interface {
	Set(key, value interface{}) error
	SetWithExpire(key, value interface{}, expiration time.Duration) error
	Get(key interface{}) (interface{}, error)
	GetIFPresent(key interface{}) (interface{}, error)
	GetALL(checkExpired bool) map[interface{}]interface{}
	get(key interface{}, onLoad bool) (interface{}, error)
	Remove(key interface{}) bool
	Purge()
	Keys(checkExpired bool) []interface{}
	Len(checkExpired bool) int
	Has(key interface{}) bool

	statsAccessor
}
```


> 引用  
> [操作系统之页面置换算法](https://www.cnblogs.com/fkissx/p/4712959.html)  
> [谈谈缓存和基本的缓存算法](https://www.ezlippi.com/blog/2015/02/cache.html)  
> [缓存算法（FIFO 、LRU、LFU三种算法的区别）](https://www.cnblogs.com/hongdada/p/10406902.html)  
> [Go gcache 源码分析（图解）](https://segmentfault.com/a/1190000020002827?utm_source=tag-newest)


---
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css">
<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
<script>
hljs.tabReplace = ' ';
hljs.initHighlightingOnLoad();
</script>

> 来源：[https://leunggeorge.github.io/](https://leunggeorge.github.io/)  
