---
title: 推荐系统初探
tags:
  - writting
  - 推荐系统
categories:
  - essay
comments: false
description:  
date: 2017-07-17 18:15:32
---

**推荐算法通常被分为四大类（1-4）：**  
详见参考资料2，病分析的各个算法的优缺点。  

+ 协同过滤推荐算法
+ 基于内容的推荐算法
+ 混合推荐算法
+ 流行度推荐算法

# 推荐系统算法综述
推荐系统在各种系统中广泛使用，推荐算法则是其中最核心的技术点， 为推荐系统选择正确的推荐算法是非常重要的决定。每一种推荐算法都有其优点和缺点，当然也有其限制条件，在作出决定之前，必须要一一考量。在实践中，你可能会测试几种算法，以发现哪一种最适合你的用户，测试中你也会直观地发现它们是什么以及它们的工作原理。
InfoQ策划了系列文章来为读者深入介绍。推荐算法综述分为五个部分，本文作为第一篇，主要介绍了推荐算法的主要类型。第二篇涵盖了不同类型的协同过滤算法，突出他们之间的一些细微差别。之后的三篇会陆续发表出来。第三篇详细介绍了基于内容的过滤算法。第四篇主要介绍了混合引荐技术和基于流行度的推荐方法。第五篇，在回顾了所有基本的推荐算法之后，介绍了如何选择最合适的推荐算法。这一系列的作者是Maya Hristakeva和Kris Jack，英国的数据科学家，具有丰富的构建推荐系统的经验，他们共同为世界创建出了一些出色的推荐系统。  

> 系列文章：  
>[推荐算法综述（一）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)   
>[推荐算法综述（二）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02)  
>[推荐算法综述（三）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03)   
>[推荐算法综述（四）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04)  
>[推荐算法综述（五）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05)    



# 协同过滤
协同过滤（CF）推荐算法通过在用户活动中寻找特定模式来为用户产生有效推荐。它依赖于系统中用户的惯用数据，例如通过用户对其阅读过书籍的评价可以推断出用户的阅读偏好。这种算法的核心思想就是：如果两个用户对于一些项的评分相似程度较高，那么一个用户对于一个新项的评分很有可能类似于另一个用户。值得注意的是，他们推荐的时候不依赖于项的任何附加信息（例如描述、元数据等等）或者用户的任何附加信息（例如喜好、人口统计相关数据等等）。  
CF的方法大体可分为两类：分别为**邻域**和**基于模型**的方法。邻域方法（即基于内存的CF）是使用用户对已有项的评分直接预测该用户对新项的评分。与之相反，基于模型的方法是使用历史评分数据，基于学习出的预测模型，预测对新项的评分。通常的方式是使用机器学习算法，找出用户与项的相互作用模型，从而找出数据中的特定模式。

* 基于用户的协同过滤，是以用户为中间跳板来推荐内容的
* 基于项的协同过滤，基于项（如书籍、商品），即基于item

邻域方法由于其简单性和效率具有相当的知名度，同时也是由于它们有产生准确的和个性化的推荐的能力。然而，它们也有一些可扩展性的限制，因为在用户数量和项的数量增长的情况下，它们需要一个相似度的计算（基于用户或项）。在最坏的情况下，这种计算的时间复杂度可能是O(m*n)，但在实践中的情况稍微好一点O(m+n)，部分原因是由于利用了数据的稀疏度。虽然稀疏有助于可扩展性，它也对基于邻域的方法提出了一个挑战，因为我们的用户仅仅对庞大数量项中的很少一部分进行了评分。例如，在Mendeley，我们有数以百万计的文章而一个用户可能只读了其中几百篇文章。两个读过100篇文章的用户有一篇相同文章的概率（共5000万篇文章）是0.0002。

基于模型的方法可以帮助克服一些基于邻域的方法的局限性。它不像基于邻域的方法，使用用户项评分直接预测新的项。基于模型的方法会在使用评分去学习预测模型的基础上，去预测新项。一般的想法是使用机器学习算法建立用户和项的相互作用模型，从而找出数据中的模式。在一般情况下，基于模型的CF被认为是建立CF推荐系统的更先进的算法。有许多不同的算法可用于构建模型并基于这些模型进行预测，例如，贝叶斯网络、聚类、分类、回归、矩阵分解、受限玻尔兹曼机等等。这些技术在为了最终赢得Netflix奖的解决方案中扮演了关键角色。Netflix发起了一个竞赛，从2006年到2009年提供一百万美元奖金，颁发给产生的推荐比他们自己的推荐系统精确10%以上的推荐系统团队。成功获奖的解决方案是Netflix研发的一个集成（即混合）了超过100种算法模型，这些算法模型都采用了矩阵分解和受限玻尔兹曼机。

矩阵因子分解（如奇异值分解，奇异值分解+ +）将项和用户都转化成了相同的潜在空间，它所代表了用户和项之间的潜相互作用（图8）。矩阵分解背后的原理是潜在特征代表了用户如何给项进行评分。给定用户和项的潜在描述，我们可以预测用户将会给还未评价的项多少评分。


CF倾向于推荐流行的项，很难推荐给有独特口味的人（即感兴趣的项并没有产生足够多的惯用数据）。这被称为流行性偏见，它通常是用基于内容的过滤方法。CF方法的一个更重要的限制是我们所称的“冷启动问题”，系统是不能够给没有（或非常少）惯用活动的用户进行推荐，又名曰新用户问题，或推荐新项问题。新用户的“冷启动问题”可以通过**流行性**和**混合方法**进行解决，而新项问题可以通过使用基于内容的过滤或multi-armed bandits（即探索利用）进行解决。我们将在下一篇文章中讨论上述方法中的一些方法。


基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但**它们所不同的是如何计算用户的相似度**，**基于人口统计学的机制只考虑用户本身的特征**，而**基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度**，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。


论文作者们试图建立满足如下性质的robust推荐算法：  
1. 算法容易实现和维护  
2. 对新的评分应该立即给予响应  
3. 查询速度要快（虽然可能以牺牲存储量为代价）  
4. 对新的用户也要能给出有效的推荐  
5. 精度上要有竞争力  

提出了三个算法:  
1. Slope One  
2. Weighted Slope One(针对不同的评价的情况，可以加权)  
3. Bi-Polar Slope One  

> 引自
> [推荐算法之 Slope One 算法](http://www.cnblogs.com/breezedeus/archive/2011/03/11/1981781.html)  


【评分】
> [SlopeOne 算法，未知项评分预测](http://www.cnblogs.com/huangxincheng/archive/2012/11/22/2782647.html),采用均值化的思想预测用户未知项的评分  
> [Slope One Predictors for Online Rating-Based Collaborative Filtering](http://soselab.cs.ntou.edu.tw/wp-content/uploads/2016/08/04.pdf)  



评分矩阵U（形式如上图）可被分解为两个矩阵相乘
> 引自  
> [推荐系统之矩阵分解](http://www.bubuko.com/infodetail-822464.html)  



http://muricoca.github.io/crab/


[推荐算法之 slope one 算法-CSDN](http://blog.csdn.net/xidianliutingting/article/details/51916578)  
[推荐算法之 Slope One 算法-博客园](http://www.cnblogs.com/breezedeus/archive/2011/03/11/1981781.html)  
[经典算法题每日演练——第六题 协同推荐SlopeOne 算法](http://www.cnblogs.com/huangxincheng/archive/2012/11/22/2782647.html)  
[使用SVD++进行协同过滤(算法原理部分主要引用自他人)-布布扣-bubu----](https://www.baidu.com/link?url=Ui4bNxhMd7u9o4dcW2dzty0ycRpGU_NfmvsZ4f7suTkircfCO7_iS_bTWh9xEFXC7CkdlGau7H-2OOK7DixlA_&wd=&eqid=e56f8b2a0003f17100000002596f820c)

>【参考资料】  
>[推荐系统的常用算法概述](http://www.cnblogs.com/luchen927/archive/2012/02/04/2334316.html)  
>[推荐算法综述（一）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)  
>[从算法到案例：推荐系统必读的10篇精选技术文章](http://www.infoq.com/cn/news/2015/12/Algorithm-case-10)  
> [机器学习相关——协同过滤](http://www.cnblogs.com/luchen927/archive/2012/02/01/2325360.html)  
>[推荐引擎初探](https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html)


---
# 推荐系统分类
## 基于人口统计学的推荐
基于人口统计学的推荐（Demographic-based Recommendation）易于实现的推荐方法，它根据系统用户的基本信息发现用户的相似度，然后将相似用户喜爱的其他物品推荐给当前用户。  
工作原理图：  
![image](基于人口统计学的推荐原理.jpg)   
系统对每个根据每个用户的基本信息，计算用户的相似度。比如系统通过计算发现用户A和C比较相似。就会把A喜欢的物品推荐给C。

## 基于内容的推荐
工作原理图：  
![image](基于内容的推荐原理.jpg)  
如图给出的一个电影推荐系统，首先对电影的元数据建模，然后计算电影间的相似度。如 A 和 C 会被认为是相似的电影。最后实现推荐，我们可以给用户A推荐类似于电影A的电影C。

## 基于协同过滤的推荐
基于用户的协同过滤——基于人口统计学的推荐

　　基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基 于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户 可能有相同或者相似的口味和偏好。

　　基于物品的协同过滤——基于内容的推荐

　　基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息。
　　
### 基于用户的协同过滤推荐
**基本假设：**喜欢类似物品的用户，可能有相似的口味和偏好  
**主要步骤：**  
（1）找出和目标用户兴趣相似的用户集合  
（2）找到用户集合中A的同类用户喜欢的，A没有接触的物品推荐给A  
**相似度计算：**   
（1）Jaccard公式  
![image](jaccard公式.png)  
（2）余弦相似度  
![image](余弦相似度.png)   
其中，N(u),N(v)分别代表用户u，v的兴趣集合。  
**用户行为记录表：**  
![image](用户行为记录表.png)   
如图，用户A对物品{a, b, d}有过行为，用户B对物品{a, c}有过行为，利用余弦相似度公式计算用户A和用户B的兴趣相似度为:  
![image](用户A和用户B的相似度.png) 
**用户相似度矩阵：**

||A|B|C|D|
|:--|:--|
|A|1|1/&radic;6|1/&radic;6|1/3|
|B|1/&radic;6|1|0|1/&radic;6|
|C|1/&radic;6|0|1|1/&radic;6|
|D|1/3|1/&radic;6|1/&radic;6|1|

**改进型用户相似度计算**  
![image](改进型用户相似度计算.png)  
该方法通过 1/log(<sub>2</sub>1+|N(i)|) 惩罚了用户u，v共同新区列表中热门物品对他们相似度的影响。  
**用户对物品感兴趣程度公式：**  
![image](用户对物品的感兴趣程度.png)  
其中，w<sub>uv</sub>是用户u、v的相似度，r<sub>vi</sub>代表用户对物品的兴趣（此处取1）。  
**推荐列表（假设推荐用户数取3）：**  
与A相似的用户为B、C，筛选B、C感兴趣的物品并且A为关注的，那么A对物品c、e的兴趣为：  
p(A,c)=w<sub>AB</sub>+w<sub>CD</sub>=0.7416  
p(A,e)=w<sub>AC</sub>+w<sub>CD</sub>=0.7416  




基于人口统计学的推荐和基于用户的协同过滤推荐都是计算用户的相似度，但二者在相似度的计算上有所不同，前者只考虑用户本身的特征，后者会在用户的历史偏好数据上计算用户相似度。

### 基于项目的协同过滤推荐
**主要步骤：**  
（1）计算物品之间的相似度  
（2）根据物品的相似度和用户的历史行为给用户生成推荐列表  
**相似度计算：**  
![image](基于内容的相似度计算公式.png)  
**相似度矩阵：**  
![image](基于内容的相似度矩阵.png)   
推荐结果的算法类似于【基于用户的协同过滤推荐】，略之。

基于内容的推荐和基于项目的协同过滤推荐同样都是基于物品相似度进行推荐，只是相似度计算的方法不一样，前者是是基于物品本身的属性特征信息，而后者会从用户历史的偏好推断。  

### 协同过滤总结
**UserCF、ItemCF比较：**  
UserCF算法侧重于挖掘有共同兴趣的人喜欢的物品，ItemCF算法侧重于挖掘用户曾经喜欢过的类似的物品。  
UserCF侧重反应用户兴趣相似的群体热点，更加社会化；  
ItemCF侧重维系用户的历史性趣，更加个性化；

||UserCF|ItemCF|
|:--|:--|:--|
|性能|适用于用户较少的场合,如果用户很多,计算用户相似度矩阵代价很大|适用于物品数明显小于用户数的场合,如果物品 很多(网页),计算物品相似度矩阵代价很大|
|领域|时效性较强,用户个性化兴趣不太明显的领域|长尾物品丰富,用户个性化需求强烈的领域|
|实时性|用户有新行为,不一定造成推荐结果的立即变化|用户有新行为，一定会导致推荐结果的实时变化|
|冷启动|在新用户对很少的物品产生行为后,不能立即对他 进行个性化推荐,因为用户相似度表是每隔一段时间离线计算的;新物品上线后一段时间,一旦有用户对物品产生行为,就可以将新物品推荐给和对它产生行为的用户 兴趣相似的其他用户|新用户只要对一个物品产生行为,就可以给他推荐和该物品相关的其他物品;但没有办法在不离线更新物品相似度表的情况下将新物品推荐给用户|
|推荐理由|很难提供令用户信服的推荐解释|利用用户的历史行为给用户做推荐解释,可以令用户比较信服|

**优势：**  
a 它不需要对物品或用户进行严格建模，不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。    
b 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好。  
**不足：**  
a 方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。  
b 推荐的效果依赖于用户历史偏好数据的多少和准确性。
c 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。  
d 对于一些特殊品味的用户不能给予很好的推荐。  
e 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。

## 混合的推荐机制

在现行的 Web 站点上的推荐往往都不是单纯只采用了某一种推荐的机制和策略，他们往往是将多个方法混合在一起，从而达到更好的推荐效果。关于如何组合各个推荐机制，这里讲几种比较流行的组合方法。

*  加权的混合（Weighted Hybridization）: 用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最好的推荐效果。
*  切换的混合（Switching Hybridization）：前面也讲到，其实对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，那么切换的混合方式，就是允许在不同的情况下，选择最为合适的推荐机制计算推荐。
*  分区的混合（Mixed Hybridization）：采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户。其实，Amazon，当当网等很多电子商务网站都是采用这样的方式，用户可以得到很全面的推荐，也更容易找到他们想要的东西。
*  分层的混合（Meta-Level Hybridization）: 采用多种推荐机制，并将一个推荐机制的结果作为另一个的输入，从而综合各个推荐机制的优缺点，得到更加准确的推荐。

# 推荐引擎的应用
## 豆瓣电影(完善豆瓣使用体验)
https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html

豆瓣是国内做的比较成功的社交网站，它以图书，电影，音乐和同城活动为中心，形成一个多元化的社交网络平台。  
豆瓣电影推荐：
![image](豆瓣热门电影.png)  



# 推荐算法
## 数据完善
+ Slope One，补充未知用户数据

# 站内应用
派站内，可在个人页推出相关用户推荐（类似于相关问题）。








> 引用



---
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css">
<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
<script>
hljs.tabReplace = ' ';
hljs.initHighlightingOnLoad();
</script>


来源：[http://leunggeorge.github.io/](http://leunggeorge.github.io/)  
