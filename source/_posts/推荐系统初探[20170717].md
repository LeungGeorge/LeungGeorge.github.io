---
title: 推荐系统初探
tags:
  - writting
  - 推荐系统
categories:
  - essay
comments: false
description:  
date: 2017-07-17 18:15:32
---

**推荐算法通常被分为四大类（1-4）：**  
详见参考资料2，病分析的各个算法的优缺点。  

+ 协同过滤推荐算法
+ 基于内容的推荐算法
+ 混合推荐算法
+ 流行度推荐算法

# 推荐系统算法综述
推荐系统在各种系统中广泛使用，推荐算法则是其中最核心的技术点， 为推荐系统选择正确的推荐算法是非常重要的决定。每一种推荐算法都有其优点和缺点，当然也有其限制条件，在作出决定之前，必须要一一考量。在实践中，你可能会测试几种算法，以发现哪一种最适合你的用户，测试中你也会直观地发现它们是什么以及它们的工作原理。
InfoQ策划了系列文章来为读者深入介绍。推荐算法综述分为五个部分，本文作为第一篇，主要介绍了推荐算法的主要类型。第二篇涵盖了不同类型的协同过滤算法，突出他们之间的一些细微差别。之后的三篇会陆续发表出来。第三篇详细介绍了基于内容的过滤算法。第四篇主要介绍了混合引荐技术和基于流行度的推荐方法。第五篇，在回顾了所有基本的推荐算法之后，介绍了如何选择最合适的推荐算法。这一系列的作者是Maya Hristakeva和Kris Jack，英国的数据科学家，具有丰富的构建推荐系统的经验，他们共同为世界创建出了一些出色的推荐系统。  

> 系列文章：  
>[推荐算法综述（一）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)   
>[推荐算法综述（二）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part02)  
>[推荐算法综述（三）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part03)   
>[推荐算法综述（四）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part04)  
>[推荐算法综述（五）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part05)    



# 协同过滤
协同过滤（CF）推荐算法通过在用户活动中寻找特定模式来为用户产生有效推荐。它依赖于系统中用户的惯用数据，例如通过用户对其阅读过书籍的评价可以推断出用户的阅读偏好。这种算法的核心思想就是：如果两个用户对于一些项的评分相似程度较高，那么一个用户对于一个新项的评分很有可能类似于另一个用户。值得注意的是，他们推荐的时候不依赖于项的任何附加信息（例如描述、元数据等等）或者用户的任何附加信息（例如喜好、人口统计相关数据等等）。  
CF的方法大体可分为两类：分别为**邻域**和**基于模型**的方法。邻域方法（即基于内存的CF）是使用用户对已有项的评分直接预测该用户对新项的评分。与之相反，基于模型的方法是使用历史评分数据，基于学习出的预测模型，预测对新项的评分。通常的方式是使用机器学习算法，找出用户与项的相互作用模型，从而找出数据中的特定模式。

* 基于用户的协同过滤，是以用户为中间跳板来推荐内容的
* 基于项的协同过滤，基于项（如书籍、商品），即基于item

邻域方法由于其简单性和效率具有相当的知名度，同时也是由于它们有产生准确的和个性化的推荐的能力。然而，它们也有一些可扩展性的限制，因为在用户数量和项的数量增长的情况下，它们需要一个相似度的计算（基于用户或项）。在最坏的情况下，这种计算的时间复杂度可能是O(m*n)，但在实践中的情况稍微好一点O(m+n)，部分原因是由于利用了数据的稀疏度。虽然稀疏有助于可扩展性，它也对基于邻域的方法提出了一个挑战，因为我们的用户仅仅对庞大数量项中的很少一部分进行了评分。例如，在Mendeley，我们有数以百万计的文章而一个用户可能只读了其中几百篇文章。两个读过100篇文章的用户有一篇相同文章的概率（共5000万篇文章）是0.0002。

基于模型的方法可以帮助克服一些基于邻域的方法的局限性。它不像基于邻域的方法，使用用户项评分直接预测新的项。基于模型的方法会在使用评分去学习预测模型的基础上，去预测新项。一般的想法是使用机器学习算法建立用户和项的相互作用模型，从而找出数据中的模式。在一般情况下，基于模型的CF被认为是建立CF推荐系统的更先进的算法。有许多不同的算法可用于构建模型并基于这些模型进行预测，例如，贝叶斯网络、聚类、分类、回归、矩阵分解、受限玻尔兹曼机等等。这些技术在为了最终赢得Netflix奖的解决方案中扮演了关键角色。Netflix发起了一个竞赛，从2006年到2009年提供一百万美元奖金，颁发给产生的推荐比他们自己的推荐系统精确10%以上的推荐系统团队。成功获奖的解决方案是Netflix研发的一个集成（即混合）了超过100种算法模型，这些算法模型都采用了矩阵分解和受限玻尔兹曼机。

矩阵因子分解（如奇异值分解，奇异值分解+ +）将项和用户都转化成了相同的潜在空间，它所代表了用户和项之间的潜相互作用（图8）。矩阵分解背后的原理是潜在特征代表了用户如何给项进行评分。给定用户和项的潜在描述，我们可以预测用户将会给还未评价的项多少评分。


CF倾向于推荐流行的项，很难推荐给有独特口味的人（即感兴趣的项并没有产生足够多的惯用数据）。这被称为流行性偏见，它通常是用基于内容的过滤方法。CF方法的一个更重要的限制是我们所称的“冷启动问题”，系统是不能够给没有（或非常少）惯用活动的用户进行推荐，又名曰新用户问题，或推荐新项问题。新用户的“冷启动问题”可以通过**流行性**和**混合方法**进行解决，而新项问题可以通过使用基于内容的过滤或multi-armed bandits（即探索利用）进行解决。我们将在下一篇文章中讨论上述方法中的一些方法。


基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但**它们所不同的是如何计算用户的相似度**，**基于人口统计学的机制只考虑用户本身的特征**，而**基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度**，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。


http://muricoca.github.io/crab/


[推荐算法之 slope one 算法-CSDN](http://blog.csdn.net/xidianliutingting/article/details/51916578)  
[推荐算法之 Slope One 算法-博客园](http://www.cnblogs.com/breezedeus/archive/2011/03/11/1981781.html)  
[经典算法题每日演练——第六题 协同推荐SlopeOne 算法](http://www.cnblogs.com/huangxincheng/archive/2012/11/22/2782647.html)  
[使用SVD++进行协同过滤(算法原理部分主要引用自他人)-布布扣-bubu----](https://www.baidu.com/link?url=Ui4bNxhMd7u9o4dcW2dzty0ycRpGU_NfmvsZ4f7suTkircfCO7_iS_bTWh9xEFXC7CkdlGau7H-2OOK7DixlA_&wd=&eqid=e56f8b2a0003f17100000002596f820c)

>【参考资料】  
>[推荐系统的常用算法概述](http://www.cnblogs.com/luchen927/archive/2012/02/04/2334316.html)  
>[推荐算法综述（一）](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)  
>[从算法到案例：推荐系统必读的10篇精选技术文章](http://www.infoq.com/cn/news/2015/12/Algorithm-case-10)  
> [机器学习相关——协同过滤](http://www.cnblogs.com/luchen927/archive/2012/02/01/2325360.html)  
>[推荐引擎初探](https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html)



---
<link rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/default.min.css">
<script src="http://yandex.st/highlightjs/6.1/highlight.min.js"></script>
<script>
hljs.tabReplace = ' ';
hljs.initHighlightingOnLoad();
</script>


来源：[http://leunggeorge.github.io/](http://leunggeorge.github.io/)  
